{"ast":null,"code":"import _regeneratorRuntime from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, util } from '@tensorflow/tfjs-core';\nvar whereImpl = kernel_impls.whereImpl;\nimport { assertNotComplex } from './cpu_util';\nexport var MathBackendCPU = /*#__PURE__*/function (_KernelBackend) {\n  _inherits(MathBackendCPU, _KernelBackend);\n  var _super = _createSuper(MathBackendCPU);\n  function MathBackendCPU() {\n    var _this;\n    _classCallCheck(this, MathBackendCPU);\n    _this = _super.call(this);\n    _this.blockSize = 48;\n    _this.firstUse = true;\n    _this.data = new DataStorage(_assertThisInitialized(_this), engine());\n    return _this;\n  }\n  _createClass(MathBackendCPU, [{\n    key: \"nextDataId\",\n    value: function nextDataId() {\n      return MathBackendCPU.nextDataId++;\n    }\n  }, {\n    key: \"write\",\n    value: function write(values, shape, dtype) {\n      if (this.firstUse) {\n        this.firstUse = false;\n        if (env().get('IS_NODE')) {\n          backend_util.warn('\\n============================\\n' + 'Hi, looks like you are running TensorFlow.js in ' + 'Node.js. To speed things up dramatically, install our node ' + 'backend, visit https://github.com/tensorflow/tfjs-node for more details. ' + '\\n============================');\n        }\n      }\n      var dataId = {\n        id: this.nextDataId()\n      };\n      this.data.set(dataId, {\n        values: values,\n        dtype: dtype,\n        refCount: 1\n      });\n      return dataId;\n    }\n    /**\n     * Create a data bucket in cpu backend.\n     * @param shape Shape of the `TensorInfo`.\n     * @param dtype DType of the `TensorInfo`.\n     * @param values The value of the `TensorInfo` stored as a flattened array.\n     */\n  }, {\n    key: \"makeTensorInfo\",\n    value: function makeTensorInfo(shape, dtype, values) {\n      var outId;\n      if (dtype === 'string' && values != null && values.length > 0 && util.isString(values[0])) {\n        var encodedValues = values.map(function (d) {\n          return util.encodeString(d);\n        });\n        outId = this.write(encodedValues, shape, dtype);\n      } else {\n        outId = this.write(values, shape, dtype);\n      }\n      return {\n        dataId: outId,\n        shape: shape,\n        dtype: dtype\n      };\n    }\n    /** Return refCount of a `TensorData`. */\n  }, {\n    key: \"refCount\",\n    value: function refCount(dataId) {\n      if (this.data.has(dataId)) {\n        var tensorData = this.data.get(dataId);\n        return tensorData.refCount;\n      }\n      return 0;\n    }\n    /** Increase refCount of a `TensorData`. */\n  }, {\n    key: \"incRef\",\n    value: function incRef(dataId) {\n      var tensorData = this.data.get(dataId);\n      tensorData.refCount++;\n    }\n    /** Decrease refCount of a `TensorData`. */\n  }, {\n    key: \"decRef\",\n    value: function decRef(dataId) {\n      if (this.data.has(dataId)) {\n        var tensorData = this.data.get(dataId);\n        tensorData.refCount--;\n      }\n    }\n  }, {\n    key: \"move\",\n    value: function move(dataId, values, shape, dtype, refCount) {\n      this.data.set(dataId, {\n        values: values,\n        dtype: dtype,\n        refCount: refCount\n      });\n    }\n  }, {\n    key: \"numDataIds\",\n    value: function numDataIds() {\n      return this.data.numDataIds();\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dataId) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.readSync(dataId));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function read(_x) {\n        return _read.apply(this, arguments);\n      }\n      return read;\n    }()\n  }, {\n    key: \"readSync\",\n    value: function readSync(dataId) {\n      var _this$data$get = this.data.get(dataId),\n        dtype = _this$data$get.dtype,\n        complexTensorInfos = _this$data$get.complexTensorInfos;\n      if (dtype === 'complex64') {\n        var realValues = this.readSync(complexTensorInfos.real.dataId);\n        var imagValues = this.readSync(complexTensorInfos.imag.dataId);\n        return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n      }\n      return util.convertBackendValuesAndArrayBuffer(this.data.get(dataId).values, dtype);\n    }\n  }, {\n    key: \"bufferSync\",\n    value: function bufferSync(t) {\n      var data = this.readSync(t.dataId);\n      if (t.dtype === 'string') {\n        try {\n          // Decode the bytes into string.\n          var strings = data.map(function (d) {\n            return util.decodeString(d);\n          });\n          return buffer(t.shape, t.dtype, strings);\n        } catch (_a) {\n          throw new Error('Failed to decode encoded string bytes into utf-8');\n        }\n      }\n      return buffer(t.shape, t.dtype, data);\n    }\n  }, {\n    key: \"makeOutput\",\n    value: function makeOutput(values, shape, dtype) {\n      return engine().makeTensorFromTensorInfo(this.makeTensorInfo(shape, dtype, values), this);\n    }\n    /**\n     * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n     * is released or memory is not managed in this backend, false if memory is\n     * not cleared.\n     * @param dataId\n     * @oaram force Optional, remove the data regardless of refCount\n     */\n  }, {\n    key: \"disposeData\",\n    value: function disposeData(dataId) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.data.has(dataId)) {\n        this.data.get(dataId).refCount--;\n        if (!force && this.data.get(dataId).refCount > 0) {\n          return false;\n        }\n        var _this$data$get2 = this.data.get(dataId),\n          complexTensorInfos = _this$data$get2.complexTensorInfos;\n        if (complexTensorInfos != null) {\n          this.disposeData(complexTensorInfos.real.dataId, true);\n          this.disposeData(complexTensorInfos.imag.dataId, true);\n        }\n        this.data.delete(dataId);\n      }\n      return true;\n    }\n  }, {\n    key: \"disposeIntermediateTensorInfo\",\n    value: function disposeIntermediateTensorInfo(tensorInfo) {\n      this.disposeData(tensorInfo.dataId);\n    }\n  }, {\n    key: \"time\",\n    value: function () {\n      var _time = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(f) {\n        var start, kernelMs;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              start = util.now();\n              f();\n              kernelMs = util.now() - start;\n              return _context2.abrupt(\"return\", {\n                kernelMs: kernelMs\n              });\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function time(_x2) {\n        return _time.apply(this, arguments);\n      }\n      return time;\n    }()\n  }, {\n    key: \"memory\",\n    value: function memory() {\n      return {\n        // Unreliable due to automatic gc. The numbers above are cumulative.\n        unreliable: true,\n        reasons: ['The reported memory is an upper bound. Due to automatic garbage ' + 'collection, the true allocated memory may be less.']\n      };\n    }\n  }, {\n    key: \"where\",\n    value: function where(condition) {\n      assertNotComplex([condition], 'where');\n      var condVals = this.readSync(condition.dataId);\n      return whereImpl(condition.shape, condVals);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {}\n  }, {\n    key: \"floatPrecision\",\n    value: function floatPrecision() {\n      return 32;\n    }\n    /** Returns the smallest representable number.  */\n  }, {\n    key: \"epsilon\",\n    value: function epsilon() {\n      return _get(_getPrototypeOf(MathBackendCPU.prototype), \"epsilon\", this).call(this);\n    }\n  }]);\n  return MathBackendCPU;\n}(KernelBackend);\nMathBackendCPU.nextDataId = 0;","map":{"version":3,"mappings":"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","names":["backend_util","buffer","DataStorage","engine","env","kernel_impls","KernelBackend","util","whereImpl","assertNotComplex","MathBackendCPU","data","nextDataId","values","shape","dtype","firstUse","get","warn","dataId","id","set","refCount","outId","length","isString","encodedValues","map","encodeString","d","write","has","tensorData","numDataIds","readSync","complexTensorInfos","realValues","real","imagValues","imag","mergeRealAndImagArrays","convertBackendValuesAndArrayBuffer","t","strings","decodeString","Error","makeTensorFromTensorInfo","makeTensorInfo","force","disposeData","delete","tensorInfo","f","start","now","kernelMs","unreliable","reasons","condition","condVals"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-backend-cpu\\src\\backend_cpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BackendTimingInfo, buffer, DataStorage, DataType, engine, env, kernel_impls, KernelBackend, Rank, ShapeMap, Tensor, Tensor2D, TensorBuffer, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nconst whereImpl = kernel_impls.whereImpl;\nimport {assertNotComplex} from './cpu_util';\n\ninterface DataId {}\n\nexport interface TensorData<D extends DataType> {\n  values?: backend_util.BackendValues;\n  dtype: D;\n  // For complex numbers, the real and imaginary parts are stored as their own\n  // individual tensors, with a parent joining the two with the\n  // complexTensorInfos field.\n  complexTensorInfos?: {real: TensorInfo, imag: TensorInfo};\n  // refCount keeps track of how many tensors reference it. Used for memory\n  // management.\n  refCount: number;\n}\n\nexport class MathBackendCPU extends KernelBackend {\n  public blockSize = 48;\n\n  data: DataStorage<TensorData<DataType>>;\n  private firstUse = true;\n  private static nextDataId = 0;\n  private nextDataId(): number {\n    return MathBackendCPU.nextDataId++;\n  }\n\n  constructor() {\n    super();\n    this.data = new DataStorage(this, engine());\n  }\n\n  override write(\n      values: backend_util.BackendValues, shape: number[],\n      dtype: DataType): DataId {\n    if (this.firstUse) {\n      this.firstUse = false;\n      if (env().get('IS_NODE')) {\n        backend_util.warn(\n            '\\n============================\\n' +\n            'Hi, looks like you are running TensorFlow.js in ' +\n            'Node.js. To speed things up dramatically, install our node ' +\n            'backend, visit https://github.com/tensorflow/tfjs-node for more details. ' +\n            '\\n============================');\n      }\n    }\n    const dataId = {id: this.nextDataId()};\n\n    this.data.set(dataId, {values, dtype, refCount: 1});\n\n    return dataId;\n  }\n\n  /**\n   * Create a data bucket in cpu backend.\n   * @param shape Shape of the `TensorInfo`.\n   * @param dtype DType of the `TensorInfo`.\n   * @param values The value of the `TensorInfo` stored as a flattened array.\n   */\n  makeTensorInfo(\n      shape: number[], dtype: DataType,\n      values?: backend_util.BackendValues|string[]): TensorInfo {\n    let outId;\n    if (dtype === 'string' && values != null && values.length > 0 &&\n        util.isString(values[0])) {\n      const encodedValues =\n          (values as unknown as string[]).map(d => util.encodeString(d));\n\n      outId = this.write(encodedValues, shape, dtype);\n    } else {\n      outId = this.write(values as TypedArray, shape, dtype);\n    }\n\n    return {dataId: outId, shape, dtype};\n  }\n\n  /** Return refCount of a `TensorData`. */\n  override refCount(dataId: DataId): number {\n    if (this.data.has(dataId)) {\n      const tensorData = this.data.get(dataId);\n      return tensorData.refCount;\n    }\n    return 0;\n  }\n\n  /** Increase refCount of a `TensorData`. */\n  override incRef(dataId: DataId): void {\n    const tensorData = this.data.get(dataId);\n    tensorData.refCount++;\n  }\n\n  /** Decrease refCount of a `TensorData`. */\n  decRef(dataId: DataId): void {\n    if (this.data.has(dataId)) {\n      const tensorData = this.data.get(dataId);\n      tensorData.refCount--;\n    }\n  }\n\n  override move(\n      dataId: DataId, values: backend_util.BackendValues, shape: number[],\n      dtype: DataType, refCount: number): void {\n    this.data.set(dataId, {values, dtype, refCount});\n  }\n\n  override numDataIds(): number {\n    return this.data.numDataIds();\n  }\n\n  override async read(dataId: DataId): Promise<backend_util.BackendValues> {\n    return this.readSync(dataId);\n  }\n  override readSync(dataId: DataId): backend_util.BackendValues {\n    const {dtype, complexTensorInfos} = this.data.get(dataId);\n\n    if (dtype === 'complex64') {\n      const realValues =\n          this.readSync(complexTensorInfos.real.dataId) as Float32Array;\n      const imagValues =\n          this.readSync(complexTensorInfos.imag.dataId) as Float32Array;\n      return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    }\n    return util.convertBackendValuesAndArrayBuffer(\n        this.data.get(dataId).values, dtype);\n  }\n\n  bufferSync<R extends Rank, D extends DataType>(t: TensorInfo):\n      TensorBuffer<R, D> {\n    const data = this.readSync(t.dataId);\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        const strings = (data as Uint8Array[]).map(d => util.decodeString(d));\n        return buffer(t.shape as ShapeMap[R], t.dtype, strings) as\n            TensorBuffer<R, D>;\n      } catch {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n    return buffer(t.shape as ShapeMap[R], t.dtype, data as TypedArray) as\n        TensorBuffer<R, D>;\n  }\n\n  makeOutput<T extends Tensor>(\n      values: backend_util.BackendValues, shape: number[], dtype: DataType): T {\n    return engine().makeTensorFromTensorInfo(\n               this.makeTensorInfo(shape, dtype, values), this) as T;\n  }\n\n  /**\n   * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n   * is released or memory is not managed in this backend, false if memory is\n   * not cleared.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n  override disposeData(dataId: DataId, force = false): boolean {\n    if (this.data.has(dataId)) {\n      this.data.get(dataId).refCount--;\n      if (!force && this.data.get(dataId).refCount > 0) {\n        return false;\n      }\n\n      const {complexTensorInfos} = this.data.get(dataId);\n\n      if (complexTensorInfos != null) {\n        this.disposeData(complexTensorInfos.real.dataId, true);\n        this.disposeData(complexTensorInfos.imag.dataId, true);\n      }\n\n      this.data.delete(dataId);\n    }\n    return true;\n  }\n\n  disposeIntermediateTensorInfo(tensorInfo: TensorInfo): void {\n    this.disposeData(tensorInfo.dataId);\n  }\n\n  override async time(f: () => void): Promise<BackendTimingInfo> {\n    const start = util.now();\n    f();\n    const kernelMs = util.now() - start;\n    return {kernelMs};\n  }\n\n  override memory() {\n    return {\n      // Unreliable due to automatic gc. The numbers above are cumulative.\n      unreliable: true,\n      reasons:\n          ['The reported memory is an upper bound. Due to automatic garbage ' +\n           'collection, the true allocated memory may be less.']\n    };\n  }\n\n  where(condition: Tensor): Tensor2D {\n    assertNotComplex([condition], 'where');\n\n    const condVals = this.readSync(condition.dataId) as TypedArray;\n    return whereImpl(condition.shape, condVals);\n  }\n\n  override dispose() {}\n\n  override floatPrecision(): 16|32 {\n    return 32;\n  }\n\n  /** Returns the smallest representable number.  */\n  override epsilon(): number {\n    return super.epsilon();\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}