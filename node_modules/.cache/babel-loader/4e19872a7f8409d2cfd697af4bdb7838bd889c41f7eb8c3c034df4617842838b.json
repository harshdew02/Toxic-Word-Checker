{"ast":null,"code":"import _toConsumableArray from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n  var usedNodes = new Set();\n  var missingInputs = [];\n  var dynamicNode = null;\n  var syncInputs = null;\n  // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n  var seen = new Set();\n  var inputNodeNames = Object.keys(inputs).map(function (name) {\n    return parseNodeName(name)[0];\n  });\n  var initNodeNames = [];\n  if (initNodes != null) {\n    initNodeNames = initNodes.map(function (node) {\n      return parseNodeName(node.name)[0];\n    });\n  }\n  var frontier = _toConsumableArray(outputs);\n  while (frontier.length > 0) {\n    var node = frontier.pop();\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(function (child) {\n          return child.name;\n        }).filter(function (name) {\n          return usedNodes.has(name);\n        });\n      }\n    }\n    usedNodes.add(node.name);\n    // Weights are dead end since we already have their values.\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n    // This node is a dead end since it's one of the user-provided inputs.\n    if (inputNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n    // This node is a dead end since it doesn't have any inputs.\n    if (initNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n    node.inputs.forEach(function (input) {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n  return {\n    inputs: inputs,\n    outputs: outputs,\n    usedNodes: usedNodes,\n    missingInputs: missingInputs,\n    dynamicNode: dynamicNode,\n    syncInputs: syncInputs\n  };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n  var usedNodes = executionInfo.usedNodes,\n    inputs = executionInfo.inputs;\n  var frontier = [];\n  var inputNodes = Object.keys(inputs).map(function (name) {\n    return parseNodeName(name)[0];\n  }).map(function (name) {\n    return graph.nodes[name];\n  });\n  var initNodes = graph.initNodes;\n  inputNodes.forEach(function (input) {\n    if (usedNodes.has(input.name)) {\n      frontier.push(input);\n    }\n  });\n  graph.weights.forEach(function (weight) {\n    if (usedNodes.has(weight.name)) {\n      frontier.push(weight);\n    }\n  });\n  if (initNodes != null) {\n    initNodes.forEach(function (node) {\n      if (usedNodes.has(node.name)) {\n        frontier.push(node);\n      }\n    });\n  }\n  var seen = new Set();\n  var orderedNodes = [];\n  while (frontier.length > 0) {\n    var node = frontier.pop();\n    seen.add(node.name);\n    if (!weightMap[node.name]) {\n      orderedNodes.push(node);\n    }\n    node.children.forEach(function (child) {\n      if (!seen.has(child.name) && usedNodes.has(child.name) && child.inputs.every(function (input) {\n        return seen.has(input.name);\n      })) {\n        frontier.push(child);\n      }\n    });\n  }\n  return orderedNodes;\n}\nvar CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf', 'StatelessWhile', 'if', 'While'];\nvar DYNAMIC_SHAPE_OPS = ['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'];\nvar HASH_TABLE_OPS = ['HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2', 'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'];\nexport function isControlFlow(node) {\n  return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nexport function isDynamicShape(node) {\n  return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\nexport function isHashTable(node) {\n  return HASH_TABLE_OPS.indexOf(node.op) >= 0;\n}","map":{"version":3,"mappings":"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","names":["parseNodeName","getExecutionSubgraph","inputs","outputs","weightMap","initNodes","usedNodes","Set","missingInputs","dynamicNode","syncInputs","seen","inputNodeNames","Object","keys","map","name","initNodeNames","node","frontier","length","pop","isControlFlow","isDynamicShape","isHashTable","children","child","filter","has","add","indexOf","push","forEach","input","getNodesInTopologicalOrder","graph","executionInfo","inputNodes","nodes","weights","weight","orderedNodes","every","CONTROL_FLOW_OPS","DYNAMIC_SHAPE_OPS","HASH_TABLE_OPS","op"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-converter\\src\\executor\\model_analysis.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NamedTensorMap} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap} from '../data/types';\nimport {parseNodeName} from '../operations/executors/utils';\nimport {Graph, Node} from '../operations/types';\n\nexport interface ExecutionInfo {\n  inputs: NamedTensorMap;\n  outputs: Node[];\n  usedNodes: Set<string>;\n  missingInputs: string[];\n  dynamicNode: Node;\n  syncInputs: string[];\n}\n\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(\n    inputs: NamedTensorMap, outputs: Node[], weightMap: NamedTensorsMap,\n    initNodes?: Node[]): ExecutionInfo {\n  const usedNodes = new Set<string>();\n  const missingInputs: string[] = [];\n  let dynamicNode: Node = null;\n  let syncInputs: string[] = null;\n\n  // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n  const seen = new Set<string>();\n  const inputNodeNames =\n      Object.keys(inputs).map(name => parseNodeName(name)[0]);\n\n  let initNodeNames: string[] = [];\n  if (initNodes != null) {\n    initNodeNames = initNodes.map(node => parseNodeName(node.name)[0]);\n  }\n\n  const frontier = [...outputs];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name)\n                         .filter(name => usedNodes.has(name));\n      }\n    }\n    usedNodes.add(node.name);\n\n    // Weights are dead end since we already have their values.\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n    // This node is a dead end since it's one of the user-provided inputs.\n    if (inputNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n    // This node is a dead end since it doesn't have any inputs.\n    if (initNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n  return {inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs};\n}\n\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(\n    graph: Graph, weightMap: NamedTensorsMap,\n    executionInfo: ExecutionInfo): Node[] {\n  const {usedNodes, inputs} = executionInfo;\n  const frontier: Node[] = [];\n  const inputNodes = Object.keys(inputs)\n                         .map(name => parseNodeName(name)[0])\n                         .map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes;\n\n  inputNodes.forEach(input => {\n    if (usedNodes.has(input.name)) {\n      frontier.push(input);\n    }\n  });\n  graph.weights.forEach(weight => {\n    if (usedNodes.has(weight.name)) {\n      frontier.push(weight);\n    }\n  });\n  if (initNodes != null) {\n    initNodes.forEach(node => {\n      if (usedNodes.has(node.name)) {\n        frontier.push(node);\n      }\n    });\n  }\n  const seen = new Set<string>();\n  const orderedNodes: Node[] = [];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    seen.add(node.name);\n    if (!weightMap[node.name]) {\n      orderedNodes.push(node);\n    }\n    node.children.forEach(child => {\n      if (!seen.has(child.name) && usedNodes.has(child.name) &&\n          child.inputs.every(input => seen.has(input.name))) {\n        frontier.push(child);\n      }\n    });\n  }\n  return orderedNodes;\n}\n\nconst CONTROL_FLOW_OPS = [\n  'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',\n  'StatelessWhile', 'if', 'While'\n];\nconst DYNAMIC_SHAPE_OPS = [\n  'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'\n];\nconst HASH_TABLE_OPS = [\n  'HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2',\n  'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'\n];\n\nexport function isControlFlow(node: Node) {\n  return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\n\nexport function isDynamicShape(node: Node) {\n  return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\n\nexport function isHashTable(node: Node) {\n  return HASH_TABLE_OPS.indexOf(node.op) >= 0;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}