{"ast":null,"code":"import _createForOfIteratorHelper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { LazyIterator, OneToManyIterator } from './lazy_iterator';\nexport var StringIterator = /*#__PURE__*/function (_LazyIterator) {\n  _inherits(StringIterator, _LazyIterator);\n  var _super = _createSuper(StringIterator);\n  function StringIterator() {\n    _classCallCheck(this, StringIterator);\n    return _super.apply(this, arguments);\n  }\n  _createClass(StringIterator, [{\n    key: \"split\",\n    value:\n    /**\n     * Splits a string stream on a given separator.\n     *\n     * It is assumed that the incoming chunk boundaries have no semantic meaning,\n     * so conceptually the incoming stream is treated simply as the concatenation\n     * of its elements.\n     *\n     * The outgoing stream provides chunks corresponding to the results of the\n     * standard string split() operation (even if such a chunk spanned incoming\n     * chunks).  The separators are not included.\n     *\n     * A typical usage is to split a text file (represented as a stream with\n     * arbitrary chunk boundaries) into lines.\n     *\n     * @param upstream A readable stream of strings that can be treated as\n     *   concatenated.\n     * @param separator A character to split on.\n     */\n    function split(separator) {\n      return new SplitIterator(this, separator);\n    }\n  }]);\n  return StringIterator;\n}(LazyIterator);\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on StringIterator.  Unfortunately they can't be placed in separate files, due\n// to resulting trouble with circular imports.\n// ============================================================================\n// We wanted multiple inheritance, e.g.\n//   class SplitIterator extends QueueIterator<string>, StringIterator\n// but the TypeScript mixin approach is a bit hacky, so we take this adapter\n// approach instead.\nvar SplitIterator = /*#__PURE__*/function (_StringIterator) {\n  _inherits(SplitIterator, _StringIterator);\n  var _super2 = _createSuper(SplitIterator);\n  function SplitIterator(upstream, separator) {\n    var _this;\n    _classCallCheck(this, SplitIterator);\n    _this = _super2.call(this);\n    _this.upstream = upstream;\n    _this.impl = new SplitIteratorImpl(upstream, separator);\n    return _this;\n  }\n  _createClass(SplitIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return this.impl.summary();\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.impl.next());\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function next() {\n        return _next.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return SplitIterator;\n}(StringIterator);\nvar SplitIteratorImpl = /*#__PURE__*/function (_OneToManyIterator) {\n  _inherits(SplitIteratorImpl, _OneToManyIterator);\n  var _super3 = _createSuper(SplitIteratorImpl);\n  function SplitIteratorImpl(upstream, separator) {\n    var _this2;\n    _classCallCheck(this, SplitIteratorImpl);\n    _this2 = _super3.call(this);\n    _this2.upstream = upstream;\n    _this2.separator = separator;\n    // A partial string at the end of an upstream chunk\n    _this2.carryover = '';\n    return _this2;\n  }\n  _createClass(SplitIteratorImpl, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Split('\").concat(this.separator, \"')\");\n    }\n  }, {\n    key: \"pump\",\n    value: function () {\n      var _pump = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var chunkResult, lines, _iterator, _step, line;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.upstream.next();\n            case 2:\n              chunkResult = _context2.sent;\n              if (!chunkResult.done) {\n                _context2.next = 9;\n                break;\n              }\n              if (!(this.carryover === '')) {\n                _context2.next = 6;\n                break;\n              }\n              return _context2.abrupt(\"return\", false);\n            case 6:\n              // Pretend that the pump succeeded in order to emit the small last batch.\n              // The next pump() call will actually fail.\n              this.outputQueue.push(this.carryover);\n              this.carryover = '';\n              return _context2.abrupt(\"return\", true);\n            case 9:\n              lines = chunkResult.value.split(this.separator); // Note the behavior: \" ab \".split(' ') === ['', 'ab', '']\n              // Thus the carryover may be '' if the separator falls on a chunk\n              // boundary; this produces the correct result.\n              lines[0] = this.carryover + lines[0];\n              _iterator = _createForOfIteratorHelper(lines.slice(0, -1));\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  line = _step.value;\n                  this.outputQueue.push(line);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              this.carryover = lines[lines.length - 1];\n              return _context2.abrupt(\"return\", true);\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function pump() {\n        return _pump.apply(this, arguments);\n      }\n      return pump;\n    }()\n  }]);\n  return SplitIteratorImpl;\n}(OneToManyIterator);","map":{"version":3,"mappings":";;;;;;;AAAA;;;;;;;;;;;;;;;;;AAkBA,SAAQA,YAAY,EAAEC,iBAAiB,QAAO,iBAAiB;AAE/D,WAAsBC,cAAe;EAAA;EAAA;EAAA;IAAA;IAAA;EAAA;EAAA;IAAA;IAAA;IACnC;;;;;;;;;;;;;;;;;;IAkBA,eAAMC,SAAiB;MACrB,OAAO,IAAIC,aAAa,CAAC,IAAI,EAAED,SAAS,CAAC;IAC3C;EAAC;EAAA;AAAA,EArB0CH,YAAoB;AAwBjE;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA,IAEMI,aAAc;EAAA;EAAA;EAGlB,uBAAsBC,QAA8B,EAAEF,SAAiB;IAAA;IAAA;IACrE;IADoB,cAAQ,GAARE,QAAQ;IAE5B,MAAKC,IAAI,GAAG,IAAIC,iBAAiB,CAACF,QAAQ,EAAEF,SAAS,CAAC;IAAC;EACzD;EAAC;IAAA;IAAA,OAED,mBAAO;MACL,OAAO,IAAI,CAACG,IAAI,CAACE,OAAO,EAAE;IAC5B;EAAC;IAAA;IAAA;MAAA,uEAED;QAAA;UAAA;YAAA;cAAA,iCACS,IAAI,CAACF,IAAI,CAACG,IAAI,EAAE;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CACxB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA,EAdyBP,cAAc;AAAA,IAiBpCK,iBAAkB;EAAA;EAAA;EAItB,2BACcF,QAA8B,EAAYF,SAAiB;IAAA;IAAA;IACvE;IADY,eAAQ,GAARE,QAAQ;IAAkC,gBAAS,GAATF,SAAS;IAJjE;IACA,gBAAS,GAAG,EAAE;IAAC;EAKf;EAAC;IAAA;IAAA,OAED,mBAAO;MACL,iBAAU,IAAI,CAACE,QAAQ,CAACG,OAAO,EAAE,wBAAc,IAAI,CAACL,SAAS;IAC/D;EAAC;IAAA;IAAA;MAAA,uEAED;QAAA;QAAA;UAAA;YAAA;cAAA;cAAA,OAC4B,IAAI,CAACE,QAAQ,CAACI,IAAI,EAAE;YAAA;cAAxCC,WAAW;cAAA,KACbA,WAAW,CAACC,IAAI;gBAAA;gBAAA;cAAA;cAAA,MACd,IAAI,CAACC,SAAS,KAAK,EAAE;gBAAA;gBAAA;cAAA;cAAA,kCAChB,KAAK;YAAA;cAGd;cACA;cACA,IAAI,CAACC,WAAW,CAACC,IAAI,CAAC,IAAI,CAACF,SAAS,CAAC;cACrC,IAAI,CAACA,SAAS,GAAG,EAAE;cAAC,kCACb,IAAI;YAAA;cAEPG,KAAK,GAAGL,WAAW,CAACM,KAAK,CAACC,KAAK,CAAC,IAAI,CAACd,SAAS,CAAa,EACjE;cACA;cACA;cAEAY,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAACH,SAAS,GAAGG,KAAK,CAAC,CAAC,CAAC;cAAC,uCAClBA,KAAK,CAACG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;cAAA;gBAArC,oDAAuC;kBAA5BC,IAAI;kBACb,IAAI,CAACN,WAAW,CAACC,IAAI,CAACK,IAAI,CAAC;;cAC5B;gBAAA;cAAA;gBAAA;cAAA;cACD,IAAI,CAACP,SAAS,GAAGG,KAAK,CAACA,KAAK,CAACK,MAAM,GAAG,CAAC,CAAC;cAAC,kCAElC,IAAI;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CACZ;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA,EAtC6BnB,iBAAyB","names":["LazyIterator","OneToManyIterator","StringIterator","separator","SplitIterator","upstream","impl","SplitIteratorImpl","summary","next","chunkResult","done","carryover","outputQueue","push","lines","value","split","slice","line","length"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-data\\src\\iterators\\string_iterator.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {LazyIterator, OneToManyIterator} from './lazy_iterator';\n\nexport abstract class StringIterator extends LazyIterator<string> {\n  /**\n   * Splits a string stream on a given separator.\n   *\n   * It is assumed that the incoming chunk boundaries have no semantic meaning,\n   * so conceptually the incoming stream is treated simply as the concatenation\n   * of its elements.\n   *\n   * The outgoing stream provides chunks corresponding to the results of the\n   * standard string split() operation (even if such a chunk spanned incoming\n   * chunks).  The separators are not included.\n   *\n   * A typical usage is to split a text file (represented as a stream with\n   * arbitrary chunk boundaries) into lines.\n   *\n   * @param upstream A readable stream of strings that can be treated as\n   *   concatenated.\n   * @param separator A character to split on.\n   */\n  split(separator: string): StringIterator {\n    return new SplitIterator(this, separator);\n  }\n}\n\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on StringIterator.  Unfortunately they can't be placed in separate files, due\n// to resulting trouble with circular imports.\n// ============================================================================\n\n// We wanted multiple inheritance, e.g.\n//   class SplitIterator extends QueueIterator<string>, StringIterator\n// but the TypeScript mixin approach is a bit hacky, so we take this adapter\n// approach instead.\n\nclass SplitIterator extends StringIterator {\n  private impl: SplitIteratorImpl;\n\n  constructor(protected upstream: LazyIterator<string>, separator: string) {\n    super();\n    this.impl = new SplitIteratorImpl(upstream, separator);\n  }\n\n  summary() {\n    return this.impl.summary();\n  }\n\n  async next() {\n    return this.impl.next();\n  }\n}\n\nclass SplitIteratorImpl extends OneToManyIterator<string> {\n  // A partial string at the end of an upstream chunk\n  carryover = '';\n\n  constructor(\n      protected upstream: LazyIterator<string>, protected separator: string) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Split('${this.separator}')`;\n  }\n\n  async pump(): Promise<boolean> {\n    const chunkResult = await this.upstream.next();\n    if (chunkResult.done) {\n      if (this.carryover === '') {\n        return false;\n      }\n\n      // Pretend that the pump succeeded in order to emit the small last batch.\n      // The next pump() call will actually fail.\n      this.outputQueue.push(this.carryover);\n      this.carryover = '';\n      return true;\n    }\n    const lines = chunkResult.value.split(this.separator) as string[];\n    // Note the behavior: \" ab \".split(' ') === ['', 'ab', '']\n    // Thus the carryover may be '' if the separator falls on a chunk\n    // boundary; this produces the correct result.\n\n    lines[0] = this.carryover + lines[0];\n    for (const line of lines.slice(0, -1)) {\n      this.outputQueue.push(line);\n    }\n    this.carryover = lines[lines.length - 1];\n\n    return true;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}