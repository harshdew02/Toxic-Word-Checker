{"ast":null,"code":"import _slicedToArray from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer, CropAndResize, util } from '@tensorflow/tfjs-core';\nexport function cropAndResize(args) {\n  var inputs = args.inputs,\n    backend = args.backend,\n    attrs = args.attrs;\n  var image = inputs.image,\n    boxes = inputs.boxes,\n    boxInd = inputs.boxInd;\n  var cropSize = attrs.cropSize,\n    method = attrs.method,\n    extrapolationValue = attrs.extrapolationValue;\n  var _image$shape = _slicedToArray(image.shape, 4),\n    batch = _image$shape[0],\n    imageHeight = _image$shape[1],\n    imageWidth = _image$shape[2],\n    numChannels = _image$shape[3];\n  var numBoxes = boxes.shape[0];\n  var _cropSize = _slicedToArray(cropSize, 2),\n    cropHeight = _cropSize[0],\n    cropWidth = _cropSize[1];\n  var output = buffer([numBoxes, cropHeight, cropWidth, numChannels], 'float32');\n  var boxVals = backend.data.get(boxes.dataId).values;\n  var boxIndVals = backend.data.get(boxInd.dataId).values;\n  var imageVals = backend.data.get(image.dataId).values;\n  var inStride = util.computeStrides(image.shape); // to calculate flat indexes into image\n  var outStride = util.computeStrides(output.shape); // to calculate flat indexes into output\n  // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc\n  for (var b = 0; b < numBoxes; b++) {\n    var startInd = b * 4;\n    var y1 = boxVals[startInd];\n    var x1 = boxVals[startInd + 1];\n    var y2 = boxVals[startInd + 2];\n    var x2 = boxVals[startInd + 3];\n    var bInd = boxIndVals[b];\n    if (bInd >= batch) {\n      continue;\n    }\n    var heightScale = cropHeight > 1 ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;\n    var widthScale = cropWidth > 1 ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;\n    for (var y = 0; y < cropHeight; y++) {\n      var yInd = cropHeight > 1 ? y1 * (imageHeight - 1) + y * heightScale : 0.5 * (y1 + y2) * (imageHeight - 1);\n      if (yInd < 0 || yInd > imageHeight - 1) {\n        for (var x = 0; x < cropWidth; x++) {\n          for (var c = 0; c < numChannels; c++) {\n            var ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[ind] = extrapolationValue;\n          }\n        }\n        continue;\n      }\n      if (method === 'bilinear') {\n        var topInd = Math.floor(yInd);\n        var bottomInd = Math.ceil(yInd);\n        var yLerp = yInd - topInd;\n        for (var _x = 0; _x < cropWidth; _x++) {\n          var xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + _x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);\n          if (xInd < 0 || xInd > imageWidth - 1) {\n            for (var _c = 0; _c < numChannels; _c++) {\n              var _ind = _c + _x * outStride[2] + y * outStride[1] + b * outStride[0];\n              output.values[_ind] = extrapolationValue;\n            }\n            continue;\n          }\n          var leftInd = Math.floor(xInd);\n          var rightInd = Math.ceil(xInd);\n          var xLerp = xInd - leftInd;\n          for (var _c2 = 0; _c2 < numChannels; _c2++) {\n            var _ind2 = _c2 + leftInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];\n            var topLeft = imageVals[_ind2];\n            _ind2 = _c2 + rightInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];\n            var topRight = imageVals[_ind2];\n            _ind2 = _c2 + leftInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];\n            var bottomLeft = imageVals[_ind2];\n            _ind2 = _c2 + rightInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];\n            var bottomRight = imageVals[_ind2];\n            var top = topLeft + (topRight - topLeft) * xLerp;\n            var bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;\n            _ind2 = _c2 + _x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[_ind2] = top + (bottom - top) * yLerp;\n          }\n        }\n      } else {\n        // method == \"nearest\"\n        for (var _x2 = 0; _x2 < cropWidth; ++_x2) {\n          var _xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + _x2 * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);\n          if (_xInd < 0 || _xInd > imageWidth - 1) {\n            for (var _c3 = 0; _c3 < numChannels; _c3++) {\n              var _ind3 = _c3 + _x2 * outStride[2] + y * outStride[1] + b * outStride[0];\n              output.values[_ind3] = extrapolationValue;\n            }\n            continue;\n          }\n          var closestX = Math.round(_xInd);\n          var closestY = Math.round(yInd);\n          for (var _c4 = 0; _c4 < numChannels; _c4++) {\n            var inInd = _c4 + closestX * inStride[2] + closestY * inStride[1] + bInd * inStride[0];\n            var outInd = _c4 + _x2 * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[outInd] = imageVals[inInd];\n          }\n        }\n      }\n    }\n  }\n  return backend.makeTensorInfo(output.shape, output.dtype, output.values);\n}\nexport var cropAndResizeConfig = {\n  kernelName: CropAndResize,\n  backendName: 'cpu',\n  kernelFunc: cropAndResize\n};","map":{"version":3,"mappings":"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","names":["buffer","CropAndResize","util","cropAndResize","args","inputs","backend","attrs","image","boxes","boxInd","cropSize","method","extrapolationValue","shape","batch","imageHeight","imageWidth","numChannels","numBoxes","cropHeight","cropWidth","output","boxVals","data","get","dataId","values","boxIndVals","imageVals","inStride","computeStrides","outStride","b","startInd","y1","x1","y2","x2","bInd","heightScale","widthScale","y","yInd","x","c","ind","topInd","Math","floor","bottomInd","ceil","yLerp","xInd","leftInd","rightInd","xLerp","topLeft","topRight","bottomLeft","bottomRight","top","bottom","closestX","round","closestY","inInd","outInd","makeTensorInfo","dtype","cropAndResizeConfig","kernelName","backendName","kernelFunc"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-backend-cpu\\src\\kernels\\CropAndResize.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, CropAndResize, CropAndResizeAttrs, CropAndResizeInputs, KernelConfig, KernelFunc, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport function cropAndResize(args: {\n  inputs: CropAndResizeInputs,\n  backend: MathBackendCPU,\n  attrs: CropAndResizeAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {image, boxes, boxInd} = inputs;\n  const {cropSize, method, extrapolationValue} = attrs;\n\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const numBoxes = boxes.shape[0];\n\n  const [cropHeight, cropWidth] = cropSize;\n  const output =\n      buffer([numBoxes, cropHeight, cropWidth, numChannels], 'float32');\n\n  const boxVals = backend.data.get(boxes.dataId).values as TypedArray;\n  const boxIndVals = backend.data.get(boxInd.dataId).values as TypedArray;\n  const imageVals = backend.data.get(image.dataId).values as TypedArray;\n\n  const inStride =\n      util.computeStrides(image.shape);  // to calculate flat indexes into image\n  const outStride = util.computeStrides(\n      output.shape);  // to calculate flat indexes into output\n\n  // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc\n  for (let b = 0; b < numBoxes; b++) {\n    const startInd = b * 4;\n    const y1 = boxVals[startInd];\n    const x1 = boxVals[startInd + 1];\n    const y2 = boxVals[startInd + 2];\n    const x2 = boxVals[startInd + 3];\n\n    const bInd: number = boxIndVals[b];\n    if (bInd >= batch) {\n      continue;\n    }\n\n    const heightScale =\n        (cropHeight > 1) ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;\n    const widthScale =\n        (cropWidth > 1) ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;\n\n    for (let y = 0; y < cropHeight; y++) {\n      const yInd: number = (cropHeight > 1) ?\n          y1 * (imageHeight - 1) + y * (heightScale) :\n          0.5 * (y1 + y2) * (imageHeight - 1);\n\n      if (yInd < 0 || yInd > imageHeight - 1) {\n        for (let x = 0; x < cropWidth; x++) {\n          for (let c = 0; c < numChannels; c++) {\n            const ind =\n                c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[ind] = extrapolationValue;\n          }\n        }\n        continue;\n      }\n\n      if (method === 'bilinear') {\n        const topInd = Math.floor(yInd);\n        const bottomInd = Math.ceil(yInd);\n        const yLerp = yInd - topInd;\n\n        for (let x = 0; x < cropWidth; x++) {\n          const xInd = (cropWidth > 1) ?\n              x1 * (imageWidth - 1) + x * widthScale :\n              0.5 * (x1 + x2) * (imageWidth - 1);\n\n          if (xInd < 0 || xInd > imageWidth - 1) {\n            for (let c = 0; c < numChannels; c++) {\n              const ind =\n                  c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n              output.values[ind] = extrapolationValue;\n            }\n            continue;\n          }\n\n          const leftInd = Math.floor(xInd);\n          const rightInd = Math.ceil(xInd);\n          const xLerp = xInd - leftInd;\n\n          for (let c = 0; c < numChannels; c++) {\n            let ind = c + leftInd * inStride[2] + topInd * inStride[1] +\n                bInd * inStride[0];\n            const topLeft = imageVals[ind];\n\n            ind = c + rightInd * inStride[2] + topInd * inStride[1] +\n                bInd * inStride[0];\n            const topRight = imageVals[ind];\n\n            ind = c + leftInd * inStride[2] + bottomInd * inStride[1] +\n                bInd * inStride[0];\n            const bottomLeft = imageVals[ind];\n\n            ind = c + rightInd * inStride[2] + bottomInd * inStride[1] +\n                bInd * inStride[0];\n            const bottomRight = imageVals[ind];\n\n            const top = topLeft + (topRight - topLeft) * xLerp;\n            const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;\n\n            ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[ind] = top + ((bottom - top) * yLerp);\n          }\n        }\n      } else {  // method == \"nearest\"\n        for (let x = 0; x < cropWidth; ++x) {\n          const xInd = (cropWidth > 1) ?\n              x1 * (imageWidth - 1) + x * widthScale :\n              0.5 * (x1 + x2) * (imageWidth - 1);\n\n          if (xInd < 0 || xInd > imageWidth - 1) {\n            for (let c = 0; c < numChannels; c++) {\n              const ind =\n                  c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n              output.values[ind] = extrapolationValue;\n            }\n            continue;\n          }\n\n          const closestX = Math.round(xInd);\n          const closestY = Math.round(yInd);\n          for (let c = 0; c < numChannels; c++) {\n            const inInd = c + closestX * inStride[2] + closestY * inStride[1] +\n                bInd * inStride[0];\n            const outInd =\n                c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[outInd] = imageVals[inInd];\n          }\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo(output.shape, output.dtype, output.values);\n}\n\nexport const cropAndResizeConfig: KernelConfig = {\n  kernelName: CropAndResize,\n  backendName: 'cpu',\n  kernelFunc: cropAndResize as unknown as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}