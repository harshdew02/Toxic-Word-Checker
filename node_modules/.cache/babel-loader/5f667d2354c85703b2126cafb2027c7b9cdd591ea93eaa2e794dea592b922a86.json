{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LRNGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function lRNGrad(args) {\n  var inputs = args.inputs,\n    backend = args.backend,\n    attrs = args.attrs;\n  var x = inputs.x,\n    y = inputs.y,\n    dy = inputs.dy;\n  var depthRadius = attrs.depthRadius,\n    bias = attrs.bias,\n    alpha = attrs.alpha,\n    beta = attrs.beta;\n  assertNotComplex(dy, 'LRNGrad');\n  var dySize = util.sizeFromShape(dy.shape);\n  var channels = dy.shape[3];\n  var dyValues = backend.data.get(dy.dataId).values;\n  var xValues = backend.data.get(x.dataId).values;\n  var yValues = backend.data.get(y.dataId).values;\n  var result = new Float32Array(dySize);\n  var size = dySize;\n  for (var offset = 0; offset < size; offset++) {\n    var currentChannel = offset % channels;\n    var depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n    var depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);\n    var norm = 0;\n    for (var k = depthBegin; k < depthEnd; k++) {\n      norm += Math.pow(xValues[k], 2);\n    }\n    norm = alpha * norm + bias;\n    for (var _k = depthBegin; _k < depthEnd; _k++) {\n      var dyi = -2 * alpha * beta * xValues[_k] * yValues[offset] / norm;\n      if (offset === _k) {\n        dyi += Math.pow(norm, -beta);\n      }\n      dyi *= dyValues[offset];\n      result[_k] += dyi;\n    }\n  }\n  return backend.makeTensorInfo(dy.shape, x.dtype, result);\n}\n// tslint:disable-next-line: variable-name\nexport var LRNGradConfig = {\n  kernelName: LRNGrad,\n  backendName: 'cpu',\n  kernelFunc: lRNGrad\n};","map":{"version":3,"mappings":"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","names":["LRNGrad","util","assertNotComplex","lRNGrad","args","inputs","backend","attrs","x","y","dy","depthRadius","bias","alpha","beta","dySize","sizeFromShape","shape","channels","dyValues","data","get","dataId","values","xValues","yValues","result","Float32Array","size","offset","currentChannel","depthBegin","Math","max","depthEnd","min","norm","k","pow","dyi","makeTensorInfo","dtype","LRNGradConfig","kernelName","backendName","kernelFunc"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-backend-cpu\\src\\kernels\\LRNGrad.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LRNGrad, LRNGradAttrs, LRNGradInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nexport function lRNGrad(\n    args:\n        {inputs: LRNGradInputs, backend: MathBackendCPU, attrs: LRNGradAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, y, dy} = inputs;\n  const {depthRadius, bias, alpha, beta} = attrs;\n\n  assertNotComplex(dy, 'LRNGrad');\n\n  const dySize = util.sizeFromShape(dy.shape);\n\n  const channels = dy.shape[3];\n  const dyValues = backend.data.get(dy.dataId).values as TypedArray;\n  const xValues = backend.data.get(x.dataId).values as TypedArray;\n  const yValues = backend.data.get(y.dataId).values as TypedArray;\n  const result = new Float32Array(dySize);\n  const size = dySize;\n\n  for (let offset = 0; offset < size; offset++) {\n    const currentChannel = offset % channels;\n    const depthBegin =\n        (offset - currentChannel) + Math.max(0, currentChannel - depthRadius);\n    const depthEnd = (offset - currentChannel) +\n        Math.min(channels, currentChannel + depthRadius + 1);\n\n    let norm = 0;\n    for (let k = depthBegin; k < depthEnd; k++) {\n      norm += Math.pow(xValues[k], 2);\n    }\n    norm = alpha * norm + bias;\n\n    for (let k = depthBegin; k < depthEnd; k++) {\n      let dyi = -2 * alpha * beta * xValues[k] * yValues[offset] / norm;\n      if (offset === k) {\n        dyi += Math.pow(norm, -beta);\n      }\n      dyi *= dyValues[offset];\n      result[k] += dyi;\n    }\n  }\n\n  return backend.makeTensorInfo(dy.shape, x.dtype, result);\n}\n\n// tslint:disable-next-line: variable-name\nexport const LRNGradConfig: KernelConfig = {\n  kernelName: LRNGrad,\n  backendName: 'cpu',\n  kernelFunc: lRNGrad as unknown as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}