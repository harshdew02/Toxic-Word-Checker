{"ast":null,"code":"import _toConsumableArray from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _assertThisInitialized from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\nexport var ModelLoggingVerbosity;\n(function (ModelLoggingVerbosity) {\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\nexport var DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport var BaseCallback = /*#__PURE__*/function () {\n  function BaseCallback() {\n    _classCallCheck(this, BaseCallback);\n    // TODO(michaelterry): This type is a best guess.\n    this.validationData = null;\n  }\n  _createClass(BaseCallback, [{\n    key: \"setParams\",\n    value: function setParams(params) {\n      this.params = params;\n    }\n  }, {\n    key: \"onEpochBegin\",\n    value: function () {\n      var _onEpochBegin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(epoch, logs) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function onEpochBegin(_x, _x2) {\n        return _onEpochBegin.apply(this, arguments);\n      }\n      return onEpochBegin;\n    }()\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(epoch, logs) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function onEpochEnd(_x3, _x4) {\n        return _onEpochEnd.apply(this, arguments);\n      }\n      return onEpochEnd;\n    }()\n  }, {\n    key: \"onBatchBegin\",\n    value: function () {\n      var _onBatchBegin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(batch, logs) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      function onBatchBegin(_x5, _x6) {\n        return _onBatchBegin.apply(this, arguments);\n      }\n      return onBatchBegin;\n    }()\n  }, {\n    key: \"onBatchEnd\",\n    value: function () {\n      var _onBatchEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(batch, logs) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n      function onBatchEnd(_x7, _x8) {\n        return _onBatchEnd.apply(this, arguments);\n      }\n      return onBatchEnd;\n    }()\n  }, {\n    key: \"onTrainBegin\",\n    value: function () {\n      var _onTrainBegin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(logs) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5);\n      }));\n      function onTrainBegin(_x9) {\n        return _onTrainBegin.apply(this, arguments);\n      }\n      return onTrainBegin;\n    }()\n  }, {\n    key: \"onTrainEnd\",\n    value: function () {\n      var _onTrainEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(logs) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6);\n      }));\n      function onTrainEnd(_x10) {\n        return _onTrainEnd.apply(this, arguments);\n      }\n      return onTrainEnd;\n    }() // LayersModel needs to call Callback.setModel(), but cannot actually depend\n    // on Callback because that creates a cyclic dependency.  Providing this no-op\n    // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n    // BaseCallback but not on Callback.  The argument is typed as `Container`\n    // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n    // overrides this method and enforces that the argument is really a\n    // LayersModel.\n  }, {\n    key: \"setModel\",\n    value: function setModel(model) {\n      // Do nothing. Use Callback instead of BaseCallback to track the model.\n    }\n  }]);\n  return BaseCallback;\n}();\n/**\n * Container abstracting a list of callbacks.\n */\nexport var CallbackList = /*#__PURE__*/function () {\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n  /**\n   * Constructor of CallbackList.\n   * @param callbacks Array of `Callback` instances.\n   * @param queueLength Queue length for keeping running statistics over\n   *   callback execution time.\n   */\n  function CallbackList(callbacks) {\n    var queueLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    _classCallCheck(this, CallbackList);\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n  _createClass(CallbackList, [{\n    key: \"append\",\n    value: function append(callback) {\n      this.callbacks.push(callback);\n    }\n  }, {\n    key: \"setParams\",\n    value: function setParams(params) {\n      var _iterator = _createForOfIteratorHelper(this.callbacks),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var callback = _step.value;\n          callback.setParams(params);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"setModel\",\n    value: function setModel(model) {\n      var _iterator2 = _createForOfIteratorHelper(this.callbacks),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var callback = _step2.value;\n          callback.setModel(model);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Called at the start of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n  }, {\n    key: \"onEpochBegin\",\n    value: function () {\n      var _onEpochBegin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(epoch, logs) {\n        var _iterator3, _step3, callback;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              _iterator3 = _createForOfIteratorHelper(this.callbacks);\n              _context7.prev = 2;\n              _iterator3.s();\n            case 4:\n              if ((_step3 = _iterator3.n()).done) {\n                _context7.next = 10;\n                break;\n              }\n              callback = _step3.value;\n              _context7.next = 8;\n              return callback.onEpochBegin(epoch, logs);\n            case 8:\n              _context7.next = 4;\n              break;\n            case 10:\n              _context7.next = 15;\n              break;\n            case 12:\n              _context7.prev = 12;\n              _context7.t0 = _context7[\"catch\"](2);\n              _iterator3.e(_context7.t0);\n            case 15:\n              _context7.prev = 15;\n              _iterator3.f();\n              return _context7.finish(15);\n            case 18:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[2, 12, 15, 18]]);\n      }));\n      function onEpochBegin(_x11, _x12) {\n        return _onEpochBegin2.apply(this, arguments);\n      }\n      return onEpochBegin;\n    }()\n    /**\n     * Called at the end of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(epoch, logs) {\n        var _iterator4, _step4, callback;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              _iterator4 = _createForOfIteratorHelper(this.callbacks);\n              _context8.prev = 2;\n              _iterator4.s();\n            case 4:\n              if ((_step4 = _iterator4.n()).done) {\n                _context8.next = 10;\n                break;\n              }\n              callback = _step4.value;\n              _context8.next = 8;\n              return callback.onEpochEnd(epoch, logs);\n            case 8:\n              _context8.next = 4;\n              break;\n            case 10:\n              _context8.next = 15;\n              break;\n            case 12:\n              _context8.prev = 12;\n              _context8.t0 = _context8[\"catch\"](2);\n              _iterator4.e(_context8.t0);\n            case 15:\n              _context8.prev = 15;\n              _iterator4.f();\n              return _context8.finish(15);\n            case 18:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[2, 12, 15, 18]]);\n      }));\n      function onEpochEnd(_x13, _x14) {\n        return _onEpochEnd2.apply(this, arguments);\n      }\n      return onEpochEnd;\n    }()\n    /**\n     * Called  right before processing a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n  }, {\n    key: \"onBatchBegin\",\n    value: function () {\n      var _onBatchBegin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(batch, logs) {\n        var _iterator5, _step5, callback;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              _iterator5 = _createForOfIteratorHelper(this.callbacks);\n              _context9.prev = 2;\n              _iterator5.s();\n            case 4:\n              if ((_step5 = _iterator5.n()).done) {\n                _context9.next = 10;\n                break;\n              }\n              callback = _step5.value;\n              _context9.next = 8;\n              return callback.onBatchBegin(batch, logs);\n            case 8:\n              _context9.next = 4;\n              break;\n            case 10:\n              _context9.next = 15;\n              break;\n            case 12:\n              _context9.prev = 12;\n              _context9.t0 = _context9[\"catch\"](2);\n              _iterator5.e(_context9.t0);\n            case 15:\n              _context9.prev = 15;\n              _iterator5.f();\n              return _context9.finish(15);\n            case 18:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[2, 12, 15, 18]]);\n      }));\n      function onBatchBegin(_x15, _x16) {\n        return _onBatchBegin2.apply(this, arguments);\n      }\n      return onBatchBegin;\n    }()\n    /**\n     * Called at the end of a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n  }, {\n    key: \"onBatchEnd\",\n    value: function () {\n      var _onBatchEnd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(batch, logs) {\n        var _iterator6, _step6, callback;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              _iterator6 = _createForOfIteratorHelper(this.callbacks);\n              _context10.prev = 2;\n              _iterator6.s();\n            case 4:\n              if ((_step6 = _iterator6.n()).done) {\n                _context10.next = 10;\n                break;\n              }\n              callback = _step6.value;\n              _context10.next = 8;\n              return callback.onBatchEnd(batch, logs);\n            case 8:\n              _context10.next = 4;\n              break;\n            case 10:\n              _context10.next = 15;\n              break;\n            case 12:\n              _context10.prev = 12;\n              _context10.t0 = _context10[\"catch\"](2);\n              _iterator6.e(_context10.t0);\n            case 15:\n              _context10.prev = 15;\n              _iterator6.f();\n              return _context10.finish(15);\n            case 18:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this, [[2, 12, 15, 18]]);\n      }));\n      function onBatchEnd(_x17, _x18) {\n        return _onBatchEnd2.apply(this, arguments);\n      }\n      return onBatchEnd;\n    }()\n    /**\n     * Called at the beginning of training.\n     * @param logs Dictionary of logs.\n     */\n  }, {\n    key: \"onTrainBegin\",\n    value: function () {\n      var _onTrainBegin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(logs) {\n        var _iterator7, _step7, callback;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              _iterator7 = _createForOfIteratorHelper(this.callbacks);\n              _context11.prev = 2;\n              _iterator7.s();\n            case 4:\n              if ((_step7 = _iterator7.n()).done) {\n                _context11.next = 10;\n                break;\n              }\n              callback = _step7.value;\n              _context11.next = 8;\n              return callback.onTrainBegin(logs);\n            case 8:\n              _context11.next = 4;\n              break;\n            case 10:\n              _context11.next = 15;\n              break;\n            case 12:\n              _context11.prev = 12;\n              _context11.t0 = _context11[\"catch\"](2);\n              _iterator7.e(_context11.t0);\n            case 15:\n              _context11.prev = 15;\n              _iterator7.f();\n              return _context11.finish(15);\n            case 18:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this, [[2, 12, 15, 18]]);\n      }));\n      function onTrainBegin(_x19) {\n        return _onTrainBegin2.apply(this, arguments);\n      }\n      return onTrainBegin;\n    }()\n    /**\n     * Called at the end of training.\n     * @param logs Dictionary of logs.\n     */\n  }, {\n    key: \"onTrainEnd\",\n    value: function () {\n      var _onTrainEnd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(logs) {\n        var _iterator8, _step8, callback;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              _iterator8 = _createForOfIteratorHelper(this.callbacks);\n              _context12.prev = 2;\n              _iterator8.s();\n            case 4:\n              if ((_step8 = _iterator8.n()).done) {\n                _context12.next = 10;\n                break;\n              }\n              callback = _step8.value;\n              _context12.next = 8;\n              return callback.onTrainEnd(logs);\n            case 8:\n              _context12.next = 4;\n              break;\n            case 10:\n              _context12.next = 15;\n              break;\n            case 12:\n              _context12.prev = 12;\n              _context12.t0 = _context12[\"catch\"](2);\n              _iterator8.e(_context12.t0);\n            case 15:\n              _context12.prev = 15;\n              _iterator8.f();\n              return _context12.finish(15);\n            case 18:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this, [[2, 12, 15, 18]]);\n      }));\n      function onTrainEnd(_x20) {\n        return _onTrainEnd2.apply(this, arguments);\n      }\n      return onTrainEnd;\n    }()\n  }]);\n  return CallbackList;\n}();\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport var BaseLogger = /*#__PURE__*/function (_BaseCallback) {\n  _inherits(BaseLogger, _BaseCallback);\n  var _super = _createSuper(BaseLogger);\n  function BaseLogger() {\n    _classCallCheck(this, BaseLogger);\n    return _super.call(this);\n  }\n  _createClass(BaseLogger, [{\n    key: \"onEpochBegin\",\n    value: function () {\n      var _onEpochBegin3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(epoch) {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              this.seen = 0;\n              this.totals = {};\n            case 2:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function onEpochBegin(_x21) {\n        return _onEpochBegin3.apply(this, arguments);\n      }\n      return onEpochBegin;\n    }()\n  }, {\n    key: \"onBatchEnd\",\n    value: function () {\n      var _onBatchEnd3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(batch, logs) {\n        var _this = this;\n        var batchSize, _loop, key;\n        return _regeneratorRuntime().wrap(function _callee14$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              batchSize = logs['size'] == null ? 0 : logs['size'];\n              this.seen += batchSize;\n              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(key) {\n                var value, oldTotalsToDispose, total;\n                return _regeneratorRuntime().wrap(function _loop$(_context14) {\n                  while (1) switch (_context14.prev = _context14.next) {\n                    case 0:\n                      value = logs[key];\n                      if (typeof value === 'number') {\n                        if (!_this.totals.hasOwnProperty(key)) {\n                          _this.totals[key] = 0;\n                        }\n                        _this.totals[key] = _this.totals[key] + value * batchSize;\n                      } else {\n                        if (key in _this.totals) {\n                          oldTotalsToDispose = _this.totals[key];\n                        } else {\n                          _this.totals[key] = 0;\n                        }\n                        total = tidy(function () {\n                          return add(_this.totals[key], mul(value, batchSize));\n                        });\n                        _this.totals[key] = total;\n                        if (oldTotalsToDispose != null) {\n                          oldTotalsToDispose.dispose();\n                        }\n                      }\n                    case 2:\n                    case \"end\":\n                      return _context14.stop();\n                  }\n                }, _loop);\n              });\n              _context15.t0 = _regeneratorRuntime().keys(logs);\n            case 5:\n              if ((_context15.t1 = _context15.t0()).done) {\n                _context15.next = 10;\n                break;\n              }\n              key = _context15.t1.value;\n              return _context15.delegateYield(_loop(key), \"t2\", 8);\n            case 8:\n              _context15.next = 5;\n              break;\n            case 10:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee14, this);\n      }));\n      function onBatchEnd(_x22, _x23) {\n        return _onBatchEnd3.apply(this, arguments);\n      }\n      return onBatchEnd;\n    }()\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(epoch, logs) {\n        var _this2 = this;\n        var _iterator9, _step9, _loop2, _ret;\n        return _regeneratorRuntime().wrap(function _callee15$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              if (!(logs != null)) {\n                _context17.next = 20;\n                break;\n              }\n              _iterator9 = _createForOfIteratorHelper(this.params['metrics']);\n              _context17.prev = 2;\n              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {\n                var key;\n                return _regeneratorRuntime().wrap(function _loop2$(_context16) {\n                  while (1) switch (_context16.prev = _context16.next) {\n                    case 0:\n                      key = _step9.value;\n                      if (!(_this2.totals[key] == null)) {\n                        _context16.next = 3;\n                        break;\n                      }\n                      return _context16.abrupt(\"return\", \"continue\");\n                    case 3:\n                      if (typeof _this2.totals[key] === 'number') {\n                        logs[key] = _this2.totals[key] / _this2.seen;\n                      } else {\n                        tidy(function () {\n                          var log = mul(div(1, _this2.seen), _this2.totals[key]);\n                          logs[key] = log;\n                          _this2.totals[key].dispose();\n                          keep(logs[key]);\n                        });\n                      }\n                    case 4:\n                    case \"end\":\n                      return _context16.stop();\n                  }\n                }, _loop2);\n              });\n              _iterator9.s();\n            case 5:\n              if ((_step9 = _iterator9.n()).done) {\n                _context17.next = 12;\n                break;\n              }\n              return _context17.delegateYield(_loop2(), \"t0\", 7);\n            case 7:\n              _ret = _context17.t0;\n              if (!(_ret === \"continue\")) {\n                _context17.next = 10;\n                break;\n              }\n              return _context17.abrupt(\"continue\", 10);\n            case 10:\n              _context17.next = 5;\n              break;\n            case 12:\n              _context17.next = 17;\n              break;\n            case 14:\n              _context17.prev = 14;\n              _context17.t1 = _context17[\"catch\"](2);\n              _iterator9.e(_context17.t1);\n            case 17:\n              _context17.prev = 17;\n              _iterator9.f();\n              return _context17.finish(17);\n            case 20:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee15, this, [[2, 14, 17, 20]]);\n      }));\n      function onEpochEnd(_x24, _x25) {\n        return _onEpochEnd3.apply(this, arguments);\n      }\n      return onEpochEnd;\n    }()\n  }]);\n  return BaseLogger;\n}(BaseCallback);\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport var History = /*#__PURE__*/function (_BaseCallback2) {\n  _inherits(History, _BaseCallback2);\n  var _super2 = _createSuper(History);\n  function History() {\n    _classCallCheck(this, History);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(History, [{\n    key: \"onTrainBegin\",\n    value: function () {\n      var _onTrainBegin3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(logs) {\n        return _regeneratorRuntime().wrap(function _callee16$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              this.epoch = [];\n              this.history = {};\n            case 2:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee16, this);\n      }));\n      function onTrainBegin(_x26) {\n        return _onTrainBegin3.apply(this, arguments);\n      }\n      return onTrainBegin;\n    }()\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(epoch, logs) {\n        var key;\n        return _regeneratorRuntime().wrap(function _callee17$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              if (logs == null) {\n                logs = {};\n              }\n              this.epoch.push(epoch);\n              for (key in logs) {\n                if (this.history[key] == null) {\n                  this.history[key] = [];\n                }\n                this.history[key].push(logs[key]);\n              }\n            case 3:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee17, this);\n      }));\n      function onEpochEnd(_x27, _x28) {\n        return _onEpochEnd4.apply(this, arguments);\n      }\n      return onEpochEnd;\n    }()\n    /**\n     * Await the values of all losses and metrics.\n     */\n  }, {\n    key: \"syncData\",\n    value: function () {\n      var _syncData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var promises, keys, indices, key, valueArray, i, valueScalar, values, n, tensorToDispose;\n        return _regeneratorRuntime().wrap(function _callee18$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              promises = [];\n              keys = [];\n              indices = [];\n              for (key in this.history) {\n                valueArray = this.history[key];\n                for (i = 0; i < valueArray.length; ++i) {\n                  if (typeof valueArray[i] !== 'number') {\n                    valueScalar = valueArray[i];\n                    promises.push(valueScalar.data());\n                    keys.push(key);\n                    indices.push(i);\n                  }\n                }\n              }\n              _context20.next = 6;\n              return Promise.all(promises);\n            case 6:\n              values = _context20.sent;\n              for (n = 0; n < values.length; ++n) {\n                tensorToDispose = this.history[keys[n]][indices[n]];\n                tensorToDispose.dispose();\n                this.history[keys[n]][indices[n]] = values[n][0];\n              }\n            case 8:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee18, this);\n      }));\n      function syncData() {\n        return _syncData.apply(this, arguments);\n      }\n      return syncData;\n    }()\n  }]);\n  return History;\n}(BaseCallback);\n/**\n * Custom callback for training.\n */\nexport var CustomCallback = /*#__PURE__*/function (_BaseCallback3) {\n  _inherits(CustomCallback, _BaseCallback3);\n  var _super3 = _createSuper(CustomCallback);\n  function CustomCallback(args, yieldEvery) {\n    var _this3;\n    _classCallCheck(this, CustomCallback);\n    _this3 = _super3.call(this);\n    _this3.currentEpoch = 0;\n    _this3.nowFunc = args.nowFunc;\n    _this3.nextFrameFunc = args.nextFrameFunc || nextFrame;\n    _this3.yieldEvery = yieldEvery || 'auto';\n    if (_this3.yieldEvery === 'auto') {\n      _this3.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n    if (_this3.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' + 'Either change `yieldEvery` or remove the callback');\n    }\n    if (util.isNumber(_this3.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      _this3.maybeWait = generic_utils.debounce(_this3.maybeWait.bind(_assertThisInitialized(_this3)), _this3.yieldEvery, _this3.nowFunc);\n    }\n    _this3.trainBegin = args.onTrainBegin;\n    _this3.trainEnd = args.onTrainEnd;\n    _this3.epochBegin = args.onEpochBegin;\n    _this3.epochEnd = args.onEpochEnd;\n    _this3.batchBegin = args.onBatchBegin;\n    _this3.batchEnd = args.onBatchEnd;\n    _this3.yield = args.onYield;\n    return _this3;\n  }\n  _createClass(CustomCallback, [{\n    key: \"maybeWait\",\n    value: function () {\n      var _maybeWait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(epoch, batch, logs) {\n        var ps;\n        return _regeneratorRuntime().wrap(function _callee19$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              ps = [];\n              if (!(this.yield != null)) {\n                _context21.next = 5;\n                break;\n              }\n              _context21.next = 4;\n              return resolveScalarsInLogs(logs);\n            case 4:\n              ps.push(this.yield(epoch, batch, logs));\n            case 5:\n              ps.push(this.nextFrameFunc());\n              _context21.next = 8;\n              return Promise.all(ps);\n            case 8:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee19, this);\n      }));\n      function maybeWait(_x29, _x30, _x31) {\n        return _maybeWait.apply(this, arguments);\n      }\n      return maybeWait;\n    }()\n  }, {\n    key: \"onEpochBegin\",\n    value: function () {\n      var _onEpochBegin4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(epoch, logs) {\n        return _regeneratorRuntime().wrap(function _callee20$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              this.currentEpoch = epoch;\n              if (!(this.epochBegin != null)) {\n                _context22.next = 6;\n                break;\n              }\n              _context22.next = 4;\n              return resolveScalarsInLogs(logs);\n            case 4:\n              _context22.next = 6;\n              return this.epochBegin(epoch, logs);\n            case 6:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee20, this);\n      }));\n      function onEpochBegin(_x32, _x33) {\n        return _onEpochBegin4.apply(this, arguments);\n      }\n      return onEpochBegin;\n    }()\n  }, {\n    key: \"onEpochEnd\",\n    value: function () {\n      var _onEpochEnd5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(epoch, logs) {\n        var ps;\n        return _regeneratorRuntime().wrap(function _callee21$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              ps = [];\n              if (!(this.epochEnd != null)) {\n                _context23.next = 5;\n                break;\n              }\n              _context23.next = 4;\n              return resolveScalarsInLogs(logs);\n            case 4:\n              ps.push(this.epochEnd(epoch, logs));\n            case 5:\n              if (this.yieldEvery === 'epoch') {\n                ps.push(this.nextFrameFunc());\n              }\n              _context23.next = 8;\n              return Promise.all(ps);\n            case 8:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee21, this);\n      }));\n      function onEpochEnd(_x34, _x35) {\n        return _onEpochEnd5.apply(this, arguments);\n      }\n      return onEpochEnd;\n    }()\n  }, {\n    key: \"onBatchBegin\",\n    value: function () {\n      var _onBatchBegin3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(batch, logs) {\n        return _regeneratorRuntime().wrap(function _callee22$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              if (!(this.batchBegin != null)) {\n                _context24.next = 5;\n                break;\n              }\n              _context24.next = 3;\n              return resolveScalarsInLogs(logs);\n            case 3:\n              _context24.next = 5;\n              return this.batchBegin(batch, logs);\n            case 5:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee22, this);\n      }));\n      function onBatchBegin(_x36, _x37) {\n        return _onBatchBegin3.apply(this, arguments);\n      }\n      return onBatchBegin;\n    }()\n  }, {\n    key: \"onBatchEnd\",\n    value: function () {\n      var _onBatchEnd4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(batch, logs) {\n        var ps;\n        return _regeneratorRuntime().wrap(function _callee23$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              ps = [];\n              if (!(this.batchEnd != null)) {\n                _context25.next = 5;\n                break;\n              }\n              _context25.next = 4;\n              return resolveScalarsInLogs(logs);\n            case 4:\n              ps.push(this.batchEnd(batch, logs));\n            case 5:\n              if (this.yieldEvery === 'batch') {\n                ps.push(this.nextFrameFunc());\n              } else if (util.isNumber(this.yieldEvery)) {\n                ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n              }\n              _context25.next = 8;\n              return Promise.all(ps);\n            case 8:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee23, this);\n      }));\n      function onBatchEnd(_x38, _x39) {\n        return _onBatchEnd4.apply(this, arguments);\n      }\n      return onBatchEnd;\n    }()\n  }, {\n    key: \"onTrainBegin\",\n    value: function () {\n      var _onTrainBegin4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(logs) {\n        return _regeneratorRuntime().wrap(function _callee24$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              if (!(this.trainBegin != null)) {\n                _context26.next = 5;\n                break;\n              }\n              _context26.next = 3;\n              return resolveScalarsInLogs(logs);\n            case 3:\n              _context26.next = 5;\n              return this.trainBegin(logs);\n            case 5:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee24, this);\n      }));\n      function onTrainBegin(_x40) {\n        return _onTrainBegin4.apply(this, arguments);\n      }\n      return onTrainBegin;\n    }()\n  }, {\n    key: \"onTrainEnd\",\n    value: function () {\n      var _onTrainEnd3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(logs) {\n        return _regeneratorRuntime().wrap(function _callee25$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              if (!(this.trainEnd != null)) {\n                _context27.next = 5;\n                break;\n              }\n              _context27.next = 3;\n              return resolveScalarsInLogs(logs);\n            case 3:\n              _context27.next = 5;\n              return this.trainEnd(logs);\n            case 5:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee25, this);\n      }));\n      function onTrainEnd(_x41) {\n        return _onTrainEnd3.apply(this, arguments);\n      }\n      return onTrainEnd;\n    }()\n  }]);\n  return CustomCallback;\n}(BaseCallback);\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n  if (callbacks == null) {\n    callbacks = {};\n  }\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks;\n  }\n  // Convert custom callback configs to custom callback objects.\n  var callbackConfigs = generic_utils.toList(callbacks);\n  return callbackConfigs.map(function (callbackConfig) {\n    return new CustomCallback(callbackConfig, yieldEvery);\n  });\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport var CallbackConstructorRegistry = /*#__PURE__*/function () {\n  /**\n   * Blocks public access to constructor.\n   */\n  function CallbackConstructorRegistry() {\n    _classCallCheck(this, CallbackConstructorRegistry);\n  }\n  /**\n   * Register a tf.LayersModel.fit() callback constructor.\n   *\n   * The registered callback constructor will be used to instantiate\n   * callbacks for every tf.LayersModel.fit() call afterwards.\n   *\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n   *   is to be reigstered.\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n   * @throws Error, if the same callbackConstructor has been registered before,\n   *   either at the same or a different `verbosityLevel`.\n   */\n  _createClass(CallbackConstructorRegistry, null, [{\n    key: \"registerCallbackConstructor\",\n    value: function registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n      util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), function () {\n        return \"Verbosity level is expected to be an integer >= 0, \" + \"but got \".concat(verbosityLevel);\n      });\n      CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n      if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n        CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n      }\n      CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n    }\n  }, {\n    key: \"checkForDuplicate\",\n    value: function checkForDuplicate(callbackConstructor) {\n      for (var levelName in CallbackConstructorRegistry.constructors) {\n        var constructors = CallbackConstructorRegistry.constructors[+levelName];\n        constructors.forEach(function (ctor) {\n          if (ctor === callbackConstructor) {\n            throw new ValueError('Duplicate callback constructor.');\n          }\n        });\n      }\n    }\n    /**\n     * Clear all registered callback constructors.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      CallbackConstructorRegistry.constructors = {};\n    }\n    /**\n     * Create callbacks using the registered callback constructors.\n     *\n     * Given `verbosityLevel`, all constructors registered at that level or above\n     * will be called and the instantiated callbacks will be used.\n     *\n     * @param verbosityLevel: Level of verbosity.\n     */\n  }, {\n    key: \"createCallbacks\",\n    value: function createCallbacks(verbosityLevel) {\n      var constructors = [];\n      for (var levelName in CallbackConstructorRegistry.constructors) {\n        var level = +levelName;\n        if (verbosityLevel >= level) {\n          constructors.push.apply(constructors, _toConsumableArray(CallbackConstructorRegistry.constructors[level]));\n        }\n      }\n      return constructors.map(function (ctor) {\n        return new ctor();\n      });\n    }\n  }]);\n  return CallbackConstructorRegistry;\n}();\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n  var history = new History();\n  var actualCallbacks = [new BaseLogger()].concat(_toConsumableArray(CallbackConstructorRegistry.createCallbacks(verbose)));\n  if (callbacks != null) {\n    actualCallbacks.push.apply(actualCallbacks, _toConsumableArray(callbacks));\n  }\n  actualCallbacks.push(history);\n  var callbackList = new CallbackList(actualCallbacks);\n  // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n  callbackList.setParams({\n    epochs: epochs,\n    initialEpoch: initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize: batchSize,\n    verbose: verbose,\n    doValidation: doValidation,\n    metrics: callbackMetrics\n  });\n  return {\n    callbackList: callbackList,\n    history: history\n  };\n}","map":{"version":3,"mappings":"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","names":["add","div","keep","mul","nextFrame","tidy","util","ValueError","resolveScalarsInLogs","generic_utils","ModelLoggingVerbosity","DEFAULT_YIELD_EVERY_MS","BaseCallback","params","epoch","logs","batch","model","CallbackList","callbacks","queueLength","callback","push","setParams","setModel","onEpochBegin","onEpochEnd","onBatchBegin","onBatchEnd","onTrainBegin","onTrainEnd","BaseLogger","seen","totals","batchSize","value","key","hasOwnProperty","oldTotalsToDispose","total","dispose","log","History","history","promises","keys","indices","valueArray","i","length","valueScalar","data","Promise","all","values","n","tensorToDispose","CustomCallback","args","yieldEvery","nowFunc","nextFrameFunc","onYield","Error","isNumber","maybeWait","debounce","bind","trainBegin","trainEnd","epochBegin","epochEnd","batchBegin","batchEnd","yield","ps","currentEpoch","standardizeCallbacks","Array","isArray","callbackConfigs","toList","map","callbackConfig","CallbackConstructorRegistry","verbosityLevel","callbackConstructor","assert","Number","isInteger","checkForDuplicate","constructors","levelName","forEach","ctor","level","configureCallbacks","verbose","epochs","initialEpoch","numTrainSamples","stepsPerEpoch","doValidation","callbackMetrics","actualCallbacks","createCallbacks","callbackList","samples","steps","metrics"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-layers\\src\\base_callbacks.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source: keras/callbacks.py */\n\nimport {add, div, keep, mul, nextFrame, Scalar, Tensor, tidy, util} from '@tensorflow/tfjs-core';\n\nimport {Container} from './engine/container';\nimport {ValueError} from './errors';\nimport {Logs, resolveScalarsInLogs, UnresolvedLogs} from './logs';\nimport * as generic_utils from './utils/generic_utils';\n\n/** Verbosity logging level when fitting a model. */\nexport enum ModelLoggingVerbosity {\n  SILENT = 0,\n  VERBOSE = 1\n}\n\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n\nexport type Params = {\n  [key: string]: number|string|boolean|number[]|string[]|boolean[];\n};\n\nexport type YieldEveryOptions = 'auto'|'batch'|'epoch'|'never'|number;\n\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport abstract class BaseCallback {\n  // TODO(michaelterry): This type is a best guess.\n  validationData: Tensor|Tensor[] = null;\n  /**\n   * Training parameters (eg. verbosity, batch size, number of epochs...).\n   */\n  params: Params;\n\n  setParams(params: Params): void {\n    this.params = params;\n  }\n\n  async onEpochBegin(epoch: number, logs?: UnresolvedLogs) {}\n\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {}\n\n  async onBatchBegin(batch: number, logs?: UnresolvedLogs) {}\n\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs) {}\n\n  async onTrainBegin(logs?: UnresolvedLogs) {}\n\n  async onTrainEnd(logs?: UnresolvedLogs) {}\n\n  // LayersModel needs to call Callback.setModel(), but cannot actually depend\n  // on Callback because that creates a cyclic dependency.  Providing this no-op\n  // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n  // BaseCallback but not on Callback.  The argument is typed as `Container`\n  // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n  // overrides this method and enforces that the argument is really a\n  // LayersModel.\n  setModel(model: Container): void {\n    // Do nothing. Use Callback instead of BaseCallback to track the model.\n  }\n}\n\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n  callbacks: BaseCallback[];\n  queueLength: number;\n\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n\n  /**\n   * Constructor of CallbackList.\n   * @param callbacks Array of `Callback` instances.\n   * @param queueLength Queue length for keeping running statistics over\n   *   callback execution time.\n   */\n  constructor(callbacks?: BaseCallback[], queueLength = 10) {\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n\n  append(callback: BaseCallback): void {\n    this.callbacks.push(callback);\n  }\n\n  setParams(params: Params): void {\n    for (const callback of this.callbacks) {\n      callback.setParams(params);\n    }\n  }\n\n  setModel(model: Container): void {\n    for (const callback of this.callbacks) {\n      callback.setModel(model);\n    }\n  }\n\n  /**\n   * Called at the start of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onEpochBegin(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onEpochBegin(epoch, logs);\n    }\n  }\n\n  /**\n   * Called at the end of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onEpochEnd(epoch, logs);\n    }\n  }\n\n  /**\n   * Called  right before processing a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onBatchBegin(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onBatchBegin(batch, logs);\n    }\n  }\n\n  /**\n   * Called at the end of a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onBatchEnd(batch, logs);\n    }\n  }\n\n  /**\n   * Called at the beginning of training.\n   * @param logs Dictionary of logs.\n   */\n  async onTrainBegin(logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onTrainBegin(logs);\n    }\n  }\n\n  /**\n   * Called at the end of training.\n   * @param logs Dictionary of logs.\n   */\n  async onTrainEnd(logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onTrainEnd(logs);\n    }\n  }\n}\n\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n  private seen: number;\n  private totals: UnresolvedLogs;\n\n  constructor() {\n    super();\n  }\n\n  override async onEpochBegin(epoch: number) {\n    this.seen = 0;\n    this.totals = {};\n  }\n\n  override async onBatchEnd(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    const batchSize = logs['size'] == null ? 0 : logs['size'] as number;\n    this.seen += batchSize;\n    for (const key in logs) {\n      const value = logs[key];\n      if (typeof value === 'number') {\n        if (!this.totals.hasOwnProperty(key)) {\n          this.totals[key] = 0;\n        }\n        this.totals[key] = this.totals[key] as number + value * batchSize;\n      } else {\n        let oldTotalsToDispose: Scalar;\n        if (key in this.totals) {\n          oldTotalsToDispose = this.totals[key] as Scalar;\n        } else {\n          this.totals[key] = 0;\n        }\n        const total: Scalar =\n            tidy(() => add((this.totals[key]), mul(value, batchSize)));\n        this.totals[key] = total;\n        if (oldTotalsToDispose != null) {\n          oldTotalsToDispose.dispose();\n        }\n      }\n    }\n  }\n\n  override async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs != null) {\n      for (const key of this.params['metrics'] as string[]) {\n        if (this.totals[key] == null) {\n          continue;\n        }\n        if (typeof this.totals[key] === 'number') {\n          logs[key] = this.totals[key] as number / this.seen;\n        } else {\n          tidy(() => {\n            const log: Scalar = mul(div(1, this.seen), this.totals[key]);\n            logs[key] = log;\n            (this.totals[key] as Tensor).dispose();\n            keep(logs[key] as Scalar);\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n  epoch: number[];\n  history: {[key: string]: Array<number|Tensor>};\n\n  override async onTrainBegin(logs?: UnresolvedLogs) {\n    this.epoch = [];\n    this.history = {};\n  }\n\n  override async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    this.epoch.push(epoch);\n    for (const key in logs) {\n      if (this.history[key] == null) {\n        this.history[key] = [];\n      }\n      this.history[key].push(logs[key]);\n    }\n  }\n\n  /**\n   * Await the values of all losses and metrics.\n   */\n  async syncData() {\n    const promises: Array<Promise<Float32Array|Int32Array|Uint8Array>> = [];\n    const keys: string[] = [];\n    const indices: number[] = [];\n    for (const key in this.history) {\n      const valueArray = this.history[key];\n      for (let i = 0; i < valueArray.length; ++i) {\n        if (typeof valueArray[i] !== 'number') {\n          const valueScalar = valueArray[i] as Tensor;\n          promises.push(valueScalar.data());\n          keys.push(key);\n          indices.push(i);\n        }\n      }\n    }\n    const values = await Promise.all(promises);\n    for (let n = 0; n < values.length; ++n) {\n      const tensorToDispose = this.history[keys[n]][indices[n]] as Tensor;\n      tensorToDispose.dispose();\n      this.history[keys[n]][indices[n]] = values[n][0];\n    }\n  }\n}\n\nexport interface CustomCallbackArgs {\n  onTrainBegin?: (logs?: Logs) => void | Promise<void>;\n  onTrainEnd?: (logs?: Logs) => void | Promise<void>;\n  onEpochBegin?: (epoch: number, logs?: Logs) => void | Promise<void>;\n  onEpochEnd?: (epoch: number, logs?: Logs) => void | Promise<void>;\n  onBatchBegin?: (batch: number, logs?: Logs) => void | Promise<void>;\n  onBatchEnd?: (batch: number, logs?: Logs) => void | Promise<void>;\n  onYield?: (epoch: number, batch: number, logs: Logs) => void | Promise<void>;\n  // Used for test DI mocking.\n  nowFunc?: Function;\n  nextFrameFunc?: Function;\n}\n\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n  protected readonly trainBegin: (logs?: Logs) => void | Promise<void>;\n  protected readonly trainEnd: (logs?: Logs) => void | Promise<void>;\n  protected readonly epochBegin:\n      (epoch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly epochEnd:\n      (epoch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly batchBegin:\n      (batch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly batchEnd:\n      (batch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly yield:\n      (epoch: number, batch: number, logs: Logs) => void | Promise<void>;\n\n  private yieldEvery: YieldEveryOptions;\n  private currentEpoch = 0;\n  public nowFunc: Function;\n  public nextFrameFunc: Function;\n\n  constructor(args: CustomCallbackArgs, yieldEvery?: YieldEveryOptions) {\n    super();\n    this.nowFunc = args.nowFunc;\n    this.nextFrameFunc = args.nextFrameFunc || nextFrame;\n    this.yieldEvery = yieldEvery || 'auto';\n    if (this.yieldEvery === 'auto') {\n      this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n    if (this.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error(\n          'yieldEvery is `never` but you provided an `onYield` callback. ' +\n          'Either change `yieldEvery` or remove the callback');\n    }\n    if (util.isNumber(this.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      this.maybeWait = generic_utils.debounce(\n          this.maybeWait.bind(this), this.yieldEvery as number, this.nowFunc);\n    }\n    this.trainBegin = args.onTrainBegin;\n    this.trainEnd = args.onTrainEnd;\n    this.epochBegin = args.onEpochBegin;\n    this.epochEnd = args.onEpochEnd;\n    this.batchBegin = args.onBatchBegin;\n    this.batchEnd = args.onBatchEnd;\n    this.yield = args.onYield;\n  }\n\n  async maybeWait(epoch: number, batch: number, logs: UnresolvedLogs) {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.yield != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.yield(epoch, batch, logs as Logs));\n    }\n    ps.push(this.nextFrameFunc());\n    await Promise.all(ps);\n  }\n\n  override async onEpochBegin(epoch: number, logs?: UnresolvedLogs):\n      Promise<void> {\n    this.currentEpoch = epoch;\n    if (this.epochBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.epochBegin(epoch, logs as Logs);\n    }\n  }\n\n  override async onEpochEnd(epoch: number, logs?: UnresolvedLogs):\n      Promise<void> {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.epochEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.epochEnd(epoch, logs as Logs));\n    }\n    if (this.yieldEvery === 'epoch') {\n      ps.push(this.nextFrameFunc());\n    }\n    await Promise.all(ps);\n  }\n\n  override async onBatchBegin(batch: number, logs?: UnresolvedLogs):\n      Promise<void> {\n    if (this.batchBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.batchBegin(batch, logs as Logs);\n    }\n  }\n\n  override async onBatchEnd(batch: number, logs?: UnresolvedLogs):\n      Promise<void> {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.batchEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.batchEnd(batch, logs as Logs));\n    }\n    if (this.yieldEvery === 'batch') {\n      ps.push(this.nextFrameFunc());\n    } else if (util.isNumber(this.yieldEvery)) {\n      ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n    }\n    await Promise.all(ps);\n  }\n\n  override async onTrainBegin(logs?: UnresolvedLogs): Promise<void> {\n    if (this.trainBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainBegin(logs as Logs);\n    }\n  }\n\n  override async onTrainEnd(logs?: UnresolvedLogs): Promise<void> {\n    if (this.trainEnd != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainEnd(logs as Logs);\n    }\n  }\n}\n\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(\n    callbacks: BaseCallback|BaseCallback[]|CustomCallbackArgs|\n    CustomCallbackArgs[],\n    yieldEvery: YieldEveryOptions): BaseCallback[] {\n  if (callbacks == null) {\n    callbacks = {} as BaseCallback;\n  }\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks as BaseCallback[];\n  }\n  // Convert custom callback configs to custom callback objects.\n  const callbackConfigs =\n      generic_utils.toList(callbacks) as CustomCallbackArgs[];\n  return callbackConfigs.map(\n      callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n\nexport declare type BaseCallbackConstructor = {\n  new (): BaseCallback\n};\n\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n  private static constructors:\n      {[verbosityLevel: number]: BaseCallbackConstructor[]} = {};\n\n  /**\n   * Blocks public access to constructor.\n   */\n  private constructor() {}\n\n  /**\n   * Register a tf.LayersModel.fit() callback constructor.\n   *\n   * The registered callback constructor will be used to instantiate\n   * callbacks for every tf.LayersModel.fit() call afterwards.\n   *\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n   *   is to be reigstered.\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n   * @throws Error, if the same callbackConstructor has been registered before,\n   *   either at the same or a different `verbosityLevel`.\n   */\n  static registerCallbackConstructor(\n      verbosityLevel: number, callbackConstructor: BaseCallbackConstructor) {\n    util.assert(\n        verbosityLevel >= 0 && Number.isInteger(verbosityLevel),\n        () => `Verbosity level is expected to be an integer >= 0, ` +\n            `but got ${verbosityLevel}`);\n    CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n    if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n      CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n    }\n    CallbackConstructorRegistry.constructors[verbosityLevel].push(\n        callbackConstructor);\n  }\n\n  private static checkForDuplicate(callbackConstructor:\n                                       BaseCallbackConstructor) {\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const constructors = CallbackConstructorRegistry.constructors[+levelName];\n      constructors.forEach(ctor => {\n        if (ctor === callbackConstructor) {\n          throw new ValueError('Duplicate callback constructor.');\n        }\n      });\n    }\n  }\n\n  /**\n   * Clear all registered callback constructors.\n   */\n  protected static clear() {\n    CallbackConstructorRegistry.constructors = {};\n  }\n\n  /**\n   * Create callbacks using the registered callback constructors.\n   *\n   * Given `verbosityLevel`, all constructors registered at that level or above\n   * will be called and the instantiated callbacks will be used.\n   *\n   * @param verbosityLevel: Level of verbosity.\n   */\n  static createCallbacks(verbosityLevel: number): BaseCallback[] {\n    const constructors: BaseCallbackConstructor[] = [];\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const level = +levelName;\n      if (verbosityLevel >= level) {\n        constructors.push(...CallbackConstructorRegistry.constructors[level]);\n      }\n    }\n    return constructors.map(ctor => new ctor());\n  }\n}\n\nexport function configureCallbacks(\n    callbacks: BaseCallback[], verbose: ModelLoggingVerbosity, epochs: number,\n    initialEpoch: number, numTrainSamples: number, stepsPerEpoch: number,\n    batchSize: number, doValidation: boolean,\n    callbackMetrics: string[]): {callbackList: CallbackList, history: History} {\n  const history = new History();\n  const actualCallbacks: BaseCallback[] = [\n    new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)\n  ];\n  if (callbacks != null) {\n    actualCallbacks.push(...callbacks);\n  }\n  actualCallbacks.push(history);\n  const callbackList = new CallbackList(actualCallbacks);\n\n  // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n\n  callbackList.setParams({\n    epochs,\n    initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize,\n    verbose,\n    doValidation,\n    metrics: callbackMetrics,\n  });\n  return {callbackList, history};\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}