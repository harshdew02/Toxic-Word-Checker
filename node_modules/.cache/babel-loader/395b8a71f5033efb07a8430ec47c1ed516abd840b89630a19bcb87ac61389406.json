{"ast":null,"code":"import _regeneratorRuntime from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\n/**\n * Apply a mapping function to a nested structure in a recursive manner.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapResult`.  The `DeepMapResult` either provides a\n *   replacement value for that node (i.e., replacing the subtree), or indicates\n *   that the node should be processed recursively.\n */\nexport function deepMap(input, mapFn) {\n  return deepMapInternal(input, mapFn);\n}\n/**\n * @param seen: A Map of known object mappings (i.e., memoized results of\n *   `mapFn()`)\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\nfunction deepMapInternal(input, mapFn) {\n  var seen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();\n  var containedIn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Set();\n  if (input == null) {\n    return null;\n  }\n  if (typeof Blob === 'function' && input instanceof Blob) {\n    return input.slice();\n  }\n  if (containedIn.has(input)) {\n    throw new Error('Circular references are not supported.');\n  }\n  if (seen.has(input)) {\n    return seen.get(input);\n  }\n  var result = mapFn(input);\n  if (result.recurse && result.value !== null) {\n    throw new Error('A deep map function may not return both a value and recurse=true.');\n  }\n  if (!result.recurse) {\n    seen.set(input, result.value);\n    return result.value;\n  } else if (isIterable(input)) {\n    // tslint:disable-next-line:no-any\n    var mappedIterable = Array.isArray(input) ? [] : {};\n    containedIn.add(input);\n    for (var k in input) {\n      var child = input[k];\n      var childResult = deepMapInternal(child, mapFn, seen, containedIn);\n      mappedIterable[k] = childResult;\n    }\n    containedIn.delete(input);\n    if (input.__proto__) {\n      mappedIterable.__proto__ = input.__proto__;\n    }\n    return mappedIterable;\n  } else {\n    throw new Error(\"Can't recurse into non-iterable type: \".concat(input));\n  }\n}\n// TODO(soergel, kangyizhang) Reconsider naming of deepZip() to avoid confusion\n// with zip()\n/**\n * Zip nested structures together in a recursive manner.\n *\n * This has the effect of transposing or pivoting data, e.g. converting it from\n * a row-major representation to a column-major representation.\n *\n * For example, `deepZip([{a: 1, b: 2}, {a: 3, b: 4}])` returns\n * `{a: [1, 3], b: [2, 4]}`.\n *\n * The inputs should all have the same nested structure (i.e., of arrays and\n * dicts).  The result is a single object with the same nested structure, where\n * the leaves are arrays collecting the values of the inputs at that location\n * (or, optionally, the result of a custom function applied to those arrays).\n *\n * @param inputs: An array of the objects to zip together.\n * @param zipFn: (optional) A function that expects an array of elements at a\n *   single node of the object tree, and returns a `DeepMapResult`.  The\n *   `DeepMapResult` either provides a result value for that node (i.e.,\n *   representing the subtree), or indicates that the node should be processed\n *   recursively.  The default zipFn recurses as far as possible and places\n *   arrays at the leaves.\n */\nexport function deepZip(inputs) {\n  var zipFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : zipToList;\n  return deepZipInternal(inputs, zipFn);\n}\n/**\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\nfunction deepZipInternal(inputs, zipFn) {\n  var containedIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n  // The recursion follows the structure of input 0; it's assumed that all the\n  // other inputs have the same structure.\n  var input = inputs[0];\n  if (containedIn.has(input)) {\n    throw new Error('Circular references are not supported.');\n  }\n  var result = zipFn(inputs);\n  if (result.recurse && result.value !== null) {\n    throw new Error('A deep zip function may not return both a value and recurse=true.');\n  }\n  if (!result.recurse) {\n    return result.value;\n  } else if (isIterable(input)) {\n    // tslint:disable-next-line:no-any\n    var mappedIterable = Array.isArray(input) ? [] : {};\n    containedIn.add(input);\n    var _loop = function _loop(k) {\n      var children = inputs.map(function (x) {\n        return x[k];\n      });\n      var childResult = deepZipInternal(children, zipFn, containedIn);\n      mappedIterable[k] = childResult;\n    };\n    for (var k in input) {\n      _loop(k);\n    }\n    containedIn.delete(input);\n    return mappedIterable;\n  } else {\n    throw new Error(\"Can't recurse into non-iterable type: \".concat(input));\n  }\n}\n// tslint:disable-next-line:no-any\nexport function zipToList(x) {\n  if (x === null) {\n    return null;\n  }\n  // TODO(soergel): validate array type?\n  if (isIterable(x[0])) {\n    return {\n      value: null,\n      recurse: true\n    };\n  } else {\n    return {\n      value: x,\n      recurse: false\n    };\n  }\n}\n/**\n * Apply an async mapping function to a nested structure in a recursive manner.\n *\n * This first creates a nested structure of Promises, and then awaits all of\n * those, resulting in a single Promise for a resolved nested structure.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapAsyncResult`.  The `DeepMapAsyncResult` either provides\n *   a `Promise` for a replacement value for that node (i.e., replacing the\n *   subtree), or indicates that the node should be processed recursively.  Note\n *   that the decision whether or not to recurse must be made immediately; only\n *   the mapped value may be promised.\n */\nexport function deepMapAndAwaitAll(_x, _x2) {\n  return _deepMapAndAwaitAll.apply(this, arguments);\n}\n/**\n * Determine whether the argument is iterable.\n *\n * @returns true if the argument is an array or any non-Tensor object.\n */\n// tslint:disable-next-line:no-any\nfunction _deepMapAndAwaitAll() {\n  _deepMapAndAwaitAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(input, mapFn) {\n    var seen, _i, _Array$from, key, value, mappedValue, result;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          seen = new Map(); // First do a normal deepMap, collecting Promises in 'seen' as a side effect.\n          deepMapInternal(input, mapFn, seen);\n          // Replace the Promises in 'seen' in place.\n          // Note TypeScript provides no async map iteration, and regular map iteration\n          // is broken too, so sadly we have to do Array.from() to make it work.\n          // (There's no advantage to Promise.all(), and that would be tricky anyway.)\n          _i = 0, _Array$from = Array.from(seen.keys());\n        case 3:\n          if (!(_i < _Array$from.length)) {\n            _context.next = 14;\n            break;\n          }\n          key = _Array$from[_i];\n          value = seen.get(key);\n          if (!tf.util.isPromise(value)) {\n            _context.next = 11;\n            break;\n          }\n          _context.next = 9;\n          return value;\n        case 9:\n          mappedValue = _context.sent;\n          seen.set(key, mappedValue);\n        case 11:\n          _i++;\n          _context.next = 3;\n          break;\n        case 14:\n          // Normal deepMap again, this time filling in the resolved values.\n          // It's unfortunate that we have to do two passes.\n          // TODO(soergel): test performance and think harder about a fast solution.\n          result = deepMapInternal(input, mapFn, seen);\n          return _context.abrupt(\"return\", result);\n        case 16:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _deepMapAndAwaitAll.apply(this, arguments);\n}\nexport function isIterable(obj) {\n  var isTextDecoder = false;\n  if (tf.env().get('IS_BROWSER')) {\n    isTextDecoder = obj instanceof TextDecoder;\n  } else {\n    // tslint:disable-next-line:no-require-imports\n    var _require = require('string_decoder'),\n      StringDecoder = _require.StringDecoder;\n    isTextDecoder = obj instanceof StringDecoder;\n  }\n  return obj != null && !ArrayBuffer.isView(obj) && (Array.isArray(obj) || typeof obj === 'object' && !(obj instanceof tf.Tensor) && !(obj instanceof Promise) && !isTextDecoder);\n}\n/**\n * Determine whether the argument can be converted to Tensor.\n *\n * Tensors, primitives, arrays, and TypedArrays all qualify; anything else does\n * not.\n *\n * @returns true if the argument can be converted to Tensor.\n */\n// tslint:disable-next-line:no-any\nexport function canTensorify(obj) {\n  return obj == null || isPrimitive(obj) || Array.isArray(obj) || typeof obj === 'object' && obj instanceof tf.Tensor || tf.util.isTypedArray(obj);\n}\n/**\n * Returns true if the given `value` is a primitive type. Otherwise returns\n * false. This is equivalant to node util.isPrimitive\n */\nfunction isPrimitive(value) {\n  return value === null || typeof value !== 'object' && typeof value !== 'function';\n}","map":{"version":3,"mappings":"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","names":["tf","deepMap","input","mapFn","deepMapInternal","seen","Map","containedIn","Set","Blob","slice","has","Error","get","result","recurse","value","set","isIterable","mappedIterable","Array","isArray","add","k","child","childResult","delete","__proto__","deepZip","inputs","zipFn","zipToList","deepZipInternal","children","map","x","deepMapAndAwaitAll","from","keys","key","util","isPromise","mappedValue","obj","isTextDecoder","env","TextDecoder","require","StringDecoder","ArrayBuffer","isView","Tensor","Promise","canTensorify","isPrimitive","isTypedArray"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-data\\src\\util\\deep_map.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\n// tslint:disable:no-any\n\n/**\n * A return value for a mapping function that can be applied via deepMap.\n *\n * If recurse is true, the value should be empty, and iteration will continue\n * into the object or array.\n */\nexport type DeepMapResult = {\n  value: any,\n  recurse: boolean\n};\n\n/**\n * Apply a mapping function to a nested structure in a recursive manner.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapResult`.  The `DeepMapResult` either provides a\n *   replacement value for that node (i.e., replacing the subtree), or indicates\n *   that the node should be processed recursively.\n */\nexport function deepMap(input: any, mapFn: (x: any) => DeepMapResult): any|\n    any[] {\n  return deepMapInternal(input, mapFn);\n}\n\n/**\n * @param seen: A Map of known object mappings (i.e., memoized results of\n *   `mapFn()`)\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\nfunction deepMapInternal(\n    input: any, mapFn: (x: any) => DeepMapResult,\n    seen: Map<any, any> = new Map(), containedIn: Set<{}> = new Set()): any|\n    any[] {\n  if (input == null) {\n    return null;\n  }\n  if (typeof Blob === 'function' && input instanceof Blob) {\n    return input.slice();\n  }\n\n  if (containedIn.has(input)) {\n    throw new Error('Circular references are not supported.');\n  }\n  if (seen.has(input)) {\n    return seen.get(input);\n  }\n  const result = mapFn(input);\n\n  if (result.recurse && result.value !== null) {\n    throw new Error(\n        'A deep map function may not return both a value and recurse=true.');\n  }\n\n  if (!result.recurse) {\n    seen.set(input, result.value);\n    return result.value;\n  } else if (isIterable(input)) {\n    // tslint:disable-next-line:no-any\n    const mappedIterable: any|any[] = Array.isArray(input) ? [] : {};\n    containedIn.add(input);\n    for (const k in input) {\n      const child = input[k];\n      const childResult = deepMapInternal(child, mapFn, seen, containedIn);\n      mappedIterable[k] = childResult;\n    }\n    containedIn.delete(input);\n    if (input.__proto__) {\n      mappedIterable.__proto__ = input.__proto__;\n    }\n    return mappedIterable;\n  } else {\n    throw new Error(`Can't recurse into non-iterable type: ${input}`);\n  }\n}\n\n// TODO(soergel, kangyizhang) Reconsider naming of deepZip() to avoid confusion\n// with zip()\n\n/**\n * Zip nested structures together in a recursive manner.\n *\n * This has the effect of transposing or pivoting data, e.g. converting it from\n * a row-major representation to a column-major representation.\n *\n * For example, `deepZip([{a: 1, b: 2}, {a: 3, b: 4}])` returns\n * `{a: [1, 3], b: [2, 4]}`.\n *\n * The inputs should all have the same nested structure (i.e., of arrays and\n * dicts).  The result is a single object with the same nested structure, where\n * the leaves are arrays collecting the values of the inputs at that location\n * (or, optionally, the result of a custom function applied to those arrays).\n *\n * @param inputs: An array of the objects to zip together.\n * @param zipFn: (optional) A function that expects an array of elements at a\n *   single node of the object tree, and returns a `DeepMapResult`.  The\n *   `DeepMapResult` either provides a result value for that node (i.e.,\n *   representing the subtree), or indicates that the node should be processed\n *   recursively.  The default zipFn recurses as far as possible and places\n *   arrays at the leaves.\n */\nexport function deepZip(\n    inputs: any[], zipFn: (xs: any[]) => DeepMapResult = zipToList): any|any[] {\n  return deepZipInternal(inputs, zipFn);\n}\n\n/**\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\nfunction deepZipInternal(\n    inputs: any[], zipFn: (xs: any[]) => DeepMapResult,\n    containedIn: Set<{}> = new Set()): any|any[] {\n  // The recursion follows the structure of input 0; it's assumed that all the\n  // other inputs have the same structure.\n  const input = inputs[0];\n  if (containedIn.has(input)) {\n    throw new Error('Circular references are not supported.');\n  }\n  const result = zipFn(inputs);\n\n  if (result.recurse && result.value !== null) {\n    throw new Error(\n        'A deep zip function may not return both a value and recurse=true.');\n  }\n\n  if (!result.recurse) {\n    return result.value;\n  } else if (isIterable(input)) {\n    // tslint:disable-next-line:no-any\n    const mappedIterable: any|any[] = Array.isArray(input) ? [] : {};\n    containedIn.add(input);\n    for (const k in input) {\n      const children = inputs.map(x => x[k]);\n      const childResult = deepZipInternal(children, zipFn, containedIn);\n      mappedIterable[k] = childResult;\n    }\n    containedIn.delete(input);\n    return mappedIterable;\n  } else {\n    throw new Error(`Can't recurse into non-iterable type: ${input}`);\n  }\n}\n\n// tslint:disable-next-line:no-any\nexport function zipToList(x: any[]): DeepMapResult {\n  if (x === null) {\n    return null;\n  }\n  // TODO(soergel): validate array type?\n\n  if (isIterable(x[0])) {\n    return {value: null, recurse: true};\n  } else {\n    return {value: x, recurse: false};\n  }\n}\n\n/**\n * A return value for an async map function for use with deepMapAndAwaitAll.\n *\n * If recurse is true, the value should be empty, and iteration will continue\n * into the object or array.\n */\nexport type DeepMapAsyncResult = {\n  value: Promise<any>,\n  recurse: boolean\n};\n\n/**\n * Apply an async mapping function to a nested structure in a recursive manner.\n *\n * This first creates a nested structure of Promises, and then awaits all of\n * those, resulting in a single Promise for a resolved nested structure.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapAsyncResult`.  The `DeepMapAsyncResult` either provides\n *   a `Promise` for a replacement value for that node (i.e., replacing the\n *   subtree), or indicates that the node should be processed recursively.  Note\n *   that the decision whether or not to recurse must be made immediately; only\n *   the mapped value may be promised.\n */\nexport async function deepMapAndAwaitAll(\n    input: any, mapFn: (x: any) => DeepMapAsyncResult): Promise<any|any[]> {\n  const seen: Map<any, any> = new Map();\n\n  // First do a normal deepMap, collecting Promises in 'seen' as a side effect.\n  deepMapInternal(input, mapFn, seen);\n\n  // Replace the Promises in 'seen' in place.\n  // Note TypeScript provides no async map iteration, and regular map iteration\n  // is broken too, so sadly we have to do Array.from() to make it work.\n  // (There's no advantage to Promise.all(), and that would be tricky anyway.)\n  for (const key of Array.from(seen.keys())) {\n    const value = seen.get(key);\n    if (tf.util.isPromise(value)) {\n      const mappedValue = await value;\n      seen.set(key, mappedValue);\n    }\n  }\n\n  // Normal deepMap again, this time filling in the resolved values.\n  // It's unfortunate that we have to do two passes.\n  // TODO(soergel): test performance and think harder about a fast solution.\n  const result = deepMapInternal(input, mapFn, seen);\n  return result;\n}\n\n/**\n * Determine whether the argument is iterable.\n *\n * @returns true if the argument is an array or any non-Tensor object.\n */\n// tslint:disable-next-line:no-any\nexport function isIterable(obj: any): boolean {\n  let isTextDecoder = false;\n  if (tf.env().get('IS_BROWSER')) {\n    isTextDecoder = obj instanceof TextDecoder;\n  } else {\n    // tslint:disable-next-line:no-require-imports\n    const {StringDecoder} = require('string_decoder');\n    isTextDecoder = obj instanceof StringDecoder;\n  }\n  return obj != null && (!ArrayBuffer.isView(obj)) &&\n      (Array.isArray(obj) ||\n       (typeof obj === 'object' && !(obj instanceof tf.Tensor) &&\n        !(obj instanceof Promise) && !isTextDecoder));\n}\n\n/**\n * Determine whether the argument can be converted to Tensor.\n *\n * Tensors, primitives, arrays, and TypedArrays all qualify; anything else does\n * not.\n *\n * @returns true if the argument can be converted to Tensor.\n */\n// tslint:disable-next-line:no-any\nexport function canTensorify(obj: any): boolean {\n  return obj == null || isPrimitive(obj) || Array.isArray(obj) ||\n      (typeof obj === 'object' && (obj instanceof tf.Tensor)) ||\n      tf.util.isTypedArray(obj);\n}\n\n/**\n * Returns true if the given `value` is a primitive type. Otherwise returns\n * false. This is equivalant to node util.isPrimitive\n */\nfunction isPrimitive(value: any): boolean {\n  return (\n      value === null ||\n      (typeof value !== 'object' && typeof value !== 'function'));\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}