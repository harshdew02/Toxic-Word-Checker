{"ast":null,"code":"import _createClass from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var SegmentOpProgram = /*#__PURE__*/_createClass(function SegmentOpProgram(segOpInfo, segOpType) {\n  _classCallCheck(this, SegmentOpProgram);\n  this.variableNames = ['x', 'segmentIds'];\n  var windowSize = segOpInfo.windowSize;\n  var batchSize = segOpInfo.batchSize;\n  var inSize = segOpInfo.inSize;\n  var numSegments = segOpInfo.numSegments;\n  var outSize = numSegments * Math.ceil(inSize / windowSize);\n  this.outputShape = [batchSize, outSize];\n  var initializationValue = '0.0';\n  var returnValue = \"sumValue\";\n  var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n  var windowSizeVec4Remainder = windowSize % 4;\n  var updateSnippet = \"\\n        sumValue += dot(values, segFilter);\\n    \";\n  var checkValueOutOfBounds = '';\n  if (inSize % windowSize > 0) {\n    checkValueOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \".concat(inSize, \") {\\n          return initializationValue;\\n        }\\n      \");\n  }\n  var checkSegmentIdOutOfBounds = '';\n  if (inSize % windowSize > 0) {\n    checkSegmentIdOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \".concat(inSize, \") {\\n          return -1.0;\\n        }\\n      \");\n  }\n  this.userCode = \"\\n      const float initializationValue = \".concat(initializationValue, \";\\n\\n      float getValue(int batch, int inIdx) {\\n        \").concat(checkValueOutOfBounds, \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      float getSegmentIdAtIndex(int inIdx) {\\n        \").concat(checkSegmentIdOutOfBounds, \"\\n        return getSegmentIds(inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = int(floor(float(outIdx) / float(\\n          \").concat(numSegments, \")) * float(\").concat(windowSize, \"));\\n        int currentSeg = int(mod(float(outIdx), float(\").concat(numSegments, \")));\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \").concat(windowSizeNearestVec4, \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        }\\n\\n        int inIdx = inOffset + \").concat(windowSizeNearestVec4, \";\\n        if (\").concat(windowSizeVec4Remainder === 1, \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            0,\\n            0,\\n            0\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        } else if (\").concat(windowSizeVec4Remainder === 2, \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n              0,\\n              0\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        } else if (\").concat(windowSizeVec4Remainder === 3, \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            0\\n          );\\n\\n          \").concat(updateSnippet, \"\\n        }\\n        setOutput(\").concat(returnValue, \");\\n      }\\n    \");\n});","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;AAoBA,WAAaA,gBAAgB,6BAK3B,0BACIC,SAA8C,EAC9CC,SAA+B;EAAA;EANnC,kBAAa,GAAG,CAAC,GAAG,EAAE,YAAY,CAAC;EAOjC,IAAMC,UAAU,GAAGF,SAAS,CAACE,UAAU;EACvC,IAAMC,SAAS,GAAGH,SAAS,CAACG,SAAS;EACrC,IAAMC,MAAM,GAAGJ,SAAS,CAACI,MAAM;EAC/B,IAAMC,WAAW,GAAGL,SAAS,CAACK,WAAW;EACzC,IAAMC,OAAO,GAAGD,WAAW,GAAGE,IAAI,CAACC,IAAI,CAACJ,MAAM,GAAGF,UAAU,CAAC;EAC5D,IAAI,CAACO,WAAW,GAAG,CAACN,SAAS,EAAEG,OAAO,CAAC;EAEvC,IAAMI,mBAAmB,GAAG,KAAK;EACjC,IAAMC,WAAW,aAAa;EAE9B,IAAMC,qBAAqB,GAAGL,IAAI,CAACM,KAAK,CAACX,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC;EAC5D,IAAMY,uBAAuB,GAAGZ,UAAU,GAAG,CAAC;EAE9C,IAAMa,aAAa,wDAElB;EAED,IAAIC,qBAAqB,GAAG,EAAE;EAC9B,IAAIZ,MAAM,GAAGF,UAAU,GAAG,CAAC,EAAE;IAC3Bc,qBAAqB,iDACSZ,MAAM,kEAGnC;;EAGH,IAAIa,yBAAyB,GAAG,EAAE;EAClC,IAAIb,MAAM,GAAGF,UAAU,GAAG,CAAC,EAAE;IAC3Be,yBAAyB,iDACKb,MAAM,mDAGnC;;EAGH,IAAI,CAACc,QAAQ,uDACyBR,mBAAmB,wEAGnDM,qBAAqB,oHAKrBC,yBAAyB,oQASvBZ,WAAW,wBAAcH,UAAU,wEACSG,WAAW,kFAIrCO,qBAAqB,omBAgBvCG,aAAa,2DAGQH,qBAAqB,4BACxCE,uBAAuB,KAAK,CAAC,ubAiB/BC,aAAa,kCACJD,uBAAuB,KAAK,CAAC,6bAetCC,aAAa,kCACJD,uBAAuB,KAAK,CAAC,wfAetCC,aAAa,4CAELJ,WAAW,sBAE1B;AACH,CAAC","names":["SegmentOpProgram","segOpInfo","segOpType","windowSize","batchSize","inSize","numSegments","outSize","Math","ceil","outputShape","initializationValue","returnValue","windowSizeNearestVec4","floor","windowSizeVec4Remainder","updateSnippet","checkValueOutOfBounds","checkSegmentIdOutOfBounds","userCode"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-backend-webgl\\src\\segment_gpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class SegmentOpProgram implements GPGPUProgram {\n  variableNames = ['x', 'segmentIds'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      segOpInfo: backend_util.segment_util.SegOpInfo,\n      segOpType: 'unsortedSegmentSum') {\n    const windowSize = segOpInfo.windowSize;\n    const batchSize = segOpInfo.batchSize;\n    const inSize = segOpInfo.inSize;\n    const numSegments = segOpInfo.numSegments;\n    const outSize = numSegments * Math.ceil(inSize / windowSize);\n    this.outputShape = [batchSize, outSize];\n\n    const initializationValue = '0.0';\n    const returnValue = `sumValue`;\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    const updateSnippet = `\n        sumValue += dot(values, segFilter);\n    `;\n\n    let checkValueOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkValueOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n    }\n\n    let checkSegmentIdOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkSegmentIdOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return -1.0;\n        }\n      `;\n    }\n\n    this.userCode = `\n      const float initializationValue = ${initializationValue};\n\n      float getValue(int batch, int inIdx) {\n        ${checkValueOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${checkSegmentIdOutOfBounds}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${numSegments})) * float(${windowSize}));\n        int currentSeg = int(mod(float(outIdx), float(${numSegments})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}