{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(values, shape, inferredShape, dtype) {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  } else if (dtype === 'complex64') {\n    throw new Error(\"Cannot construct a complex64 tensor directly. \" + \"Please use tf.complex(real, imag).\");\n  }\n  if (typeof values === 'object' && ('texture' in values || 'buffer' in values && !(values.buffer instanceof ArrayBuffer))) {\n    if (dtype !== 'float32' && dtype !== 'int32') {\n      throw new Error(\"Creating tensor from GPU data only supports \" + \"'float32'|'int32' dtype, while the dtype is \".concat(dtype, \".\"));\n    }\n    return ENGINE.backend.createTensorFromGPUData(values, shape || inferredShape, dtype);\n  }\n  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') {\n    throw new Error('values passed to tensor(values) must be a number/boolean/string or ' + 'an array of numbers/booleans/strings, or a TypedArray');\n  }\n  // Verify that the shape matches the inferred shape.\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n    var providedSize = sizeFromShape(shape);\n    var inferredSize = sizeFromShape(inferredShape);\n    assert(providedSize === inferredSize, function () {\n      return \"Based on the provided shape, [\".concat(shape, \"], the tensor should have \") + \"\".concat(providedSize, \" values but has \").concat(inferredSize);\n    });\n    for (var i = 0; i < inferredShape.length; ++i) {\n      var inferred = inferredShape[i];\n      var flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;\n      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, function () {\n        return \"Error creating a new Tensor. Inferred shape \" + \"(\".concat(inferredShape, \") does not match the provided \") + \"shape (\".concat(shape, \"). \");\n      });\n    }\n  }\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values];\n  }\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ? toTypedArray(values, dtype) : flatten(values, [], true);\n  return ENGINE.makeTensor(values, shape, dtype);\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,MAAM,QAAO,WAAW;AAIhC,SAAQC,MAAM,EAAEC,kCAAkC,EAAEC,OAAO,EAAEC,UAAU,EAAEC,YAAY,EAAEC,aAAa,EAAEC,YAAY,QAAO,SAAS;AAElI;AACA,OAAM,SAAUC,UAAU,CACtBC,MAAuC,EAAEC,KAAe,EACxDC,aAAuB,EAAEC,KAAgB;EAC3C,IAAIA,KAAK,IAAI,IAAI,EAAE;IACjBA,KAAK,GAAGR,UAAU,CAACK,MAAM,CAAC;GAC3B,MAAM,IAAIG,KAAK,KAAK,WAAW,EAAE;IAChC,MAAM,IAAIC,KAAK,CACX,uFACoC,CAAC;;EAG3C,IAAI,OAAOJ,MAAM,KAAK,QAAQ,KACzB,SAAS,IAAIA,MAAM,IAClB,QAAQ,IAAIA,MAAM,IAAI,EAAEA,MAAM,CAACK,MAAM,YAAYC,WAAW,CAAE,CAAC,EAAE;IACrE,IAAIH,KAAK,KAAK,SAAS,IAAIA,KAAK,KAAK,OAAO,EAAE;MAC5C,MAAM,IAAIC,KAAK,CACX,uGAC+CD,KAAK,MAAG,CAAC;;IAE9D,OAAOZ,MAAM,CAACgB,OAAO,CAACC,uBAAuB,CACzCR,MAAgC,EAAEC,KAAK,IAAIC,aAAa,EAAEC,KAAK,CAAC;;EAGtE,IAAI,CAACP,YAAY,CAACI,MAAM,CAAC,IAAI,CAACS,KAAK,CAACC,OAAO,CAACV,MAAM,CAAC,IAC/C,OAAOA,MAAM,KAAK,QAAQ,IAAI,OAAOA,MAAM,KAAK,SAAS,IACzD,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAC9B,MAAM,IAAII,KAAK,CACX,qEAAqE,GACrE,uDAAuD,CAAC;;EAE9D;EACA,IAAIH,KAAK,IAAI,IAAI,EAAE;IACjBR,kCAAkC,CAACQ,KAAK,CAAC;IAEzC,IAAMU,YAAY,GAAGd,aAAa,CAACI,KAAK,CAAC;IACzC,IAAMW,YAAY,GAAGf,aAAa,CAACK,aAAa,CAAC;IACjDV,MAAM,CACFmB,YAAY,KAAKC,YAAY,EAC7B;MAAA,OACI,wCAAiCX,KAAK,4CACnCU,YAAY,6BAAmBC,YAAY,CAAE;IAAA,EAAC;IAEzD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,aAAa,CAACY,MAAM,EAAE,EAAED,CAAC,EAAE;MAC7C,IAAME,QAAQ,GAAGb,aAAa,CAACW,CAAC,CAAC;MACjC,IAAMG,iBAAiB,GAAGH,CAAC,KAAKX,aAAa,CAACY,MAAM,GAAG,CAAC,GACpDC,QAAQ,KAAKlB,aAAa,CAACI,KAAK,CAACgB,KAAK,CAACJ,CAAC,CAAC,CAAC,GAC1C,IAAI;MACRrB,MAAM,CACFU,aAAa,CAACW,CAAC,CAAC,KAAKZ,KAAK,CAACY,CAAC,CAAC,IAAI,CAACG,iBAAiB,EACnD;QAAA,OAAM,4DACEd,aAAa,mCAAgC,oBACvCD,KAAK,QAAK;MAAA,EAAC;;;EAIjC,IAAI,CAACL,YAAY,CAACI,MAAM,CAAC,IAAI,CAACS,KAAK,CAACC,OAAO,CAACV,MAAM,CAAC,EAAE;IACnDA,MAAM,GAAG,CAACA,MAAM,CAAa;;EAG/BC,KAAK,GAAGA,KAAK,IAAIC,aAAa;EAC9BF,MAAM,GAAGG,KAAK,KAAK,QAAQ,GACvBL,YAAY,CAACE,MAAM,EAAEG,KAAK,CAAC,GAC3BT,OAAO,CAACM,MAAkB,EAAE,EAAE,EAAE,IAAI,CAAa;EACrD,OAAOT,MAAM,CAACQ,UAAU,CAACC,MAAoB,EAAEC,KAAK,EAAEE,KAAK,CAAC;AAC9D","names":["ENGINE","assert","assertNonNegativeIntegerDimensions","flatten","inferDtype","isTypedArray","sizeFromShape","toTypedArray","makeTensor","values","shape","inferredShape","dtype","Error","buffer","ArrayBuffer","backend","createTensorFromGPUData","Array","isArray","providedSize","inferredSize","i","length","inferred","flatDimsDontMatch","slice"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-core\\src\\ops\\tensor_ops_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {TensorLike, TypedArray, WebGLData, WebGPUData} from '../types';\nimport {DataType} from '../types';\nimport {assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray} from '../util';\n\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(\n    values: TensorLike|WebGLData|WebGPUData, shape: number[],\n    inferredShape: number[], dtype?: DataType): Tensor {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  } else if (dtype === 'complex64') {\n    throw new Error(\n        `Cannot construct a complex64 tensor directly. ` +\n        `Please use tf.complex(real, imag).`);\n  }\n\n  if (typeof values === 'object' &&\n      ('texture' in values ||\n       ('buffer' in values && !(values.buffer instanceof ArrayBuffer)))) {\n    if (dtype !== 'float32' && dtype !== 'int32') {\n      throw new Error(\n          `Creating tensor from GPU data only supports ` +\n          `'float32'|'int32' dtype, while the dtype is ${dtype}.`);\n    }\n    return ENGINE.backend.createTensorFromGPUData(\n        values as WebGLData | WebGPUData, shape || inferredShape, dtype);\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values) &&\n      typeof values !== 'number' && typeof values !== 'boolean' &&\n      typeof values !== 'string') {\n    throw new Error(\n        'values passed to tensor(values) must be a number/boolean/string or ' +\n        'an array of numbers/booleans/strings, or a TypedArray');\n  }\n  // Verify that the shape matches the inferred shape.\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(\n        providedSize === inferredSize,\n        () =>\n            `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ?\n          inferred !== sizeFromShape(shape.slice(i)) :\n          true;\n      assert(\n          inferredShape[i] === shape[i] || !flatDimsDontMatch,\n          () => `Error creating a new Tensor. Inferred shape ` +\n              `(${inferredShape}) does not match the provided ` +\n              `shape (${shape}). `);\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values] as number[];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ?\n      toTypedArray(values, dtype) :\n      flatten(values as string[], [], true) as string[];\n  return ENGINE.makeTensor(values as TypedArray, shape, dtype);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}