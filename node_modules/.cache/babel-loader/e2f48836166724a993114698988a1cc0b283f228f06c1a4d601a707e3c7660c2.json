{"ast":null,"code":"import _regeneratorRuntime from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { dispose } from '@tensorflow/tfjs-core';\n/**\n * Turn any Scalar values in a Logs object into actual number values.\n *\n * @param logs The `Logs` object to be resolved in place.\n */\nexport function resolveScalarsInLogs(_x) {\n  return _resolveScalarsInLogs.apply(this, arguments);\n}\n/**\n * Dispose all Tensors in an UnresolvedLogs object.\n *\n * @param logs An `UnresolvedLogs` object potentially containing `tf.Tensor`s in\n *   places where the values can be `tf.Tensor` or `number`.\n */\nfunction _resolveScalarsInLogs() {\n  _resolveScalarsInLogs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(logs) {\n    var promises, keys, scalarsToDispose, key, value, valueScalar, values, i;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (!(logs == null)) {\n            _context.next = 2;\n            break;\n          }\n          return _context.abrupt(\"return\");\n        case 2:\n          promises = [];\n          keys = [];\n          scalarsToDispose = [];\n          for (key in logs) {\n            value = logs[key];\n            if (typeof value !== 'number') {\n              valueScalar = value;\n              promises.push(valueScalar.data());\n              keys.push(key);\n              scalarsToDispose.push(valueScalar);\n            }\n          }\n          if (!(promises.length > 0)) {\n            _context.next = 12;\n            break;\n          }\n          _context.next = 9;\n          return Promise.all(promises);\n        case 9:\n          values = _context.sent;\n          for (i = 0; i < values.length; ++i) {\n            logs[keys[i]] = values[i][0];\n          }\n          // Dispose the original scalar tensors.\n          dispose(scalarsToDispose);\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _resolveScalarsInLogs.apply(this, arguments);\n}\nexport function disposeTensorsInLogs(logs) {\n  if (logs == null) {\n    return;\n  }\n  for (var key in logs) {\n    var value = logs[key];\n    if (typeof value !== 'number') {\n      value.dispose();\n    }\n  }\n}","map":{"version":3,"mappings":";;AAAA;;;;;;;;;AAUA,SAAQA,OAAO,QAAe,uBAAuB;AAWrD;;;;;AAKA,gBAAsBC,oBAAoB;EAAA;AAAA;AA0B1C;;;;;;AAAA;EAAA,mFA1BO,iBAAoCC,IAAoB;IAAA;IAAA;MAAA;QAAA;UAAA,MACzDA,IAAI,IAAI,IAAI;YAAA;YAAA;UAAA;UAAA;QAAA;UAGVC,QAAQ,GAAuD,EAAE;UACjEC,IAAI,GAAa,EAAE;UACnBC,gBAAgB,GAAa,EAAE;UACrC,KAAWC,GAAG,IAAIJ,IAAI,EAAE;YAChBK,KAAK,GAAGL,IAAI,CAACI,GAAG,CAAC;YACvB,IAAI,OAAOC,KAAK,KAAK,QAAQ,EAAE;cACvBC,WAAW,GAAGD,KAAK;cACzBJ,QAAQ,CAACM,IAAI,CAACD,WAAW,CAACE,IAAI,EAAE,CAAC;cACjCN,IAAI,CAACK,IAAI,CAACH,GAAG,CAAC;cACdD,gBAAgB,CAACI,IAAI,CAACD,WAAW,CAAC;;;UAErC,MACGL,QAAQ,CAACQ,MAAM,GAAG,CAAC;YAAA;YAAA;UAAA;UAAA;UAAA,OACAC,OAAO,CAACC,GAAG,CAACV,QAAQ,CAAC;QAAA;UAApCW,MAAM;UACZ,KAASC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,CAACH,MAAM,EAAE,EAAEI,CAAC,EAAE;YACtCb,IAAI,CAACE,IAAI,CAACW,CAAC,CAAC,CAAC,GAAGD,MAAM,CAACC,CAAC,CAAC,CAAC,CAAC,CAAC;;UAE9B;UACAf,OAAO,CAACK,gBAAgB,CAAC;QAAC;QAAA;UAAA;MAAA;IAAA;EAAA,CAE7B;EAAA;AAAA;AAQD,OAAM,SAAUW,oBAAoB,CAACd,IAAoB;EACvD,IAAIA,IAAI,IAAI,IAAI,EAAE;IAChB;;EAEF,KAAK,IAAMI,GAAG,IAAIJ,IAAI,EAAE;IACtB,IAAMK,KAAK,GAAGL,IAAI,CAACI,GAAG,CAAC;IACvB,IAAI,OAAOC,KAAK,KAAK,QAAQ,EAAE;MAC7BA,KAAK,CAACP,OAAO,EAAE;;;AAGrB","names":["dispose","resolveScalarsInLogs","logs","promises","keys","scalarsToDispose","key","value","valueScalar","push","data","length","Promise","all","values","i","disposeTensorsInLogs"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-layers\\src\\logs.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport {dispose, Scalar} from '@tensorflow/tfjs-core';\n\n/**\n * Logs in which values can be either numbers or Tensors (Scalars).\n *\n * Used internally.\n */\nexport type UnresolvedLogs = {\n  [key: string]: number|Scalar;\n};\n\n/**\n * Turn any Scalar values in a Logs object into actual number values.\n *\n * @param logs The `Logs` object to be resolved in place.\n */\nexport async function resolveScalarsInLogs(logs: UnresolvedLogs) {\n  if (logs == null) {\n    return;\n  }\n  const promises: Array<Promise<Float32Array|Int32Array|Uint8Array>> = [];\n  const keys: string[] = [];\n  const scalarsToDispose: Scalar[] = [];\n  for (const key in logs) {\n    const value = logs[key];\n    if (typeof value !== 'number') {\n      const valueScalar = value;\n      promises.push(valueScalar.data());\n      keys.push(key);\n      scalarsToDispose.push(valueScalar);\n    }\n  }\n  if (promises.length > 0) {\n    const values = await Promise.all(promises);\n    for (let i = 0; i < values.length; ++i) {\n      logs[keys[i]] = values[i][0];\n    }\n    // Dispose the original scalar tensors.\n    dispose(scalarsToDispose);\n  }\n}\n\n/**\n * Dispose all Tensors in an UnresolvedLogs object.\n *\n * @param logs An `UnresolvedLogs` object potentially containing `tf.Tensor`s in\n *   places where the values can be `tf.Tensor` or `number`.\n */\nexport function disposeTensorsInLogs(logs: UnresolvedLogs) {\n  if (logs == null) {\n    return;\n  }\n  for (const key in logs) {\n    const value = logs[key];\n    if (typeof value !== 'number') {\n      value.dispose();\n    }\n  }\n}\n\n/**\n * Logs in which values can only be numbers.\n *\n * Used when calling client-provided custom callbacks.\n */\nexport type Logs = {\n  [key: string]: number;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}