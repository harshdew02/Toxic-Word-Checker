{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, sumOutType, UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { SegmentOpProgram } from '../segment_gpu';\nimport { range } from './Range';\nimport { reshape } from './Reshape';\nimport { tile } from './Tile';\nimport { transpose } from './Transpose';\nexport function unsortedSegmentSum(args) {\n  var inputs = args.inputs,\n    backend = args.backend,\n    attrs = args.attrs;\n  var x = inputs.x,\n    segmentIds = inputs.segmentIds;\n  var numSegments = attrs.numSegments;\n  var xRank = x.shape.length;\n  var toDispose = [];\n  var axis = 0;\n  var permutation = backend_util.getAxesPermutation([axis], xRank);\n  var permutedX = x;\n  if (permutation != null) {\n    permutedX = transpose({\n      inputs: {\n        x: x\n      },\n      backend: backend,\n      attrs: {\n        perm: permutation\n      }\n    });\n    toDispose.push(permutedX);\n    axis = backend_util.getInnerMostAxes(1, xRank)[0];\n  }\n  var outShape = backend_util.segment_util.computeOutShape(permutedX.shape, axis, numSegments);\n  var inSize = util.sizeFromShape([permutedX.shape[axis]]);\n  var a2D = reshape({\n    inputs: {\n      x: permutedX\n    },\n    backend: backend,\n    attrs: {\n      shape: [-1, inSize]\n    }\n  });\n  toDispose.push(a2D);\n  var outputDType = sumOutType(x.dtype);\n  var segOpCompute = function segOpCompute(x, segOpType, segmentIds, dtype, numSegments) {\n    var batchSize = x.shape[0];\n    var inSize = x.shape[1];\n    var windowSize = backend_util.segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);\n    var segOpInfo = {\n      windowSize: windowSize,\n      inSize: inSize,\n      batchSize: batchSize,\n      numSegments: numSegments\n    };\n    var program = new SegmentOpProgram(segOpInfo, segOpType);\n    var output = backend.compileAndRun(program, [x, segmentIds], dtype);\n    toDispose.push(output);\n    // No need to run another GPGPU program.\n    if (output.shape[1] === numSegments) {\n      return output;\n    }\n    var rangeInfo = range({\n      backend: backend,\n      attrs: {\n        start: 0,\n        stop: numSegments,\n        step: 1,\n        dtype: 'float32'\n      }\n    });\n    var tileInfo = tile({\n      inputs: {\n        x: rangeInfo\n      },\n      backend: backend,\n      attrs: {\n        reps: [inSize / windowSize]\n      }\n    });\n    toDispose.push(rangeInfo);\n    toDispose.push(tileInfo);\n    var result = segOpCompute(output, segOpType, tileInfo, dtype, numSegments);\n    return result;\n  };\n  var segOpResult = segOpCompute(a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);\n  var reshaped = reshape({\n    inputs: {\n      x: segOpResult\n    },\n    backend: backend,\n    attrs: {\n      shape: outShape\n    }\n  });\n  var result = reshaped;\n  if (permutation != null) {\n    toDispose.push(reshaped);\n    var perm = backend_util.getUndoAxesPermutation(permutation);\n    result = transpose({\n      inputs: {\n        x: result\n      },\n      backend: backend,\n      attrs: {\n        perm: perm\n      }\n    });\n  }\n  toDispose.forEach(function (t) {\n    return backend.disposeIntermediateTensorInfo(t);\n  });\n  return result;\n}\nexport var unsortedSegmentSumConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'webgl',\n  kernelFunc: unsortedSegmentSum\n};","map":{"version":3,"mappings":"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","names":["backend_util","sumOutType","UnsortedSegmentSum","util","SegmentOpProgram","range","reshape","tile","transpose","unsortedSegmentSum","args","inputs","backend","attrs","x","segmentIds","numSegments","xRank","shape","length","toDispose","axis","permutation","getAxesPermutation","permutedX","perm","push","getInnerMostAxes","outShape","segment_util","computeOutShape","inSize","sizeFromShape","a2D","outputDType","dtype","segOpCompute","segOpType","batchSize","windowSize","segOpComputeOptimalWindowSize","segOpInfo","program","output","compileAndRun","rangeInfo","start","stop","step","tileInfo","reps","result","segOpResult","reshaped","getUndoAxesPermutation","forEach","disposeIntermediateTensorInfo","t","unsortedSegmentSumConfig","kernelName","backendName","kernelFunc"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-backend-webgl\\src\\kernels\\UnsortedSegmentSum.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, KernelConfig, KernelFunc, sumOutType, TensorInfo, UnsortedSegmentSum, UnsortedSegmentSumAttrs, UnsortedSegmentSumInputs, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {SegmentOpProgram} from '../segment_gpu';\n\nimport {range} from './Range';\nimport {reshape} from './Reshape';\nimport {tile} from './Tile';\nimport {transpose} from './Transpose';\n\nexport function unsortedSegmentSum(args: {\n  inputs: UnsortedSegmentSumInputs,\n  backend: MathBackendWebGL,\n  attrs: UnsortedSegmentSumAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, segmentIds} = inputs;\n  const {numSegments} = attrs;\n\n  const xRank = x.shape.length;\n\n  const toDispose = [];\n\n  let axis = 0;\n  const permutation = backend_util.getAxesPermutation([axis], xRank);\n  let permutedX = x;\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n    toDispose.push(permutedX);\n    axis = backend_util.getInnerMostAxes(1, xRank)[0];\n  }\n\n  const outShape = backend_util.segment_util.computeOutShape(\n      permutedX.shape, axis, numSegments);\n  const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n  const a2D =\n      reshape({inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n  toDispose.push(a2D);\n\n  const outputDType = sumOutType(x.dtype);\n\n  const segOpCompute =\n      (x: TensorInfo, segOpType: 'unsortedSegmentSum', segmentIds: TensorInfo,\n       dtype: DataType, numSegments: number): TensorInfo => {\n        const batchSize = x.shape[0];\n        const inSize = x.shape[1];\n        const windowSize =\n            backend_util.segment_util.segOpComputeOptimalWindowSize(\n                inSize, numSegments);\n        const segOpInfo = {windowSize, inSize, batchSize, numSegments};\n        const program = new SegmentOpProgram(segOpInfo, segOpType);\n        const output = backend.compileAndRun(program, [x, segmentIds], dtype);\n        toDispose.push(output);\n        // No need to run another GPGPU program.\n        if (output.shape[1] === numSegments) {\n          return output;\n        }\n        const rangeInfo = range({\n          backend,\n          attrs: {start: 0, stop: numSegments, step: 1, dtype: 'float32'}\n        });\n        const tileInfo = tile({\n          inputs: {x: rangeInfo},\n          backend,\n          attrs: {reps: [inSize / windowSize]}\n        });\n\n        toDispose.push(rangeInfo);\n        toDispose.push(tileInfo);\n\n        const result =\n            segOpCompute(output, segOpType, tileInfo, dtype, numSegments);\n        return result;\n      };\n\n  const segOpResult = segOpCompute(\n      a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);\n\n  const reshaped =\n      reshape({inputs: {x: segOpResult}, backend, attrs: {shape: outShape}});\n\n  let result = reshaped;\n  if (permutation != null) {\n    toDispose.push(reshaped);\n    const perm = backend_util.getUndoAxesPermutation(permutation);\n    result = transpose({inputs: {x: result}, backend, attrs: {perm}});\n  }\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return result;\n}\n\nexport const unsortedSegmentSumConfig: KernelConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'webgl',\n  kernelFunc: unsortedSegmentSum as unknown as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}