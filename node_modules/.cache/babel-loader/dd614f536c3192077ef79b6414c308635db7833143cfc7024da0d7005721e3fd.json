{"ast":null,"code":"import _classCallCheck from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport var ExecutionContext = /*#__PURE__*/function () {\n  function ExecutionContext() {\n    var weightMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var tensorArrayMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var tensorListMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var functionMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    _classCallCheck(this, ExecutionContext);\n    this.weightMap = weightMap;\n    this.tensorArrayMap = tensorArrayMap;\n    this.tensorListMap = tensorListMap;\n    this.functionMap = functionMap;\n    this.rootContext = {\n      id: 0,\n      frameName: '',\n      iterationId: 0\n    };\n    this.contexts = [this.rootContext];\n    this.lastId = 0;\n    this.generateCurrentContextIds();\n  }\n  _createClass(ExecutionContext, [{\n    key: \"newFrame\",\n    value: function newFrame(id, frameName) {\n      return {\n        id: id,\n        frameName: frameName,\n        iterationId: 0\n      };\n    }\n    /**\n     * Set the current context\n     * @param contexts: ExecutionContextInfo[] the current path of execution\n     * frames\n     */\n  }, {\n    key: \"currentContext\",\n    get: function get() {\n      return this.contexts;\n    }\n    /**\n     * Returns the current context in string format.\n     */,\n    set: function set(contexts) {\n      if (this.contexts !== contexts) {\n        this.contexts = contexts;\n        this.generateCurrentContextIds();\n      }\n    }\n  }, {\n    key: \"currentContextId\",\n    get: function get() {\n      return this._currentContextIds[0];\n    }\n    /**\n     * Returns the current context and all parent contexts in string format.\n     * This allow access to the nodes in the current and parent frames.\n     */\n  }, {\n    key: \"currentContextIds\",\n    get: function get() {\n      return this._currentContextIds;\n    }\n  }, {\n    key: \"generateCurrentContextIds\",\n    value: function generateCurrentContextIds() {\n      var names = [];\n      for (var i = 0; i < this.contexts.length - 1; i++) {\n        var contexts = this.contexts.slice(0, this.contexts.length - i);\n        names.push(this.contextIdforContexts(contexts));\n      }\n      names.push('');\n      this._currentContextIds = names;\n    }\n  }, {\n    key: \"contextIdforContexts\",\n    value: function contextIdforContexts(contexts) {\n      return contexts ? contexts.map(function (context) {\n        return context.id === 0 && context.iterationId === 0 ? '' : \"\".concat(context.frameName, \"-\").concat(context.iterationId);\n      }).join('/') : '';\n    }\n    /**\n     * Enter a new frame, a new context is pushed on the current context list.\n     * @param frameId new frame id\n     */\n  }, {\n    key: \"enterFrame\",\n    value: function enterFrame(frameId) {\n      if (this.contexts) {\n        this.lastId++;\n        this.contexts = this.contexts.slice();\n        this.contexts.push(this.newFrame(this.lastId, frameId));\n        this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n      }\n    }\n    /**\n     * Exit the current frame, the last context is removed from the current\n     * context list.\n     */\n  }, {\n    key: \"exitFrame\",\n    value: function exitFrame() {\n      if (this.contexts && this.contexts.length > 1) {\n        this.contexts = this.contexts.slice();\n        this.contexts.splice(-1);\n        this.currentContextIds.shift();\n      } else {\n        throw new Error('Cannot exit frame, the context is empty');\n      }\n    }\n    /**\n     * Enter the next iteration of a loop, the iteration id of last context is\n     * increased.\n     */\n  }, {\n    key: \"nextIteration\",\n    value: function nextIteration() {\n      if (this.contexts && this.contexts.length > 0) {\n        this.contexts = this.contexts.slice();\n        this.lastId++;\n        var context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n        context.iterationId += 1;\n        context.id = this.lastId;\n        this.contexts.splice(-1, 1, context);\n        this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n      } else {\n        throw new Error('Cannot increase frame iteration, the context is empty');\n      }\n    }\n  }, {\n    key: \"getWeight\",\n    value: function getWeight(name) {\n      return this.weightMap[name];\n    }\n  }, {\n    key: \"addTensorArray\",\n    value: function addTensorArray(tensorArray) {\n      this.tensorArrayMap[tensorArray.id] = tensorArray;\n    }\n  }, {\n    key: \"getTensorArray\",\n    value: function getTensorArray(id) {\n      return this.tensorArrayMap[id];\n    }\n  }, {\n    key: \"addTensorList\",\n    value: function addTensorList(tensorList) {\n      this.tensorListMap[tensorList.id] = tensorList;\n    }\n  }, {\n    key: \"getTensorList\",\n    value: function getTensorList(id) {\n      return this.tensorListMap[id];\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose(keepIds) {\n      for (var key in this.tensorArrayMap) {\n        this.tensorArrayMap[key].clearAndClose(keepIds);\n      }\n      for (var _key in this.tensorListMap) {\n        this.tensorListMap[_key].clearAndClose(keepIds);\n      }\n    }\n  }]);\n  return ExecutionContext;\n}();","map":{"version":3,"mappings":"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","names":["ExecutionContext","weightMap","tensorArrayMap","tensorListMap","functionMap","id","frameName","iterationId","rootContext","generateCurrentContextIds","contexts","_currentContextIds","names","i","length","slice","push","contextIdforContexts","map","context","join","frameId","lastId","newFrame","unshift","splice","currentContextIds","shift","Error","Object","assign","name","tensorArray","tensorList","keepIds","key","clearAndClose"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-converter\\src\\executor\\execution_context.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap, TensorArrayMap, TensorListMap} from '../data/types';\n\nimport {TensorArray} from './tensor_array';\nimport {TensorList} from './tensor_list';\nimport {FunctionExecutor} from './types';\n\nexport interface ExecutionContextInfo {\n  id: number;           // the unique id of the context info\n  frameName: string;    // The frame name of the loop, this comes from\n                        // the TensorFlow NodeDef.\n  iterationId: number;  // The iteration id of the loop\n}\n\n/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  private rootContext = {id: 0, frameName: '', iterationId: 0};\n  private contexts: ExecutionContextInfo[] = [this.rootContext];\n  private lastId = 0;\n  private _currentContextIds: string[];\n\n  constructor(\n      readonly weightMap: NamedTensorsMap = {},\n      readonly tensorArrayMap: TensorArrayMap = {},\n      readonly tensorListMap: TensorListMap = {},\n      readonly functionMap: {[key: string]: FunctionExecutor} = {}) {\n    this.generateCurrentContextIds();\n  }\n\n  private newFrame(id: number, frameName: string) {\n    return {id, frameName, iterationId: 0};\n  }\n\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n  set currentContext(contexts: ExecutionContextInfo[]) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n\n  get currentContext(): ExecutionContextInfo[] {\n    return this.contexts;\n  }\n\n  /**\n   * Returns the current context in string format.\n   */\n  get currentContextId(): string {\n    return this._currentContextIds[0];\n  }\n\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n  get currentContextIds(): string[] {\n    return this._currentContextIds;\n  }\n\n  private generateCurrentContextIds() {\n    const names = [];\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n    names.push('');\n    this._currentContextIds = names;\n  }\n\n  private contextIdforContexts(contexts: ExecutionContextInfo[]) {\n    return contexts ?\n        contexts\n            .map(\n                context => (context.id === 0 && context.iterationId === 0) ?\n                    '' :\n                    `${context.frameName}-${context.iterationId}`)\n            .join('/') :\n        '';\n  }\n\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n  enterFrame(frameId: string) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context =\n          Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n      this._currentContextIds.splice(\n          0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n\n  getWeight(name: string): Tensor[] {\n    return this.weightMap[name];\n  }\n\n  addTensorArray(tensorArray: TensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n\n  getTensorArray(id: number): TensorArray {\n    return this.tensorArrayMap[id];\n  }\n\n  addTensorList(tensorList: TensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n\n  getTensorList(id: number): TensorList {\n    return this.tensorListMap[id];\n  }\n\n  dispose(keepIds: Set<number>) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}