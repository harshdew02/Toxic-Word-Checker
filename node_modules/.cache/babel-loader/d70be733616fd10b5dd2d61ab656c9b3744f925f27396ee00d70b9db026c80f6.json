{"ast":null,"code":"import _slicedToArray from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { BatchMatMul, broadcast_util, buffer, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { reshape } from './Reshape';\nexport function batchMatMul(args) {\n  var inputs = args.inputs,\n    backend = args.backend,\n    attrs = args.attrs;\n  var a = inputs.a,\n    b = inputs.b;\n  var transposeA = attrs.transposeA,\n    transposeB = attrs.transposeB;\n  assertNotComplex([a, b], 'matMul');\n  var aRank = a.shape.length;\n  var bRank = b.shape.length;\n  var innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n  var innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n  var outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n  var outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n  var outerDimsA = a.shape.slice(0, -2);\n  var outerDimsB = b.shape.slice(0, -2);\n  var batchDimA = util.sizeFromShape(outerDimsA);\n  var batchDimB = util.sizeFromShape(outerDimsB);\n  var outShapeOuterDims = broadcast_util.assertAndGetBroadcastShape(a.shape.slice(0, -2), b.shape.slice(0, -2));\n  var outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n  util.assert(innerShapeA === innerShapeB, function () {\n    return \"Error in matMul: inner shapes (\".concat(innerShapeA, \") and (\") + \"\".concat(innerShapeB, \") of Tensors with shapes \").concat(a.shape, \" and \") + \"\".concat(b.shape, \" and transposeA=\").concat(transposeA) + \" and transposeB=\".concat(transposeB, \" must match.\");\n  });\n  var a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];\n  var b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];\n  // The rest of the implementation is designed to operate on rank-3 tensors\n  var a3d = reshape({\n    inputs: {\n      x: a\n    },\n    backend: backend,\n    attrs: {\n      shape: a3dShape\n    }\n  });\n  var b3d = reshape({\n    inputs: {\n      x: b\n    },\n    backend: backend,\n    attrs: {\n      shape: b3dShape\n    }\n  });\n  var sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n  var leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];\n  var rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];\n  var batchDim = Math.max(batchDimA, batchDimB);\n  var a3dValues = backend.data.get(a3d.dataId).values;\n  var b3dValues = backend.data.get(b3d.dataId).values;\n  var a3dStrides = util.computeStrides(a3d.shape);\n  var b3dStrides = util.computeStrides(b3d.shape);\n  var _ref = transposeA ? [a3dStrides[0], 1, a3dStrides[1]] : [a3dStrides[0], a3dStrides[1], 1],\n    _ref2 = _slicedToArray(_ref, 3),\n    aBatch = _ref2[0],\n    aOuterStep = _ref2[1],\n    aInnerStep = _ref2[2];\n  var _ref3 = transposeB ? [1, b3dStrides[1], b3dStrides[0]] : [b3dStrides[1], 1, b3dStrides[0]],\n    _ref4 = _slicedToArray(_ref3, 3),\n    bInnerStep = _ref4[0],\n    bOuterStep = _ref4[1],\n    bBatch = _ref4[2];\n  var size = leftDim * rightDim;\n  var result = buffer([batchDim, leftDim, rightDim], a3d.dtype);\n  var resVals = result.values;\n  var blockSize = backend.blockSize;\n  for (var bi = 0; bi < batchDim; bi++) {\n    var batchIndexA = bi % batchDimA;\n    var batchIndexB = bi % batchDimB;\n    for (var i0 = 0; i0 < leftDim; i0 += blockSize) {\n      // for when blockSize doesn't evenly divide the input\n      var iBlock = Math.min(i0 + blockSize, leftDim);\n      for (var j0 = 0; j0 < rightDim; j0 += blockSize) {\n        var jBlock = Math.min(j0 + blockSize, rightDim);\n        for (var k0 = 0; k0 < sharedDim; k0 += blockSize) {\n          var kBlock = Math.min(k0 + blockSize, sharedDim);\n          for (var i = i0; i < iBlock; i++) {\n            for (var j = j0; j < jBlock; j++) {\n              var sum = 0.0;\n              for (var k = k0; k < kBlock; k++) {\n                var aVal =\n                // tslint:disable-next-line: max-line-length\n                a3dValues[batchIndexA * aBatch + i * aOuterStep + k * aInnerStep];\n                var bVal =\n                // tslint:disable-next-line: max-line-length\n                b3dValues[k * bInnerStep + j * bOuterStep + batchIndexB * bBatch];\n                sum += aVal * bVal;\n              }\n              resVals[bi * size + (i * rightDim + j)] += sum;\n            }\n          }\n        }\n      }\n    }\n  }\n  backend.disposeIntermediateTensorInfo(a3d);\n  backend.disposeIntermediateTensorInfo(b3d);\n  // set correct shape on output.\n  return backend.makeTensorInfo(outShape, result.dtype, result.values);\n}\nexport var batchMatMulConfig = {\n  kernelName: BatchMatMul,\n  backendName: 'cpu',\n  kernelFunc: batchMatMul\n};","map":{"version":3,"mappings":"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","names":["BatchMatMul","broadcast_util","buffer","util","assertNotComplex","reshape","batchMatMul","args","inputs","backend","attrs","a","b","transposeA","transposeB","aRank","shape","length","bRank","innerShapeA","innerShapeB","outerShapeA","outerShapeB","outerDimsA","slice","outerDimsB","batchDimA","sizeFromShape","batchDimB","outShapeOuterDims","assertAndGetBroadcastShape","outShape","concat","assert","a3dShape","b3dShape","a3d","x","b3d","sharedDim","leftDim","rightDim","batchDim","Math","max","a3dValues","data","get","dataId","values","b3dValues","a3dStrides","computeStrides","b3dStrides","aBatch","aOuterStep","aInnerStep","bInnerStep","bOuterStep","bBatch","size","result","dtype","resVals","blockSize","bi","batchIndexA","batchIndexB","i0","iBlock","min","j0","jBlock","k0","kBlock","i","j","sum","k","aVal","bVal","disposeIntermediateTensorInfo","makeTensorInfo","batchMatMulConfig","kernelName","backendName","kernelFunc"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-backend-cpu\\src\\kernels\\BatchMatMul.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {BatchMatMul, BatchMatMulAttrs, BatchMatMulInputs, broadcast_util, buffer, KernelConfig, KernelFunc, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nimport {reshape} from './Reshape';\n\nexport function batchMatMul(args: {\n  inputs: BatchMatMulInputs,\n  attrs: BatchMatMulAttrs,\n  backend: MathBackendCPU\n}) {\n  const {inputs, backend, attrs} = args;\n  const {a, b} = inputs;\n  const {transposeA, transposeB} = attrs;\n\n  assertNotComplex([a, b], 'matMul');\n\n  const aRank = a.shape.length;\n  const bRank = b.shape.length;\n\n  const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n  const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n\n  const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n  const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n\n  const outerDimsA = a.shape.slice(0, -2);\n  const outerDimsB = b.shape.slice(0, -2);\n\n  const batchDimA = util.sizeFromShape(outerDimsA);\n  const batchDimB = util.sizeFromShape(outerDimsB);\n\n  const outShapeOuterDims = broadcast_util.assertAndGetBroadcastShape(\n      a.shape.slice(0, -2), b.shape.slice(0, -2));\n  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n\n  util.assert(\n      innerShapeA === innerShapeB,\n      () => `Error in matMul: inner shapes (${innerShapeA}) and (` +\n          `${innerShapeB}) of Tensors with shapes ${a.shape} and ` +\n          `${b.shape} and transposeA=${transposeA}` +\n          ` and transposeB=${transposeB} must match.`);\n\n  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] :\n                                [batchDimA, outerShapeA, innerShapeA];\n  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] :\n                                [batchDimB, innerShapeB, outerShapeB];\n\n  // The rest of the implementation is designed to operate on rank-3 tensors\n  const a3d = reshape({inputs: {x: a}, backend, attrs: {shape: a3dShape}});\n  const b3d = reshape({inputs: {x: b}, backend, attrs: {shape: b3dShape}});\n\n  const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n  const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];\n  const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];\n  const batchDim = Math.max(batchDimA, batchDimB);\n\n  const a3dValues = backend.data.get(a3d.dataId).values as TypedArray;\n  const b3dValues = backend.data.get(b3d.dataId).values as TypedArray;\n\n  const a3dStrides = util.computeStrides(a3d.shape);\n  const b3dStrides = util.computeStrides(b3d.shape);\n\n  const [aBatch, aOuterStep, aInnerStep] = transposeA ?\n      [a3dStrides[0], 1, a3dStrides[1]] :\n      [a3dStrides[0], a3dStrides[1], 1];\n  const [bInnerStep, bOuterStep, bBatch] = transposeB ?\n      [1, b3dStrides[1], b3dStrides[0]] :\n      [b3dStrides[1], 1, b3dStrides[0]];\n\n  const size = leftDim * rightDim;\n  const result = buffer([batchDim, leftDim, rightDim], a3d.dtype);\n\n  const resVals = result.values as TypedArray;\n  const blockSize = backend.blockSize;\n\n  for (let bi = 0; bi < batchDim; bi++) {\n    const batchIndexA = bi % batchDimA;\n    const batchIndexB = bi % batchDimB;\n    for (let i0 = 0; i0 < leftDim; i0 += blockSize) {\n      // for when blockSize doesn't evenly divide the input\n      const iBlock = Math.min(i0 + blockSize, leftDim);\n      for (let j0 = 0; j0 < rightDim; j0 += blockSize) {\n        const jBlock = Math.min(j0 + blockSize, rightDim);\n        for (let k0 = 0; k0 < sharedDim; k0 += blockSize) {\n          const kBlock = Math.min(k0 + blockSize, sharedDim);\n\n          for (let i = i0; i < iBlock; i++) {\n            for (let j = j0; j < jBlock; j++) {\n              let sum = 0.0;\n\n              for (let k = k0; k < kBlock; k++) {\n                const aVal =\n                    // tslint:disable-next-line: max-line-length\n                    a3dValues[batchIndexA * aBatch + i * aOuterStep + k * aInnerStep];\n                const bVal =\n                    // tslint:disable-next-line: max-line-length\n                    b3dValues[k * bInnerStep + j * bOuterStep + batchIndexB * bBatch];\n                sum += aVal * bVal;\n              }\n              resVals[bi * size + (i * rightDim + j)] += sum;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  backend.disposeIntermediateTensorInfo(a3d);\n  backend.disposeIntermediateTensorInfo(b3d);\n\n  // set correct shape on output.\n  return backend.makeTensorInfo(\n      outShape, result.dtype, result.values as TypedArray);\n}\n\nexport const batchMatMulConfig: KernelConfig = {\n  kernelName: BatchMatMul,\n  backendName: 'cpu',\n  kernelFunc: batchMatMul as unknown as KernelFunc,\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}