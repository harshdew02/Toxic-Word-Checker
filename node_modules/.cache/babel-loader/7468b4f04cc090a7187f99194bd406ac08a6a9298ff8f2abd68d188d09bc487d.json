{"ast":null,"code":"import _classCallCheck from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { serialization } from '@tensorflow/tfjs-core';\nimport { getUid } from '../backend/state';\nimport { ValueError } from '../errors';\nimport { Layer, Node, SymbolicTensor } from './topology';\nexport var InputLayer = /*#__PURE__*/function (_Layer) {\n  _inherits(InputLayer, _Layer);\n  var _super = _createSuper(InputLayer);\n  function InputLayer(args) {\n    var _this;\n    _classCallCheck(this, InputLayer);\n    _this = _super.call(this, {\n      dtype: args.dtype,\n      name: args.name != null ? args.name : getUid('input').toString()\n    });\n    // Normalize config.batchSize and config.sparse\n    if (args.batchSize == null) {\n      args.batchSize = null;\n    }\n    if (args.sparse == null) {\n      args.sparse = false;\n    }\n    _this.trainable = false;\n    _this.built = true;\n    _this.sparse = args.sparse;\n    if (args.inputShape != null && args.batchInputShape != null) {\n      throw new ValueError('Only provide the inputShape OR ' + 'batchInputShape argument to inputLayer, not both at the same time.');\n    }\n    var batchInputShape = args.batchInputShape;\n    if (batchInputShape == null) {\n      if (args.inputShape == null) {\n        throw new ValueError('An InputLayer should be passed either a ' + '`batchInputShape` or an `inputShape`.');\n      } else {\n        batchInputShape = [args.batchSize].concat(args.inputShape);\n      }\n    } else {\n      // TODO(michaelterry): Backport to PyKeras\n      if (args.batchSize != null) {\n        throw new ValueError('Cannot specify batchSize if batchInputShape is ' + 'specified when creating an InputLayer.');\n      }\n    }\n    var dtype = args.dtype || 'float32';\n    _this.batchInputShape = batchInputShape;\n    _this.dtype = dtype;\n    // TODO(michaelterry): Backport this to PyKeras?\n    _this.inputSpec = [{\n      shape: batchInputShape\n    }];\n    var inputTensor = new SymbolicTensor(_this.dtype, _this.batchInputShape, _assertThisInitialized(_this), [], {}, _this.name);\n    inputTensor.nodeIndex = 0;\n    inputTensor.tensorIndex = 0;\n    // Create an input node to add to this.outboundNode.\n    // (This call has side effects.)\n    // tslint:disable-next-line:no-unused-expression\n    new Node({\n      outboundLayer: _assertThisInitialized(_this),\n      inboundLayers: [],\n      nodeIndices: [],\n      tensorIndices: [],\n      inputTensors: [inputTensor],\n      outputTensors: [inputTensor],\n      inputMasks: [null],\n      outputMasks: [null],\n      inputShapes: [batchInputShape],\n      outputShapes: [batchInputShape]\n    });\n    return _this;\n  }\n  _createClass(InputLayer, [{\n    key: \"apply\",\n    value: function apply(inputs, kwargs) {\n      throw new ValueError('Cannot pass any input to an ' + \"InputLayer's apply() method. InputLayer name: \".concat(this.name));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      // dispose() for InputLayer is overridden as no-op.\n      return {\n        refCountAfterDispose: this._refCount,\n        numDisposedVariables: 0\n      };\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return {\n        batchInputShape: this.batchInputShape,\n        dtype: this.dtype,\n        sparse: this.sparse,\n        name: this.name\n      };\n    }\n  }]);\n  return InputLayer;\n}(Layer);\n/** @nocollapse */\nInputLayer.className = 'InputLayer';\nserialization.registerClass(InputLayer);\nexport function Input(config) {\n  if (config.batchShape == null && config.shape == null) {\n    throw new Error('Please provide to Input either a `shape`' + ' or a `batchShape` argument. Note that ' + '`shape` does not include the batch ' + 'dimension.');\n  }\n  if (config.batchShape != null && config.shape != null) {\n    // TODO(michaelterry): Backport to PyKeras.\n    throw new ValueError('Please provide either a `shape` or `batchShape` ' + 'argument to Input, but not both.');\n  }\n  var batchShape = config.batchShape;\n  if (config.shape != null && batchShape == null) {\n    batchShape = [null].concat(config.shape);\n  }\n  var dtype = config.dtype;\n  if (dtype == null) {\n    dtype = 'float32';\n  }\n  var inputLayer = new InputLayer({\n    batchInputShape: batchShape,\n    name: config.name,\n    dtype: dtype,\n    sparse: config.sparse\n  });\n  var outputs = inputLayer.inboundNodes[0].outputTensors;\n  return outputs[0];\n}","map":{"version":3,"mappings":"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","names":["serialization","getUid","ValueError","Layer","Node","SymbolicTensor","InputLayer","args","dtype","name","toString","batchSize","sparse","trainable","built","inputShape","batchInputShape","concat","inputSpec","shape","inputTensor","nodeIndex","tensorIndex","outboundLayer","inboundLayers","nodeIndices","tensorIndices","inputTensors","outputTensors","inputMasks","outputMasks","inputShapes","outputShapes","inputs","kwargs","refCountAfterDispose","_refCount","numDisposedVariables","registerClass","Input","config","batchShape","Error","inputLayer","outputs","inboundNodes"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-layers\\src\\engine\\input_layer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport {DataType, serialization, Tensor} from '@tensorflow/tfjs-core';\n\nimport {getUid} from '../backend/state';\nimport {ValueError} from '../errors';\nimport {Shape} from '../keras_format/common';\nimport {Kwargs} from '../types';\n\nimport {DisposeResult, Layer, Node, SymbolicTensor} from './topology';\n\n/**\n * Constructor arguments for InputLayer.\n *\n * Note: You should provide only inputShape or batchInputShape (not both).\n * If only inputShape is provided, then the batchInputShape is determined by\n * the batchSize argument and the inputShape: [batchSize].concat(inputShape).\n */\nexport declare interface InputLayerArgs {\n  /** Input shape, not including the batch axis. */\n  inputShape?: Shape;\n  /** Optional input batch size (integer or null). */\n  batchSize?: number;\n  /** Batch input shape, including the batch axis. */\n  batchInputShape?: Shape;\n  /** Datatype of the input.  */\n  dtype?: DataType;\n  /**\n   * Whether the placeholder created is meant to be sparse.\n   */\n  sparse?: boolean;  // TODO(michaelterry): Not clear whether we'll need this.\n\n  /** Name of the layer. */\n  name?: string;\n}\n\nexport class InputLayer extends Layer {\n  /** @nocollapse */\n  static readonly className = 'InputLayer';\n  sparse: boolean;\n  constructor(args: InputLayerArgs) {\n    super({\n      dtype: args.dtype,\n      name: args.name != null ? args.name : getUid('input').toString()\n    });\n    // Normalize config.batchSize and config.sparse\n    if (args.batchSize == null) {\n      args.batchSize = null;\n    }\n    if (args.sparse == null) {\n      args.sparse = false;\n    }\n\n    this.trainable = false;\n    this.built = true;\n    this.sparse = args.sparse;\n\n    if (args.inputShape != null && args.batchInputShape != null) {\n      throw new ValueError(\n          'Only provide the inputShape OR ' +\n          'batchInputShape argument to inputLayer, not both at the same time.');\n    }\n    let batchInputShape = args.batchInputShape;\n    if (batchInputShape == null) {\n      if (args.inputShape == null) {\n        throw new ValueError(\n            'An InputLayer should be passed either a ' +\n            '`batchInputShape` or an `inputShape`.');\n      } else {\n        batchInputShape = [args.batchSize].concat(args.inputShape);\n      }\n    } else {\n      // TODO(michaelterry): Backport to PyKeras\n      if (args.batchSize != null) {\n        throw new ValueError(\n            'Cannot specify batchSize if batchInputShape is ' +\n            'specified when creating an InputLayer.');\n      }\n    }\n\n    const dtype = args.dtype || 'float32';\n\n    this.batchInputShape = batchInputShape;\n    this.dtype = dtype;\n    // TODO(michaelterry): Backport this to PyKeras?\n    this.inputSpec = [{shape: batchInputShape}];\n\n    const inputTensor = new SymbolicTensor(\n        this.dtype, this.batchInputShape, this, [], {}, this.name);\n    inputTensor.nodeIndex = 0;\n    inputTensor.tensorIndex = 0;\n\n    // Create an input node to add to this.outboundNode.\n    // (This call has side effects.)\n    // tslint:disable-next-line:no-unused-expression\n    new Node({\n      outboundLayer: this,\n      inboundLayers: [],\n      nodeIndices: [],\n      tensorIndices: [],\n      inputTensors: [inputTensor],\n      outputTensors: [inputTensor],\n      inputMasks: [null],\n      outputMasks: [null],\n      inputShapes: [batchInputShape],\n      outputShapes: [batchInputShape]\n    });\n  }\n\n  override apply(\n      inputs: Tensor|Tensor[]|SymbolicTensor|SymbolicTensor[],\n      kwargs?: Kwargs): Tensor|Tensor[]|SymbolicTensor {\n    throw new ValueError(\n        'Cannot pass any input to an ' +\n        `InputLayer's apply() method. InputLayer name: ${this.name}`);\n  }\n\n  override dispose(): DisposeResult {\n    // dispose() for InputLayer is overridden as no-op.\n    return {refCountAfterDispose: this._refCount, numDisposedVariables: 0};\n  }\n\n  override getConfig(): serialization.ConfigDict {\n    return {\n      batchInputShape: this.batchInputShape,\n      dtype: this.dtype,\n      sparse: this.sparse,\n      name: this.name\n    };\n  }\n}\nserialization.registerClass(InputLayer);\n\n/**\n * Config for the Input function.\n *\n * Note: You should provide only shape or batchShape (not both).\n * If only shape is provided, then the batchShape becomes\n * [null].concat(inputShape).\n */\nexport interface InputConfig {\n  /**\n   * A shape, not including the batch size. For instance, `shape=[32]`\n   * indicates that the expected input will be batches of 32-dimensional\n   * vectors.\n   */\n  shape?: Shape;\n  /**\n   * A shape tuple (integer), including the batch size. For instance,\n   * `batchShape=[10, 32]` indicates that the expected input will be batches of\n   * 10 32-dimensional vectors. `batchShape=[null, 32]` indicates batches of an\n   * arbitrary number of 32-dimensional vectors.\n   */\n  batchShape?: Shape;\n  /**\n   * An optional name string for the layer. Should be unique in a model (do not\n   * reuse the same name twice). It will be autogenerated if it isn't provided.\n   */\n  name?: string;\n  dtype?: DataType;\n  /**\n   * A boolean specifying whether the placeholder to be created is sparse.\n   */\n  sparse?: boolean;\n}\n\nexport function Input(config: InputConfig): SymbolicTensor {\n  if (config.batchShape == null && config.shape == null) {\n    throw new Error(\n        'Please provide to Input either a `shape`' +\n        ' or a `batchShape` argument. Note that ' +\n        '`shape` does not include the batch ' +\n        'dimension.');\n  }\n  if (config.batchShape != null && config.shape != null) {\n    // TODO(michaelterry): Backport to PyKeras.\n    throw new ValueError(\n        'Please provide either a `shape` or `batchShape` ' +\n        'argument to Input, but not both.');\n  }\n  let batchShape = config.batchShape;\n  if (config.shape != null && batchShape == null) {\n    batchShape = [null].concat(config.shape);\n  }\n\n  let dtype = config.dtype;\n  if (dtype == null) {\n    dtype = 'float32';\n  }\n\n  const inputLayer = new InputLayer({\n    batchInputShape: batchShape,\n    name: config.name,\n    dtype,\n    sparse: config.sparse\n  });\n\n  const outputs = inputLayer.inboundNodes[0].outputTensors;\n  return outputs[0];\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}