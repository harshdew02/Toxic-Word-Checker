{"ast":null,"code":"import _createForOfIteratorHelper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, broadcastTo, reshape, tidy, util } from '@tensorflow/tfjs-core';\nvar RowPartitionType = backend_util.RowPartitionType;\n// Based on\n// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc\nvar RaggedTensorToTensorOp = /*#__PURE__*/function () {\n  function RaggedTensorToTensorOp(shape, shapeShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypeStrings) {\n    _classCallCheck(this, RaggedTensorToTensorOp);\n    this.shape = shape;\n    this.shapeShape = shapeShape;\n    this.values = values;\n    this.valuesShape = valuesShape;\n    this.valuesDType = valuesDType;\n    this.defaultValue = defaultValue;\n    this.defaultValueShape = defaultValueShape;\n    this.rowPartitionValues = rowPartitionValues;\n    this.rowPartitionValuesShapes = rowPartitionValuesShapes;\n    this.rowPartitionTypes = backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);\n    this.raggedRank = backend_util.getRaggedRank(this.rowPartitionTypes);\n  }\n  _createClass(RaggedTensorToTensorOp, [{\n    key: \"getRowPartitionTypeByDimension\",\n    value: function getRowPartitionTypeByDimension(dimension) {\n      if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n        return this.rowPartitionTypes[dimension + 1];\n      } else {\n        return this.rowPartitionTypes[dimension];\n      }\n    }\n    // Returns the relationship between dimension and dimension + 1.\n  }, {\n    key: \"getRowPartitionTensor\",\n    value: function getRowPartitionTensor(dimension) {\n      if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n        return this.rowPartitionValues[dimension + 1];\n      } else {\n        return this.rowPartitionValues[dimension];\n      }\n    }\n  }, {\n    key: \"getMaxWidth\",\n    value: function getMaxWidth(dimension) {\n      var rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);\n      switch (this.getRowPartitionTypeByDimension(dimension - 1)) {\n        case RowPartitionType.VALUE_ROWIDS:\n          return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);\n        case RowPartitionType.ROW_SPLITS:\n          return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);\n        default:\n          throw new Error(\"Cannot handle partition type \".concat(RowPartitionType[this.getRowPartitionTypeByDimension(dimension - 1)]));\n      }\n    }\n  }, {\n    key: \"tensorShapeFromTensor\",\n    value: function tensorShapeFromTensor(t, tShape) {\n      var isPartial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (tShape.length === 0) {\n        if (t[0] === -1) {\n          return [];\n        }\n        throw new Error(\"The only valid scalar shape tensor is the fully unknown shape specified as -1.\");\n      }\n      // MakePartialShape/MakeShapeHelper.\n      return makeShape(t, isPartial);\n    }\n  }, {\n    key: \"calculateOutputSize\",\n    value: function calculateOutputSize(firstDim) {\n      var valueShape = this.valuesShape;\n      var defaultValueShape = this.defaultValueShape;\n      backend_util.validateDefaultValueShape(defaultValueShape, valueShape);\n      var shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);\n      var outputShape = backend_util.combineRaggedTensorToTensorShapes(this.raggedRank, shape, valueShape);\n      var result = outputShape;\n      if (result[0] < 0) {\n        result[0] = firstDim;\n      }\n      for (var i = 1; i <= this.raggedRank; ++i) {\n        if (result[i] < 0) {\n          result[i] = this.getMaxWidth(i);\n        }\n      }\n      return result;\n    }\n    /**\n     * The outputIndex represents the index in the output tensor\n     * where the first element of a particular dimension would be written.\n     * If it is -1, it indicates that the index is out of scope.\n     * Example, given firstDimension = 10, firstDimensionOutput = 6,\n     * and outputIndexMultiplier = 100:\n     * result = [0 100 200 300 400 500 -1 -1 -1 -1]\n     * If firstDimensionOutput = 11 instead, then:\n     * result = [0 100 200 300 400 500 600 700 800 900]\n     */\n  }, {\n    key: \"calculateFirstParentOutputIndex\",\n    value: function calculateFirstParentOutputIndex(firstDimension, outputIndexMultiplier, firstDimensionOutput) {\n      var minDimension = Math.min(firstDimension, firstDimensionOutput);\n      var result = [];\n      var currentOutputIndex = 0;\n      for (var i = 0; i < minDimension; ++i, currentOutputIndex += outputIndexMultiplier) {\n        result.push(currentOutputIndex);\n      }\n      for (var _i = minDimension; _i < firstDimension; ++_i) {\n        result.push(-1);\n      }\n      util.assert(result.length === firstDimension, function () {\n        return 'Final length of result must be equal to firstDimension.';\n      });\n      return result;\n    }\n  }, {\n    key: \"calculateOutputIndexRowSplit\",\n    value: function calculateOutputIndexRowSplit(rowSplit, parentOutputIndex, outputIndexMultiplier, outputSize) {\n      var rowSplitSize = rowSplit.length;\n      var result = [];\n      for (var i = 0; i < rowSplitSize - 1; ++i) {\n        var rowLength = rowSplit[i + 1] - rowSplit[i];\n        var realLength = Math.min(outputSize, rowLength);\n        var parentOutputIndexCurrent = parentOutputIndex[i];\n        if (parentOutputIndexCurrent === -1) {\n          realLength = 0;\n        }\n        for (var j = 0; j < realLength; ++j) {\n          result.push(parentOutputIndexCurrent);\n          parentOutputIndexCurrent += outputIndexMultiplier;\n        }\n        for (var _j = 0; _j < rowLength - realLength; ++_j) {\n          result.push(-1);\n        }\n      }\n      if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {\n        throw new Error('Invalid row split size.');\n      }\n      return result;\n    }\n    // Calculate the output index of the first element of a list.\n    // The parentOutputIndex is the same computation for the previous list.\n    // -1 indicates an element or list that is out of range.\n    // The outputIndexMultiplier is the number of output indices one moves\n    // forward for each column.\n    // E.g., given:\n    // valueRowIds:[0 1 2 2 2 3 5 5 6]\n    // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]\n    // outputIndexMultiplier: 10\n    // outputSize: 2\n    // You get:\n    // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]\n    // result[0] = parentOutputIndex[valueRowIds[0]]\n    // result[1] = parentOutputIndex[valueRowIds[1]]\n    // result[2] = parentOutputIndex[valueRowIds[2]]\n    // result[3] = parentOutputIndex[valueRowIds[2] + 10]\n    // result[4] = -1 because it is the third element the size is 2.\n    // result[5] = parentOutputIndex[valueRowIds[3]]\n    // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n    // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n    // result[8] = parentOutputIndex[valueRowIds[7]]\n  }, {\n    key: \"calculateOutputIndexValueRowID\",\n    value: function calculateOutputIndexValueRowID(valueRowIds, parentOutputIndex, outputIndexMultiplier, outputSize) {\n      var indexSize = valueRowIds.length;\n      var result = [];\n      if (indexSize === 0) {\n        return [];\n      }\n      var currentOutputColumn = 0;\n      var currentValueRowId = valueRowIds[0];\n      if (currentValueRowId >= parentOutputIndex.length) {\n        throw new Error(\"Got currentValueRowId=\".concat(currentValueRowId, \", which is not less than \").concat(parentOutputIndex.length));\n      }\n      var currentOutputIndex = parentOutputIndex[currentValueRowId];\n      result.push(currentOutputIndex);\n      for (var i = 1; i < indexSize; ++i) {\n        var nextValueRowId = valueRowIds[i];\n        if (nextValueRowId === currentValueRowId) {\n          if (currentOutputIndex >= 0) {\n            ++currentOutputColumn;\n            if (currentOutputColumn < outputSize) {\n              currentOutputIndex += outputIndexMultiplier;\n            } else {\n              currentOutputIndex = -1;\n            }\n          }\n        } else {\n          currentOutputColumn = 0;\n          currentValueRowId = nextValueRowId;\n          if (nextValueRowId >= parentOutputIndex.length) {\n            throw new Error(\"Got nextValueRowId=\".concat(nextValueRowId, \" which is not less than \").concat(parentOutputIndex.length));\n          }\n          currentOutputIndex = parentOutputIndex[nextValueRowId];\n        }\n        result.push(currentOutputIndex);\n      }\n      if (result.length !== valueRowIds.length) {\n        throw new Error('Invalid row ids.');\n      }\n      return result;\n    }\n  }, {\n    key: \"calculateOutputIndex\",\n    value: function calculateOutputIndex(dimension, parentOutputIndex, outputIndexMultiplier, outputSize) {\n      var rowPartitionTensor = this.getRowPartitionTensor(dimension);\n      var partitionType = this.getRowPartitionTypeByDimension(dimension);\n      switch (partitionType) {\n        case RowPartitionType.VALUE_ROWIDS:\n          return this.calculateOutputIndexValueRowID(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n        case RowPartitionType.ROW_SPLITS:\n          if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {\n            throw new Error(\"Row partition size is greater than output size: \".concat(rowPartitionTensor.length - 1, \" > \").concat(parentOutputIndex.length));\n          }\n          return this.calculateOutputIndexRowSplit(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n        default:\n          throw new Error(\"Unsupported partition type: \".concat(RowPartitionType[partitionType]));\n      }\n    }\n  }, {\n    key: \"getFirstDimensionSize\",\n    value: function getFirstDimensionSize() {\n      var firstPartitionTensor = this.rowPartitionValues[0];\n      if (this.rowPartitionTypes.length === 0) {\n        throw new Error('No row_partition_types given.');\n      }\n      var firstPartitionType = this.rowPartitionTypes[0];\n      switch (firstPartitionType) {\n        case RowPartitionType.FIRST_DIM_SIZE:\n          return firstPartitionTensor[0];\n        case RowPartitionType.VALUE_ROWIDS:\n          throw new Error('Cannot handle VALUE_ROWIDS in first dimension.');\n        case RowPartitionType.ROW_SPLITS:\n          return this.rowPartitionValuesShapes[0][0] - 1;\n        default:\n          throw new Error(\"Cannot handle type \".concat(RowPartitionType[firstPartitionType]));\n      }\n    }\n  }, {\n    key: \"compute\",\n    value: function compute() {\n      var firstPartitionTensor = this.rowPartitionValues[0];\n      if (firstPartitionTensor.length <= 0) {\n        throw new Error('Invalid first partition input. ' + 'Tensor requires at least one element.');\n      }\n      var firstDimension = this.getFirstDimensionSize();\n      var outputSize = this.calculateOutputSize(firstDimension);\n      var multiplier = new Array(this.raggedRank + 1);\n      multiplier[multiplier.length - 1] = 1;\n      for (var i = multiplier.length - 2; i >= 0; --i) {\n        multiplier[i] = multiplier[i + 1] * outputSize[i + 1];\n      }\n      // Full size of the tensor.\n      var outputShape = makeShape(outputSize, false);\n      var outputTensor = util.getArrayFromDType(this.valuesDType, util.sizeFromShape(outputShape));\n      var fullSize = multiplier[0] * outputSize[0];\n      if (fullSize > 0) {\n        var outputIndex = this.calculateFirstParentOutputIndex(firstDimension, multiplier[0], outputSize[0]);\n        for (var _i2 = 1; _i2 <= this.raggedRank; ++_i2) {\n          var newOutputIndex = this.calculateOutputIndex(_i2 - 1, outputIndex, multiplier[_i2], outputSize[_i2]);\n          outputIndex = newOutputIndex;\n        }\n        this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);\n      }\n      return [outputShape, outputTensor];\n    }\n  }, {\n    key: \"setOutput\",\n    value: function setOutput(raggedRank, outputIndex, outputTensor, outputShape) {\n      if (outputTensor.length === 0) {\n        return;\n      }\n      var valuesBase = this.values;\n      var outputBase = outputTensor;\n      var elementShape = outputShape.slice();\n      elementShape = elementShape.slice(raggedRank + 1);\n      var valueElementSize = util.sizeFromShape(elementShape);\n      var outputIndexSize = outputIndex.length;\n      // Broadcast the default value to value_element_size.  (We can skip this\n      // if defaultValueTensor.size == 1, since we use fill when that's true.)\n      var defaultValue = this.defaultValue;\n      if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {\n        var srcShape = this.defaultValueShape;\n        tidy(function () {\n          var defaultValueTensor = reshape(defaultValue, srcShape);\n          var bCastDefault = broadcastTo(defaultValueTensor, elementShape);\n          defaultValue = bCastDefault.dataSync();\n        });\n      }\n      // Loop through the outputIndex array, finding contiguous regions that\n      // should be copied.  Once we find the end of a contiguous region, copy it\n      // and add any necessary padding (with defaultValue).\n      var srcStart = 0; // Start of contiguous region (in values)\n      var dstStart = 0; // Destination for contiguous region (in output)\n      var dstEnd = 0; // Destination for contiguous region (in output)\n      for (var srcI = 0; srcI <= outputIndexSize; ++srcI) {\n        // dstI is the destination where the value at srcI should be copied.\n        var dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;\n        // If we're still in a contiguous region, then update dstEnd go to the\n        // next srcI.\n        if (dstI === dstEnd) {\n          ++dstEnd;\n          continue;\n        }\n        // We found the end of contiguous region.  This can be because we found\n        // a gap (dstI > dstEnd), or a source value that shouldn't be copied\n        // because it's out-of-bounds (dstI == -1), or the end of the tensor\n        // (dstI === -1).\n        if (dstStart < dstEnd) {\n          // Copy the contiguous region.\n          var src = valuesBase.subarray(srcStart * valueElementSize);\n          var dst = outputBase.subarray(dstStart * valueElementSize);\n          var nVals = (dstEnd - dstStart) * valueElementSize;\n          copyArray(dst, src, nVals);\n        }\n        // Add any necessary padding (w/ defaultValue).\n        if (srcI >= outputIndexSize) {\n          // We reached the end of values: pad to the end of output.\n          var outputSize = outputTensor.length;\n          dstI = Math.floor(outputSize / valueElementSize);\n        }\n        if (dstI > dstEnd) {\n          if (this.defaultValue.length === 1) {\n            outputBase.subarray(dstEnd * valueElementSize, dstI * valueElementSize).fill(this.defaultValue[0]);\n            dstEnd = dstI;\n          } else {\n            while (dstI > dstEnd) {\n              var _dst = outputBase.slice(dstEnd * valueElementSize);\n              copyArray(_dst, defaultValue, valueElementSize);\n              ++dstEnd;\n            }\n          }\n        }\n        // Update indices.\n        if (dstI < 0) {\n          // srcI should be skipped -- leave it out of the contiguous region.\n          srcStart = srcI + 1;\n          dstStart = dstEnd;\n        } else {\n          // srcI should be copied -- include it in the contiguous region.\n          srcStart = srcI;\n          dstStart = dstEnd;\n          dstEnd = dstStart + 1;\n        }\n      }\n    }\n  }], [{\n    key: \"getMaxWidthRowSplit\",\n    value: function getMaxWidthRowSplit(rowSplit) {\n      var tensorLength = rowSplit.length;\n      if (tensorLength === 0 || tensorLength === 1) {\n        return 0;\n      }\n      var maxWidth = 0;\n      for (var i = 0; i < tensorLength - 1; ++i) {\n        var currentWidth = rowSplit[i + 1] - rowSplit[i];\n        if (currentWidth > maxWidth) {\n          maxWidth = currentWidth;\n        }\n      }\n      return maxWidth;\n    }\n  }, {\n    key: \"getMaxWidthValueRowID\",\n    value: function getMaxWidthValueRowID(valueRowIds) {\n      var indexLength = valueRowIds.length;\n      if (indexLength === 0) {\n        return 0;\n      }\n      var firstEqualIndex = 0;\n      var firstEqualIndexValue = valueRowIds[0];\n      var maxWidth = 0;\n      for (var i = 1; i < indexLength; ++i) {\n        var value = valueRowIds[i];\n        if (value !== firstEqualIndexValue) {\n          firstEqualIndexValue = value;\n          maxWidth = Math.max(i - firstEqualIndex, maxWidth);\n          firstEqualIndex = i;\n        }\n      }\n      return Math.max(indexLength - firstEqualIndex, maxWidth);\n    }\n  }]);\n  return RaggedTensorToTensorOp;\n}();\nfunction copyArray(dst, src, size) {\n  for (var i = 0; i < size; i++) {\n    dst[i] = src[i];\n  }\n}\nfunction makeShape(shape, isPartial) {\n  var out = [];\n  var _iterator = _createForOfIteratorHelper(shape),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var dim = _step.value;\n      if (dim < 0) {\n        if (!isPartial) {\n          throw new Error(\"Dimension \".concat(dim, \" must be >= 0\"));\n        }\n        if (dim < -1) {\n          throw new Error(\"Dimension \".concat(dim, \" must be >= -1\"));\n        }\n        dim = -1;\n      }\n      out.push(dim);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return out;\n}\nexport function raggedTensorToTensorImpl(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes) {\n  return new RaggedTensorToTensorOp(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes).compute();\n}","map":{"version":3,"mappings":"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","names":["backend_util","broadcastTo","reshape","tidy","util","RowPartitionType","RaggedTensorToTensorOp","shape","shapeShape","values","valuesShape","valuesDType","defaultValue","defaultValueShape","rowPartitionValues","rowPartitionValuesShapes","rowPartitionTypeStrings","rowPartitionTypes","getRowPartitionTypesHelper","raggedRank","getRaggedRank","dimension","FIRST_DIM_SIZE","rowPartitionTensor","getRowPartitionTensor","getRowPartitionTypeByDimension","VALUE_ROWIDS","getMaxWidthValueRowID","ROW_SPLITS","getMaxWidthRowSplit","Error","t","tShape","isPartial","length","makeShape","firstDim","valueShape","validateDefaultValueShape","tensorShapeFromTensor","outputShape","combineRaggedTensorToTensorShapes","result","i","getMaxWidth","firstDimension","outputIndexMultiplier","firstDimensionOutput","minDimension","Math","min","currentOutputIndex","push","assert","rowSplit","parentOutputIndex","outputSize","rowSplitSize","rowLength","realLength","parentOutputIndexCurrent","j","valueRowIds","indexSize","currentOutputColumn","currentValueRowId","nextValueRowId","partitionType","calculateOutputIndexValueRowID","calculateOutputIndexRowSplit","firstPartitionTensor","firstPartitionType","getFirstDimensionSize","calculateOutputSize","multiplier","Array","outputTensor","getArrayFromDType","sizeFromShape","fullSize","outputIndex","calculateFirstParentOutputIndex","newOutputIndex","calculateOutputIndex","setOutput","valuesBase","outputBase","elementShape","slice","valueElementSize","outputIndexSize","srcShape","defaultValueTensor","bCastDefault","dataSync","srcStart","dstStart","dstEnd","srcI","dstI","src","subarray","dst","nVals","copyArray","floor","fill","tensorLength","maxWidth","currentWidth","indexLength","firstEqualIndex","firstEqualIndexValue","value","max","size","out","dim","raggedTensorToTensorImpl","shapesShape","compute"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-backend-cpu\\src\\kernels\\RaggedTensorToTensor_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, broadcastTo, DataType, reshape, tidy, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport RowPartitionType = backend_util.RowPartitionType;\n// Based on\n// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc\nclass RaggedTensorToTensorOp {\n  private readonly rowPartitionTypes: RowPartitionType[];\n  private readonly raggedRank: number;\n  constructor(\n      private shape: TypedArray, private shapeShape: number[],\n      private values: TypedArray, private valuesShape: number[],\n      private valuesDType: DataType, private defaultValue: TypedArray,\n      private defaultValueShape: number[],\n      private readonly rowPartitionValues: TypedArray[],\n      private readonly rowPartitionValuesShapes: number[][],\n      rowPartitionTypeStrings: string[]) {\n    this.rowPartitionTypes =\n        backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);\n    this.raggedRank = backend_util.getRaggedRank(this.rowPartitionTypes);\n  }\n\n  private getRowPartitionTypeByDimension(dimension: number) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionTypes[dimension + 1];\n    } else {\n      return this.rowPartitionTypes[dimension];\n    }\n  }\n\n  // Returns the relationship between dimension and dimension + 1.\n  private getRowPartitionTensor(dimension: number) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionValues[dimension + 1];\n    } else {\n      return this.rowPartitionValues[dimension];\n    }\n  }\n\n  private getMaxWidth(dimension: number) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);\n    switch (this.getRowPartitionTypeByDimension(dimension - 1)) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);\n      case RowPartitionType.ROW_SPLITS:\n        return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);\n      default:\n        throw new Error(`Cannot handle partition type ${\n            RowPartitionType[this.getRowPartitionTypeByDimension(\n                dimension - 1)]}`);\n    }\n  }\n\n  static getMaxWidthRowSplit(rowSplit: TypedArray) {\n    const tensorLength = rowSplit.length;\n    if (tensorLength === 0 || tensorLength === 1) {\n      return 0;\n    }\n    let maxWidth = 0;\n    for (let i = 0; i < tensorLength - 1; ++i) {\n      const currentWidth = rowSplit[i + 1] - rowSplit[i];\n      if (currentWidth > maxWidth) {\n        maxWidth = currentWidth;\n      }\n    }\n    return maxWidth;\n  }\n\n  static getMaxWidthValueRowID(valueRowIds: TypedArray) {\n    const indexLength = valueRowIds.length;\n    if (indexLength === 0) {\n      return 0;\n    }\n    let firstEqualIndex = 0;\n    let firstEqualIndexValue = valueRowIds[0];\n    let maxWidth = 0;\n    for (let i = 1; i < indexLength; ++i) {\n      const value = valueRowIds[i];\n      if (value !== firstEqualIndexValue) {\n        firstEqualIndexValue = value;\n        maxWidth = Math.max(i - firstEqualIndex, maxWidth);\n        firstEqualIndex = i;\n      }\n    }\n    return Math.max(indexLength - firstEqualIndex, maxWidth);\n  }\n\n  private tensorShapeFromTensor(\n      t: TypedArray, tShape: number[], isPartial = true) {\n    if (tShape.length === 0) {\n      if (t[0] === -1) {\n        return [];\n      }\n      throw new Error(\n          `The only valid scalar shape tensor is the fully unknown shape specified as -1.`);\n    }\n    // MakePartialShape/MakeShapeHelper.\n    return makeShape(t, isPartial);\n  }\n\n  private calculateOutputSize(firstDim: number) {\n    const valueShape = this.valuesShape;\n    const defaultValueShape = this.defaultValueShape;\n\n    backend_util.validateDefaultValueShape(defaultValueShape, valueShape);\n\n    const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);\n    const outputShape = backend_util.combineRaggedTensorToTensorShapes(\n        this.raggedRank, shape, valueShape);\n\n    const result = outputShape;\n\n    if (result[0] < 0) {\n      result[0] = firstDim;\n    }\n    for (let i = 1; i <= this.raggedRank; ++i) {\n      if (result[i] < 0) {\n        result[i] = this.getMaxWidth(i);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * The outputIndex represents the index in the output tensor\n   * where the first element of a particular dimension would be written.\n   * If it is -1, it indicates that the index is out of scope.\n   * Example, given firstDimension = 10, firstDimensionOutput = 6,\n   * and outputIndexMultiplier = 100:\n   * result = [0 100 200 300 400 500 -1 -1 -1 -1]\n   * If firstDimensionOutput = 11 instead, then:\n   * result = [0 100 200 300 400 500 600 700 800 900]\n   */\n  private calculateFirstParentOutputIndex(\n      firstDimension: number, outputIndexMultiplier: number,\n      firstDimensionOutput: number) {\n    const minDimension = Math.min(firstDimension, firstDimensionOutput);\n    const result: number[] = [];\n    let currentOutputIndex = 0;\n    for (let i = 0; i < minDimension;\n         ++i, currentOutputIndex += outputIndexMultiplier) {\n      result.push(currentOutputIndex);\n    }\n    for (let i = minDimension; i < firstDimension; ++i) {\n      result.push(-1);\n    }\n    util.assert(\n        result.length === firstDimension,\n        () => 'Final length of result must be equal to firstDimension.');\n\n    return result;\n  }\n\n  private calculateOutputIndexRowSplit(\n      rowSplit: TypedArray, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const rowSplitSize = rowSplit.length;\n    const result: number[] = [];\n    for (let i = 0; i < rowSplitSize - 1; ++i) {\n      const rowLength = rowSplit[i + 1] - rowSplit[i];\n      let realLength = Math.min(outputSize, rowLength);\n      let parentOutputIndexCurrent = parentOutputIndex[i];\n\n      if (parentOutputIndexCurrent === -1) {\n        realLength = 0;\n      }\n      for (let j = 0; j < realLength; ++j) {\n        result.push(parentOutputIndexCurrent);\n        parentOutputIndexCurrent += outputIndexMultiplier;\n      }\n      for (let j = 0; j < rowLength - realLength; ++j) {\n        result.push(-1);\n      }\n    }\n    if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {\n      throw new Error('Invalid row split size.');\n    }\n\n    return result;\n  }\n\n  // Calculate the output index of the first element of a list.\n  // The parentOutputIndex is the same computation for the previous list.\n  // -1 indicates an element or list that is out of range.\n  // The outputIndexMultiplier is the number of output indices one moves\n  // forward for each column.\n  // E.g., given:\n  // valueRowIds:[0 1 2 2 2 3 5 5 6]\n  // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]\n  // outputIndexMultiplier: 10\n  // outputSize: 2\n  // You get:\n  // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]\n  // result[0] = parentOutputIndex[valueRowIds[0]]\n  // result[1] = parentOutputIndex[valueRowIds[1]]\n  // result[2] = parentOutputIndex[valueRowIds[2]]\n  // result[3] = parentOutputIndex[valueRowIds[2] + 10]\n  // result[4] = -1 because it is the third element the size is 2.\n  // result[5] = parentOutputIndex[valueRowIds[3]]\n  // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[8] = parentOutputIndex[valueRowIds[7]]\n  private calculateOutputIndexValueRowID(\n      valueRowIds: TypedArray, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const indexSize = valueRowIds.length;\n    const result: number[] = [];\n    if (indexSize === 0) {\n      return [];\n    }\n\n    let currentOutputColumn = 0;\n    let currentValueRowId = valueRowIds[0];\n\n    if (currentValueRowId >= parentOutputIndex.length) {\n      throw new Error(\n          `Got currentValueRowId=${currentValueRowId}, which is not less than ${\n              parentOutputIndex.length}`);\n    }\n\n    let currentOutputIndex = parentOutputIndex[currentValueRowId];\n    result.push(currentOutputIndex);\n    for (let i = 1; i < indexSize; ++i) {\n      const nextValueRowId = valueRowIds[i];\n      if (nextValueRowId === currentValueRowId) {\n        if (currentOutputIndex >= 0) {\n          ++currentOutputColumn;\n          if (currentOutputColumn < outputSize) {\n            currentOutputIndex += outputIndexMultiplier;\n          } else {\n            currentOutputIndex = -1;\n          }\n        }\n      } else {\n        currentOutputColumn = 0;\n        currentValueRowId = nextValueRowId;\n\n        if (nextValueRowId >= parentOutputIndex.length) {\n          throw new Error(\n              `Got nextValueRowId=${nextValueRowId} which is not less than ${\n                  parentOutputIndex.length}`);\n        }\n\n        currentOutputIndex = parentOutputIndex[nextValueRowId];\n      }\n      result.push(currentOutputIndex);\n    }\n\n    if (result.length !== valueRowIds.length) {\n      throw new Error('Invalid row ids.');\n    }\n\n    return result;\n  }\n\n  private calculateOutputIndex(\n      dimension: number, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension);\n    const partitionType = this.getRowPartitionTypeByDimension(dimension);\n    switch (partitionType) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return this.calculateOutputIndexValueRowID(\n            rowPartitionTensor, parentOutputIndex, outputIndexMultiplier,\n            outputSize);\n      case RowPartitionType.ROW_SPLITS:\n        if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {\n          throw new Error(`Row partition size is greater than output size: ${\n              rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);\n        }\n        return this.calculateOutputIndexRowSplit(\n            rowPartitionTensor, parentOutputIndex, outputIndexMultiplier,\n            outputSize);\n      default:\n        throw new Error(\n            `Unsupported partition type: ${RowPartitionType[partitionType]}`);\n    }\n  }\n\n  private getFirstDimensionSize() {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (this.rowPartitionTypes.length === 0) {\n      throw new Error('No row_partition_types given.');\n    }\n    const firstPartitionType = this.rowPartitionTypes[0];\n    switch (firstPartitionType) {\n      case RowPartitionType.FIRST_DIM_SIZE:\n        return firstPartitionTensor[0];\n      case RowPartitionType.VALUE_ROWIDS:\n        throw new Error('Cannot handle VALUE_ROWIDS in first dimension.');\n      case RowPartitionType.ROW_SPLITS:\n        return this.rowPartitionValuesShapes[0][0] - 1;\n      default:\n        throw new Error(\n            `Cannot handle type ${RowPartitionType[firstPartitionType]}`);\n    }\n  }\n\n  compute(): [number[], TypedArray] {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (firstPartitionTensor.length <= 0) {\n      throw new Error(\n          'Invalid first partition input. ' +\n          'Tensor requires at least one element.');\n    }\n    const firstDimension = this.getFirstDimensionSize();\n    const outputSize = this.calculateOutputSize(firstDimension);\n    const multiplier: number[] = new Array(this.raggedRank + 1);\n\n    multiplier[multiplier.length - 1] = 1;\n    for (let i = multiplier.length - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * outputSize[i + 1];\n    }\n    // Full size of the tensor.\n    const outputShape: number[] = makeShape(outputSize, false);\n    const outputTensor =\n        util.getArrayFromDType(\n            this.valuesDType, util.sizeFromShape(outputShape)) as TypedArray;\n\n    const fullSize = multiplier[0] * outputSize[0];\n    if (fullSize > 0) {\n      let outputIndex = this.calculateFirstParentOutputIndex(\n          firstDimension, multiplier[0], outputSize[0]);\n      for (let i = 1; i <= this.raggedRank; ++i) {\n        const newOutputIndex = this.calculateOutputIndex(\n            i - 1, outputIndex, multiplier[i], outputSize[i]);\n        outputIndex = newOutputIndex;\n      }\n\n      this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);\n    }\n\n    return [outputShape, outputTensor];\n  }\n  setOutput(\n      raggedRank: number, outputIndex: number[], outputTensor: TypedArray,\n      outputShape: number[]) {\n    if (outputTensor.length === 0) {\n      return;\n    }\n\n    const valuesBase = this.values;\n    const outputBase = outputTensor;\n\n    let elementShape = outputShape.slice();\n    elementShape = elementShape.slice(raggedRank + 1);\n    const valueElementSize = util.sizeFromShape(elementShape);\n    const outputIndexSize = outputIndex.length;\n\n    // Broadcast the default value to value_element_size.  (We can skip this\n    // if defaultValueTensor.size == 1, since we use fill when that's true.)\n    let defaultValue = this.defaultValue;\n    if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {\n      const srcShape = this.defaultValueShape;\n      tidy(() => {\n        const defaultValueTensor = reshape(defaultValue, srcShape);\n        const bCastDefault = broadcastTo(defaultValueTensor, elementShape);\n        defaultValue = bCastDefault.dataSync();\n      });\n    }\n\n    // Loop through the outputIndex array, finding contiguous regions that\n    // should be copied.  Once we find the end of a contiguous region, copy it\n    // and add any necessary padding (with defaultValue).\n    let srcStart = 0;  // Start of contiguous region (in values)\n    let dstStart = 0;  // Destination for contiguous region (in output)\n    let dstEnd = 0;    // Destination for contiguous region (in output)\n    for (let srcI = 0; srcI <= outputIndexSize; ++srcI) {\n      // dstI is the destination where the value at srcI should be copied.\n      let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;\n\n      // If we're still in a contiguous region, then update dstEnd go to the\n      // next srcI.\n      if (dstI === dstEnd) {\n        ++dstEnd;\n        continue;\n      }\n\n      // We found the end of contiguous region.  This can be because we found\n      // a gap (dstI > dstEnd), or a source value that shouldn't be copied\n      // because it's out-of-bounds (dstI == -1), or the end of the tensor\n      // (dstI === -1).\n      if (dstStart < dstEnd) {\n        // Copy the contiguous region.\n        const src = valuesBase.subarray(srcStart * valueElementSize);\n        const dst = outputBase.subarray(dstStart * valueElementSize);\n        const nVals = (dstEnd - dstStart) * valueElementSize;\n        copyArray(dst, src, nVals);\n      }\n\n      // Add any necessary padding (w/ defaultValue).\n      if (srcI >= outputIndexSize) {\n        // We reached the end of values: pad to the end of output.\n        const outputSize = outputTensor.length;\n        dstI = Math.floor(outputSize / valueElementSize);\n      }\n      if (dstI > dstEnd) {\n        if (this.defaultValue.length === 1) {\n          outputBase\n              .subarray(dstEnd * valueElementSize, dstI * valueElementSize)\n              .fill(this.defaultValue[0]);\n          dstEnd = dstI;\n        } else {\n          while (dstI > dstEnd) {\n            const dst = outputBase.slice(dstEnd * valueElementSize);\n            copyArray(dst, defaultValue, valueElementSize);\n            ++dstEnd;\n          }\n        }\n      }\n\n      // Update indices.\n      if (dstI < 0) {\n        // srcI should be skipped -- leave it out of the contiguous region.\n        srcStart = srcI + 1;\n        dstStart = dstEnd;\n      } else {\n        // srcI should be copied -- include it in the contiguous region.\n        srcStart = srcI;\n        dstStart = dstEnd;\n        dstEnd = dstStart + 1;\n      }\n    }\n  }\n}\n\nfunction copyArray(dst: TypedArray, src: TypedArray, size: number) {\n  for (let i = 0; i < size; i++) {\n    dst[i] = src[i];\n  }\n}\n\nfunction makeShape(shape: number[]|TypedArray, isPartial: boolean) {\n  const out: number[] = [];\n  for (let dim of shape) {\n    if (dim < 0) {\n      if (!isPartial) {\n        throw new Error(`Dimension ${dim} must be >= 0`);\n      }\n      if (dim < -1) {\n        throw new Error(`Dimension ${dim} must be >= -1`);\n      }\n      dim = -1;\n    }\n    out.push(dim);\n  }\n\n  return out;\n}\n\nexport function raggedTensorToTensorImpl(\n    shape: TypedArray, shapesShape: number[], values: TypedArray,\n    valuesShape: number[], valuesDType: DataType, defaultValue: TypedArray,\n    defaultValueShape: number[], rowPartitionValues: TypedArray[],\n    rowPartitionValuesShapes: number[][],\n    rowPartitionTypes: string[]): [number[], TypedArray] {\n  return new RaggedTensorToTensorOp(\n             shape, shapesShape, values, valuesShape, valuesDType, defaultValue,\n             defaultValueShape, rowPartitionValues, rowPartitionValuesShapes,\n             rowPartitionTypes)\n      .compute();\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}