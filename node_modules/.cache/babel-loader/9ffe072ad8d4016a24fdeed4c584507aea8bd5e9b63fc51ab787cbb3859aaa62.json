{"ast":null,"code":"import { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { conv2d } from './conv2d';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Computes a 1D convolution over the input x.\n *\n * @param x The input tensor, of rank 3 or rank 2, of shape\n *     `[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.\n * @param filter The filter, rank 3, of shape\n *     `[filterWidth, inDepth, outDepth]`.\n * @param stride The number of entries by which the filter is moved right at\n *     each step.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\n *     the data is stored in the order of [batch, in_width, in_channels]. Only\n *     \"NWC\" is currently supported.\n * @param dilation The dilation rate in which we sample input values in\n *     atrous convolution. Defaults to `1`. If it is greater than 1, then\n *     stride must be `1`.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction conv1d_(x, filter, stride, pad) {\n  var dataFormat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'NWC';\n  var dilation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n  var dimRoundingMode = arguments.length > 6 ? arguments[6] : undefined;\n  var $x = convertToTensor(x, 'x', 'conv1d');\n  var $filter = convertToTensor(filter, 'filter', 'conv1d');\n  var x3D = $x;\n  var reshapedTo3D = false;\n  if ($x.rank === 2) {\n    reshapedTo3D = true;\n    x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);\n  }\n  util.assert(x3D.rank === 3, function () {\n    return \"Error in conv1d: input must be rank 3, but got rank \".concat(x3D.rank, \".\");\n  });\n  util.assert($filter.rank === 3, function () {\n    return \"Error in conv1d: filter must be rank 3, but got rank \" + \"\".concat($filter.rank, \".\");\n  });\n  conv_util.checkPadOnDimRoundingMode('conv1d', pad, dimRoundingMode);\n  util.assert(x3D.shape[2] === $filter.shape[1], function () {\n    return \"Error in conv1d: depth of input (\".concat(x3D.shape[2], \") must match \") + \"input depth for filter \".concat($filter.shape[1], \".\");\n  });\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(stride, dilation), function () {\n    return 'Error in conv1D: Either stride or dilation must be 1. ' + \"Got stride \".concat(stride, \" and dilation '\").concat(dilation, \"'\");\n  });\n  util.assert(conv_util.stridesOrDilationsArePositive(dilation), function () {\n    return 'Error in conv1D: Dilated rates should be larger than 0.';\n  });\n  util.assert(conv_util.stridesOrDilationsArePositive(stride), function () {\n    return 'Error in conv1D: Stride should be larger than 0.';\n  });\n  util.assert(dataFormat === 'NWC', function () {\n    return \"Error in conv1d: got dataFormat of \".concat(dataFormat, \" but only NWC is currently supported.\");\n  });\n  var filter4D = reshape($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);\n  var input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);\n  var strides = [1, stride];\n  var dilations = [1, dilation];\n  var conv2dDataFormat = 'NHWC';\n  var res = conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);\n  if (reshapedTo3D) {\n    return reshape(res, [res.shape[2], res.shape[3]]);\n  }\n  return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]);\n}\nexport var conv1d = /* @__PURE__ */op({\n  conv1d_: conv1d_\n});","map":{"version":3,"mappings":"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","names":["convertToTensor","util","conv2d","conv_util","op","reshape","conv1d_","x","filter","stride","pad","dataFormat","dilation","dimRoundingMode","$x","$filter","x3D","reshapedTo3D","rank","shape","assert","checkPadOnDimRoundingMode","eitherStridesOrDilationsAreOne","stridesOrDilationsArePositive","filter4D","input4D","strides","dilations","conv2dDataFormat","res","conv1d"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-core\\src\\ops\\conv1d.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor2D, Tensor3D, Tensor4D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {conv2d} from './conv2d';\nimport * as conv_util from './conv_util';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes a 1D convolution over the input x.\n *\n * @param x The input tensor, of rank 3 or rank 2, of shape\n *     `[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.\n * @param filter The filter, rank 3, of shape\n *     `[filterWidth, inDepth, outDepth]`.\n * @param stride The number of entries by which the filter is moved right at\n *     each step.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\n *     the data is stored in the order of [batch, in_width, in_channels]. Only\n *     \"NWC\" is currently supported.\n * @param dilation The dilation rate in which we sample input values in\n *     atrous convolution. Defaults to `1`. If it is greater than 1, then\n *     stride must be `1`.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction conv1d_<T extends Tensor2D|Tensor3D>(\n    x: T|TensorLike, filter: Tensor3D|TensorLike, stride: number,\n    pad: 'valid'|'same'|number|conv_util.ExplicitPadding,\n    dataFormat: 'NWC'|'NCW' = 'NWC', dilation = 1,\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'conv1d');\n  const $filter = convertToTensor(filter, 'filter', 'conv1d');\n\n  let x3D = $x as Tensor3D;\n  let reshapedTo3D = false;\n  if ($x.rank === 2) {\n    reshapedTo3D = true;\n    x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);\n  }\n\n  util.assert(\n      x3D.rank === 3,\n      () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);\n  util.assert(\n      $filter.rank === 3,\n      () => `Error in conv1d: filter must be rank 3, but got rank ` +\n          `${$filter.rank}.`);\n  conv_util.checkPadOnDimRoundingMode('conv1d', pad, dimRoundingMode);\n  util.assert(\n      x3D.shape[2] === $filter.shape[1],\n      () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match ` +\n          `input depth for filter ${$filter.shape[1]}.`);\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(stride, dilation),\n      () => 'Error in conv1D: Either stride or dilation must be 1. ' +\n          `Got stride ${stride} and dilation '${dilation}'`);\n  util.assert(\n      conv_util.stridesOrDilationsArePositive(dilation),\n      () => 'Error in conv1D: Dilated rates should be larger than 0.');\n  util.assert(\n      conv_util.stridesOrDilationsArePositive(stride),\n      () => 'Error in conv1D: Stride should be larger than 0.');\n  util.assert(\n      dataFormat === 'NWC',\n      () => `Error in conv1d: got dataFormat of ${\n          dataFormat} but only NWC is currently supported.`);\n\n  const filter4D = reshape(\n      $filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);\n  const input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);\n  const strides: [number, number] = [1, stride];\n  const dilations: [number, number] = [1, dilation];\n\n  const conv2dDataFormat = 'NHWC';\n\n  const res = conv2d(\n      (input4D as Tensor4D), (filter4D as Tensor4D), strides, pad,\n      conv2dDataFormat, dilations, dimRoundingMode);\n\n  if (reshapedTo3D) {\n    return reshape(res, [res.shape[2], res.shape[3]]) as T;\n  }\n\n  return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]) as T;\n}\n\nexport const conv1d = /* @__PURE__ */ op({conv1d_});\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}