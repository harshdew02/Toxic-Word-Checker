{"ast":null,"code":"import _slicedToArray from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Import webgl flags.\nimport './flags_webgl';\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, nextFrame, scalar, tidy, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { DecodeMatrixProgram } from './decode_matrix_gpu';\nimport { DecodeMatrixPackedProgram } from './decode_matrix_packed_gpu';\nimport { EncodeFloatProgram } from './encode_float_gpu';\nimport { EncodeFloatPackedProgram } from './encode_float_packed_gpu';\nimport { EncodeMatrixProgram } from './encode_matrix_gpu';\nimport { EncodeMatrixPackedProgram } from './encode_matrix_packed_gpu';\nimport { GPGPUContext } from './gpgpu_context';\nimport * as gpgpu_math from './gpgpu_math';\nimport { getUniformLocations as _getUniformLocations } from './gpgpu_math';\nimport { simpleAbsImplCPU } from './kernel_utils/shared';\nimport { PackProgram } from './pack_gpu';\nimport { ReshapePackedProgram } from './reshape_packed_gpu';\nimport * as tex_util from './tex_util';\nimport { TextureUsage } from './tex_util';\nimport { TextureManager } from './texture_manager';\nimport * as unary_op from './unaryop_gpu';\nimport { UnaryOpProgram } from './unaryop_gpu';\nimport { UnaryOpPackedProgram } from './unaryop_packed_gpu';\nimport { UnpackProgram } from './unpack_gpu';\nimport * as webgl_util from './webgl_util';\nvar whereImpl = kernel_impls.whereImpl;\nexport var EPSILON_FLOAT32 = 1e-7;\nexport var EPSILON_FLOAT16 = 1e-4;\nvar binaryCaches = {};\nexport function getBinaryCache(webGLVersion) {\n  if (webGLVersion in binaryCaches) {\n    return binaryCaches[webGLVersion];\n  }\n  binaryCaches[webGLVersion] = {};\n  return binaryCaches[webGLVersion];\n}\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nvar CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber('CPU_HANDOFF_SIZE_THRESHOLD');\n// Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\nvar BEFORE_PAGING_CONSTANT = 600;\nfunction numMBBeforeWarning() {\n  if (env().global.screen == null) {\n    return 1024; // 1 GB.\n  }\n\n  return env().global.screen.height * env().global.screen.width * window.devicePixelRatio * BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\nexport var MathBackendWebGL = /*#__PURE__*/function (_KernelBackend) {\n  _inherits(MathBackendWebGL, _KernelBackend);\n  var _super = _createSuper(MathBackendWebGL);\n  function MathBackendWebGL(gpuResource) {\n    var _this;\n    _classCallCheck(this, MathBackendWebGL);\n    _this = _super.call(this);\n    // Maps data ids that have a pending read operation, to list of subscribers.\n    _this.pendingRead = new WeakMap();\n    // List of data ids that are scheduled for disposal, but are waiting on a\n    // pending read operation.\n    _this.pendingDisposal = new WeakSet();\n    // Used to count the number of 'shallow' sliced tensors that point to the\n    // same data id.\n    _this.dataRefCount = new WeakMap();\n    _this.numBytesInGPU = 0;\n    // Accumulated time spent (including blocking) in uploading data to webgl.\n    _this.uploadWaitMs = 0;\n    // Accumulated time spent (including blocking in downloading data from webgl.\n    _this.downloadWaitMs = 0;\n    // record the last manual GL Flush time.\n    _this.lastGlFlushTime = 0;\n    _this.warnedAboutMemory = false;\n    _this.pendingDeletes = 0;\n    _this.disposed = false;\n    if (!env().getBool('HAS_WEBGL')) {\n      throw new Error('WebGL is not supported on this device');\n    }\n    var newGPGPU;\n    if (gpuResource != null) {\n      if (gpuResource instanceof GPGPUContext) {\n        newGPGPU = gpuResource;\n      } else {\n        var gl = getWebGLContext(env().getNumber('WEBGL_VERSION'), gpuResource);\n        newGPGPU = new GPGPUContext(gl);\n      }\n      _this.binaryCache = {};\n      _this.gpgpuCreatedLocally = false;\n    } else {\n      var _gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));\n      newGPGPU = new GPGPUContext(_gl);\n      _this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));\n      _this.gpgpuCreatedLocally = true;\n    }\n    _this.gpgpu = newGPGPU;\n    _this.canvas = _this.gpgpu.gl.canvas;\n    _this.textureManager = new TextureManager(_this.gpgpu);\n    _this.numMBBeforeWarning = numMBBeforeWarning();\n    _this.texData = new DataStorage(_assertThisInitialized(_this), engine());\n    return _this;\n  }\n  _createClass(MathBackendWebGL, [{\n    key: \"nextDataId\",\n    value: function nextDataId() {\n      return MathBackendWebGL.nextDataId++;\n    }\n  }, {\n    key: \"numDataIds\",\n    value: function numDataIds() {\n      return this.texData.numDataIds() - this.pendingDeletes;\n    }\n    // Writes a new entry to the data store with a WebGL texture, and registers it\n    // to the texture manager.\n  }, {\n    key: \"writeTexture\",\n    value: function writeTexture(texture, shape, dtype, texHeight, texWidth, channels) {\n      // Temporarily create an tensor info to make the texture compatible with\n      // the runWebGLProgram's input.\n      var input = this.makeTensorInfo(shape, dtype);\n      var inData = this.texData.get(input.dataId);\n      // Even though the input texture could be unpacked or dense packed, it is\n      // always considered as unpacked for EncodeMatrixProgram.\n      inData.isPacked = false;\n      // Bind texture to the input tensor.\n      inData.texture = {\n        texture: texture,\n        texShape: [texHeight, texWidth]\n      };\n      inData.texShape = [texHeight, texWidth];\n      var shapeAs3D = webgl_util.getShapeAs3D(shape);\n      var program = new EncodeMatrixProgram(shapeAs3D, false /* isByteArray */, channels);\n      var output = this.runWebGLProgram(program, [input], dtype, [[texHeight, texWidth]]);\n      output.shape = shape;\n      // Unbind the texture from the input tensor to avoid the texture being\n      // released.\n      inData.texture = null;\n      this.disposeIntermediateTensorInfo(input);\n      return output.dataId;\n    }\n  }, {\n    key: \"write\",\n    value: function write(values, shape, dtype) {\n      if (env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') || env().getBool('DEBUG')) {\n        this.checkNumericalProblems(values);\n      }\n      if (dtype === 'complex64' && values != null) {\n        throw new Error(\"Cannot write to a complex64 dtype. \" + \"Please use tf.complex(real, imag).\");\n      }\n      var dataId = {\n        id: this.nextDataId()\n      };\n      this.texData.set(dataId, {\n        shape: shape,\n        dtype: dtype,\n        values: values,\n        usage: TextureUsage.UPLOAD,\n        refCount: 1\n      });\n      return dataId;\n    }\n    /** Return refCount of a `TensorData`. */\n  }, {\n    key: \"refCount\",\n    value: function refCount(dataId) {\n      if (this.texData.has(dataId)) {\n        var tensorData = this.texData.get(dataId);\n        return tensorData.refCount;\n      }\n      return 0;\n    }\n    /** Increase refCount of a `TextureData`. */\n  }, {\n    key: \"incRef\",\n    value: function incRef(dataId) {\n      var texData = this.texData.get(dataId);\n      texData.refCount++;\n    }\n    /** Decrease refCount of a `TextureData`. */\n  }, {\n    key: \"decRef\",\n    value: function decRef(dataId) {\n      if (this.texData.has(dataId)) {\n        var texData = this.texData.get(dataId);\n        texData.refCount--;\n      }\n    }\n  }, {\n    key: \"move\",\n    value: function move(dataId, values, shape, dtype, refCount) {\n      if (env().getBool('DEBUG')) {\n        this.checkNumericalProblems(values);\n      }\n      if (dtype === 'complex64') {\n        throw new Error(\"Cannot write to a complex64 dtype. \" + \"Please use tf.complex(real, imag).\");\n      }\n      this.texData.set(dataId, {\n        shape: shape,\n        dtype: dtype,\n        values: values,\n        usage: TextureUsage.UPLOAD,\n        refCount: refCount\n      });\n    }\n  }, {\n    key: \"disposeIntermediateTensorInfo\",\n    value: function disposeIntermediateTensorInfo(tensorInfo) {\n      this.disposeData(tensorInfo.dataId);\n    }\n  }, {\n    key: \"readSync\",\n    value: function readSync(dataId) {\n      var texData = this.texData.get(dataId);\n      var values = texData.values,\n        dtype = texData.dtype,\n        complexTensorInfos = texData.complexTensorInfos,\n        slice = texData.slice,\n        shape = texData.shape,\n        isPacked = texData.isPacked;\n      // The presence of `slice` indicates this tensor is a shallow slice of a\n      // different tensor, and is using that original tensor's texture. Run\n      // `clone` in order to copy that texture and read from it.\n      if (slice != null) {\n        var program;\n        if (isPacked) {\n          program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n        } else {\n          program = new UnaryOpProgram(shape, unary_op.CLONE);\n        }\n        var res = this.runWebGLProgram(program, [{\n          dataId: dataId,\n          shape: shape,\n          dtype: dtype\n        }], dtype);\n        var data = this.readSync(res.dataId);\n        this.disposeIntermediateTensorInfo(res);\n        return data;\n      }\n      if (values != null) {\n        return this.convertAndCacheOnCPU(dataId);\n      }\n      if (dtype === 'string') {\n        return values;\n      }\n      var shouldTimeProgram = this.activeTimers != null;\n      var start;\n      if (shouldTimeProgram) {\n        start = util.now();\n      }\n      var result;\n      if (dtype === 'complex64') {\n        var realValues = this.readSync(complexTensorInfos.real.dataId);\n        var imagValues = this.readSync(complexTensorInfos.imag.dataId);\n        result = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n      } else {\n        result = this.getValuesFromTexture(dataId);\n      }\n      if (shouldTimeProgram) {\n        this.downloadWaitMs += util.now() - start;\n      }\n      return this.convertAndCacheOnCPU(dataId, result);\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dataId) {\n        var _subscribers, texData, values, shape, slice, dtype, complexTensorInfos, isPacked, program, res, data, buffer, tmpDownloadTarget, _this$gpgpu, tmpData, vals, ps, realValues, imagValues, size, gl, dTypeVals, subscribers;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.pendingRead.has(dataId)) {\n                _context.next = 3;\n                break;\n              }\n              _subscribers = this.pendingRead.get(dataId);\n              return _context.abrupt(\"return\", new Promise(function (resolve) {\n                return _subscribers.push(resolve);\n              }));\n            case 3:\n              texData = this.texData.get(dataId);\n              values = texData.values, shape = texData.shape, slice = texData.slice, dtype = texData.dtype, complexTensorInfos = texData.complexTensorInfos, isPacked = texData.isPacked; // The presence of `slice` indicates this tensor is a shallow slice of a\n              // different tensor, and is using that original tensor's texture. Run\n              // `clone` in order to copy that texture and read from it.\n              if (!(slice != null)) {\n                _context.next = 11;\n                break;\n              }\n              if (isPacked) {\n                program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n              } else {\n                program = new UnaryOpProgram(shape, unary_op.CLONE);\n              }\n              res = this.runWebGLProgram(program, [{\n                dataId: dataId,\n                shape: shape,\n                dtype: dtype\n              }], dtype);\n              data = this.read(res.dataId);\n              this.disposeIntermediateTensorInfo(res);\n              return _context.abrupt(\"return\", data);\n            case 11:\n              if (!(values != null)) {\n                _context.next = 13;\n                break;\n              }\n              return _context.abrupt(\"return\", this.convertAndCacheOnCPU(dataId));\n            case 13:\n              if (!env().getBool('DEBUG')) {\n                _context.next = 16;\n                break;\n              }\n              if (!(!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') && env().getNumber('WEBGL_VERSION') === 2)) {\n                _context.next = 16;\n                break;\n              }\n              throw new Error(\"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and \" + \"WEBGL_VERSION=2 not yet supported.\");\n            case 16:\n              buffer = null;\n              if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {\n                // Possibly copy the texture into a buffer before inserting a fence.\n                tmpDownloadTarget = this.decode(dataId);\n                tmpData = this.texData.get(tmpDownloadTarget.dataId);\n                buffer = (_this$gpgpu = this.gpgpu).createBufferFromTexture.apply(_this$gpgpu, [tmpData.texture.texture].concat(_toConsumableArray(tex_util.getDenseTexShape(shape))));\n              }\n              this.pendingRead.set(dataId, []);\n              if (!(dtype !== 'complex64')) {\n                _context.next = 22;\n                break;\n              }\n              _context.next = 22;\n              return this.gpgpu.createAndWaitForFence();\n            case 22:\n              if (!(dtype === 'complex64')) {\n                _context.next = 31;\n                break;\n              }\n              _context.next = 25;\n              return Promise.all([this.read(complexTensorInfos.real.dataId), this.read(complexTensorInfos.imag.dataId)]);\n            case 25:\n              ps = _context.sent;\n              realValues = ps[0];\n              imagValues = ps[1];\n              vals = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n              _context.next = 32;\n              break;\n            case 31:\n              if (buffer == null) {\n                vals = this.getValuesFromTexture(dataId);\n              } else {\n                size = util.sizeFromShape(shape);\n                vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n              }\n            case 32:\n              if (tmpDownloadTarget != null) {\n                this.disposeIntermediateTensorInfo(tmpDownloadTarget);\n              }\n              if (buffer != null) {\n                gl = this.gpgpu.gl;\n                webgl_util.callAndCheck(gl, function () {\n                  return gl.deleteBuffer(buffer);\n                });\n              }\n              dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n              subscribers = this.pendingRead.get(dataId);\n              this.pendingRead.delete(dataId);\n              // Notify all pending reads.\n              subscribers.forEach(function (resolve) {\n                return resolve(dTypeVals);\n              });\n              if (this.pendingDisposal.has(dataId)) {\n                this.pendingDisposal.delete(dataId);\n                if (this.disposeData(dataId)) {\n                  engine().removeDataId(dataId, this);\n                }\n                this.pendingDeletes--;\n              }\n              return _context.abrupt(\"return\", dTypeVals);\n            case 40:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function read(_x) {\n        return _read.apply(this, arguments);\n      }\n      return read;\n    }()\n    /**\n     * Read tensor to a new texture that is densely packed for ease of use.\n     * @param dataId The source tensor.\n     * @param options\n     *     customTexShape: Optional. If set, will use the user defined texture\n     *     shape to create the texture.\n     */\n  }, {\n    key: \"readToGPU\",\n    value: function readToGPU(dataId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var texData = this.texData.get(dataId);\n      var values = texData.values,\n        shape = texData.shape,\n        slice = texData.slice,\n        dtype = texData.dtype,\n        isPacked = texData.isPacked,\n        texture = texData.texture;\n      if (dtype === 'complex64') {\n        throw new Error('Does not support reading texture for complex64 dtype.');\n      }\n      // The presence of `slice` indicates this tensor is a shallow slice of a\n      // different tensor, and is using that original tensor's texture. Run\n      // `clone` in order to copy that texture and read from it.\n      if (slice != null) {\n        var program;\n        if (isPacked) {\n          program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n        } else {\n          program = new UnaryOpProgram(shape, unary_op.CLONE);\n        }\n        var res = this.runWebGLProgram(program, [{\n          dataId: dataId,\n          shape: shape,\n          dtype: dtype\n        }], dtype);\n        var gpuResouorce = this.readToGPU(res, options);\n        this.disposeIntermediateTensorInfo(res);\n        return gpuResouorce;\n      }\n      if (texture == null) {\n        if (values != null) {\n          throw new Error('Data is not on GPU but on CPU.');\n        } else {\n          throw new Error('There is no data on GPU or CPU.');\n        }\n      }\n      // Decode the texture so that it is stored densely (using four channels).\n      var tmpTarget = this.decode(dataId, options.customTexShape);\n      // Make engine track this tensor, so that we can dispose it later.\n      var tensorRef = engine().makeTensorFromTensorInfo(tmpTarget);\n      var tmpData = this.texData.get(tmpTarget.dataId);\n      return Object.assign({\n        tensorRef: tensorRef\n      }, tmpData.texture);\n    }\n  }, {\n    key: \"bufferSync\",\n    value: function bufferSync(t) {\n      var data = this.readSync(t.dataId);\n      if (t.dtype === 'string') {\n        try {\n          // Decode the bytes into string.\n          var strings = data.map(function (d) {\n            return util.decodeString(d);\n          });\n          return buffer(t.shape, t.dtype, strings);\n        } catch (_a) {\n          throw new Error('Failed to decode encoded string bytes into utf-8');\n        }\n      }\n      return buffer(t.shape, t.dtype, data);\n    }\n  }, {\n    key: \"checkNumericalProblems\",\n    value: function checkNumericalProblems(values) {\n      if (values == null) {\n        return;\n      }\n      for (var i = 0; i < values.length; i++) {\n        var num = values[i];\n        if (!webgl_util.canBeRepresented(num)) {\n          if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n            throw Error(\"The value \".concat(num, \" cannot be represented with your \") + \"current settings. Consider enabling float32 rendering: \" + \"'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'\");\n          }\n          throw Error(\"The value \".concat(num, \" cannot be represented on this device.\"));\n        }\n      }\n    }\n  }, {\n    key: \"getValuesFromTexture\",\n    value: function getValuesFromTexture(dataId) {\n      var _this$texData$get = this.texData.get(dataId),\n        shape = _this$texData$get.shape,\n        dtype = _this$texData$get.dtype,\n        isPacked = _this$texData$get.isPacked;\n      var size = util.sizeFromShape(shape);\n      if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n        var _this$gpgpu2;\n        var tmpTarget = this.decode(dataId);\n        var _tmpData = this.texData.get(tmpTarget.dataId);\n        var _vals = (_this$gpgpu2 = this.gpgpu).downloadMatrixFromPackedTexture.apply(_this$gpgpu2, [_tmpData.texture.texture].concat(_toConsumableArray(tex_util.getDenseTexShape(shape)))).subarray(0, size);\n        this.disposeIntermediateTensorInfo(tmpTarget);\n        return _vals;\n      }\n      var shouldUsePackedProgram = env().getBool('WEBGL_PACK') && isPacked === true;\n      var outputShape = shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;\n      var program = shouldUsePackedProgram ? new EncodeFloatPackedProgram(outputShape) : new EncodeFloatProgram(outputShape);\n      var output = this.runWebGLProgram(program, [{\n        shape: outputShape,\n        dtype: dtype,\n        dataId: dataId\n      }], 'float32');\n      var tmpData = this.texData.get(output.dataId);\n      var vals = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture.texture, tmpData.texShape[0], tmpData.texShape[1]).subarray(0, size);\n      this.disposeIntermediateTensorInfo(output);\n      return vals;\n    }\n  }, {\n    key: \"timerAvailable\",\n    value: function timerAvailable() {\n      return env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0;\n    }\n  }, {\n    key: \"time\",\n    value: function time(f) {\n      var _this2 = this;\n      var oldActiveTimers = this.activeTimers;\n      var newActiveTimers = [];\n      var outerMostTime = false;\n      if (this.programTimersStack == null) {\n        this.programTimersStack = newActiveTimers;\n        outerMostTime = true;\n      } else {\n        this.activeTimers.push(newActiveTimers);\n      }\n      this.activeTimers = newActiveTimers;\n      f();\n      // needing to split these up because util.flatten only accepts certain types\n      var flattenedActiveTimerQueries = util.flatten(this.activeTimers.map(function (d) {\n        return d.query;\n      })).filter(function (d) {\n        return d != null;\n      });\n      var flattenedActiveTimerNames = util.flatten(this.activeTimers.map(function (d) {\n        return d.name;\n      })).filter(function (d) {\n        return d != null;\n      });\n      this.activeTimers = oldActiveTimers;\n      if (outerMostTime) {\n        this.programTimersStack = null;\n      }\n      var res = {\n        uploadWaitMs: this.uploadWaitMs,\n        downloadWaitMs: this.downloadWaitMs,\n        kernelMs: null,\n        wallMs: null // will be filled by the engine\n      };\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var kernelMs;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0)) {\n                _context2.next = 8;\n                break;\n              }\n              _context2.next = 3;\n              return Promise.all(flattenedActiveTimerQueries);\n            case 3:\n              kernelMs = _context2.sent;\n              res['kernelMs'] = util.sum(kernelMs);\n              res['getExtraProfileInfo'] = function () {\n                return kernelMs.map(function (d, i) {\n                  return {\n                    name: flattenedActiveTimerNames[i],\n                    ms: d\n                  };\n                }).map(function (d) {\n                  return \"\".concat(d.name, \": \").concat(d.ms);\n                }).join(', ');\n              };\n              _context2.next = 9;\n              break;\n            case 8:\n              res['kernelMs'] = {\n                error: 'WebGL query timers are not supported in this environment.'\n              };\n            case 9:\n              _this2.uploadWaitMs = 0;\n              _this2.downloadWaitMs = 0;\n              return _context2.abrupt(\"return\", res);\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }))();\n    }\n  }, {\n    key: \"memory\",\n    value: function memory() {\n      return {\n        unreliable: false,\n        numBytesInGPU: this.numBytesInGPU,\n        numBytesInGPUAllocated: this.textureManager.numBytesAllocated,\n        numBytesInGPUFree: this.textureManager.numBytesFree\n      };\n    }\n  }, {\n    key: \"startTimer\",\n    value: function startTimer() {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n        return this.gpgpu.beginQuery();\n      }\n      return {\n        startMs: util.now(),\n        endMs: null\n      };\n    }\n  }, {\n    key: \"endTimer\",\n    value: function endTimer(query) {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n        this.gpgpu.endQuery();\n        return query;\n      }\n      query.endMs = util.now();\n      return query;\n    }\n  }, {\n    key: \"getQueryTime\",\n    value: function () {\n      var _getQueryTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(query) {\n        var timerQuery;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0)) {\n                _context3.next = 2;\n                break;\n              }\n              return _context3.abrupt(\"return\", this.gpgpu.waitForQueryAndGetTime(query));\n            case 2:\n              timerQuery = query;\n              return _context3.abrupt(\"return\", timerQuery.endMs - timerQuery.startMs);\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function getQueryTime(_x2) {\n        return _getQueryTime.apply(this, arguments);\n      }\n      return getQueryTime;\n    }()\n    /**\n     * Decrease the RefCount on the dataId and dispose the memory if the dataId\n     * has 0 refCount. If there are pending read on the data, the disposal would\n     * added to the pending delete queue. Return true if the dataId is removed\n     * from backend or the backend does not contain the dataId, false if the\n     * dataId is not removed. Memory may or may not be released even when dataId\n     * is removed, which also depends on dataRefCount, see `releaseGPU`.\n     * @param dataId\n     * @oaram force Optional, remove the data regardless of refCount\n     */\n  }, {\n    key: \"disposeData\",\n    value: function disposeData(dataId) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.pendingDisposal.has(dataId)) {\n        return false;\n      }\n      // No-op if already disposed.\n      if (!this.texData.has(dataId)) {\n        return true;\n      }\n      // if force flag is set, change refCount to 0, this would ensure disposal\n      // when added to the pendingDisposal queue. Memory may or may not be\n      // released, which also depends on dataRefCount, see `releaseGPU`.\n      if (force) {\n        this.texData.get(dataId).refCount = 0;\n      } else {\n        this.texData.get(dataId).refCount--;\n      }\n      if (!force && this.texData.get(dataId).refCount > 0) {\n        return false;\n      }\n      if (this.pendingRead.has(dataId)) {\n        this.pendingDisposal.add(dataId);\n        this.pendingDeletes++;\n        return false;\n      }\n      this.releaseGPUData(dataId);\n      var _this$texData$get2 = this.texData.get(dataId),\n        complexTensorInfos = _this$texData$get2.complexTensorInfos;\n      if (complexTensorInfos != null) {\n        this.disposeData(complexTensorInfos.real.dataId, force);\n        this.disposeData(complexTensorInfos.imag.dataId, force);\n      }\n      this.texData.delete(dataId);\n      return true;\n    }\n  }, {\n    key: \"releaseGPUData\",\n    value: function releaseGPUData(dataId) {\n      var _this$texData$get3 = this.texData.get(dataId),\n        texture = _this$texData$get3.texture,\n        dtype = _this$texData$get3.dtype,\n        texShape = _this$texData$get3.texShape,\n        usage = _this$texData$get3.usage,\n        isPacked = _this$texData$get3.isPacked,\n        slice = _this$texData$get3.slice;\n      var key = slice && slice.origDataId || dataId;\n      var refCount = this.dataRefCount.get(key);\n      if (refCount > 1) {\n        this.dataRefCount.set(key, refCount - 1);\n      } else {\n        this.dataRefCount.delete(key);\n        if (texture != null) {\n          this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n          this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n        }\n      }\n      var texData = this.texData.get(dataId);\n      texData.texture = null;\n      texData.texShape = null;\n      texData.isPacked = false;\n      texData.slice = null;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture(dataId) {\n      this.uploadToGPU(dataId);\n      return this.texData.get(dataId).texture.texture;\n    }\n    /**\n     * Returns internal information for the specific data bucket. Used in unit\n     * tests.\n     */\n  }, {\n    key: \"getDataInfo\",\n    value: function getDataInfo(dataId) {\n      return this.texData.get(dataId);\n    }\n    /*\n    Tests whether all the inputs to an op are small and on the CPU. This heuristic\n    determines when it would be faster to execute a kernel on the CPU. WebGL\n    kernels opt into running this check and forwarding when appropriate.\n    TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n    sustainable strategy for optimizing backend execution of ops.\n     */\n  }, {\n    key: \"shouldExecuteOnCPU\",\n    value: function shouldExecuteOnCPU(inputs) {\n      var _this3 = this;\n      var sizeThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CPU_HANDOFF_SIZE_THRESHOLD;\n      return env().getBool('WEBGL_CPU_FORWARD') && inputs.every(function (input) {\n        return _this3.texData.get(input.dataId).texture == null && util.sizeFromShape(input.shape) < sizeThreshold;\n      });\n    }\n  }, {\n    key: \"getGPGPUContext\",\n    value: function getGPGPUContext() {\n      return this.gpgpu;\n    }\n  }, {\n    key: \"where\",\n    value: function where(condition) {\n      backend_util.warn('tf.where() in webgl locks the UI thread. ' + 'Call tf.whereAsync() instead');\n      var condVals = condition.dataSync();\n      return whereImpl(condition.shape, condVals);\n    }\n  }, {\n    key: \"packedUnaryOp\",\n    value: function packedUnaryOp(x, op, dtype) {\n      var program = new UnaryOpPackedProgram(x.shape, op);\n      var outInfo = this.compileAndRun(program, [x], dtype);\n      return engine().makeTensorFromTensorInfo(outInfo);\n    }\n    // TODO(msoulanille) remove this once the backend has been modularized\n    // a copy is needed here to break a circular dependency.\n    // Also remove the op from unary_op.\n  }, {\n    key: \"abs\",\n    value: function abs(x) {\n      // TODO: handle cases when x is complex.\n      if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n        var outValues = simpleAbsImplCPU(this.texData.get(x.dataId).values);\n        return this.makeOutput(x.shape, x.dtype, outValues);\n      }\n      if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n        return this.packedUnaryOp(x, unary_op.ABS, x.dtype);\n      }\n      var program = new UnaryOpProgram(x.shape, unary_op.ABS);\n      var outInfo = this.compileAndRun(program, [x]);\n      return engine().makeTensorFromTensorInfo(outInfo);\n    }\n  }, {\n    key: \"makeTensorInfo\",\n    value: function makeTensorInfo(shape, dtype, values) {\n      var dataId;\n      if (dtype === 'string' && values != null && values.length > 0 && util.isString(values[0])) {\n        var encodedValues = values.map(function (d) {\n          return util.encodeString(d);\n        });\n        dataId = this.write(encodedValues, shape, dtype);\n      } else {\n        dataId = this.write(values, shape, dtype);\n      }\n      this.texData.get(dataId).usage = null;\n      return {\n        dataId: dataId,\n        shape: shape,\n        dtype: dtype\n      };\n    }\n  }, {\n    key: \"makeOutput\",\n    value: function makeOutput(shape, dtype, values) {\n      return engine().makeTensorFromTensorInfo(this.makeTensorInfo(shape, dtype, values), this);\n    }\n  }, {\n    key: \"unpackTensor\",\n    value: function unpackTensor(input) {\n      var program = new UnpackProgram(input.shape);\n      return this.runWebGLProgram(program, [input], input.dtype);\n    }\n  }, {\n    key: \"packTensor\",\n    value: function packTensor(input) {\n      var program = new PackProgram(input.shape);\n      var preventEagerUnpackingOutput = true;\n      return this.runWebGLProgram(program, [input], input.dtype, null /* customUniformValues */, preventEagerUnpackingOutput);\n    }\n  }, {\n    key: \"packedReshape\",\n    value: function packedReshape(input, afterShape) {\n      var input3DShape = [webgl_util.getBatchDim(input.shape)].concat(_toConsumableArray(webgl_util.getRowsCols(input.shape)));\n      var input3D = {\n        dtype: input.dtype,\n        shape: input3DShape,\n        dataId: input.dataId\n      };\n      var afterShapeAs3D = [webgl_util.getBatchDim(afterShape)].concat(_toConsumableArray(webgl_util.getRowsCols(afterShape)));\n      var program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n      var preventEagerUnpackingOfOutput = true;\n      var customValues = [input3DShape];\n      var output = this.runWebGLProgram(program, [input3D], input.dtype, customValues, preventEagerUnpackingOfOutput);\n      return {\n        dataId: output.dataId,\n        shape: afterShape,\n        dtype: output.dtype\n      };\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(dataId, customTexShape) {\n      var texData = this.texData.get(dataId);\n      var isPacked = texData.isPacked,\n        shape = texData.shape,\n        dtype = texData.dtype;\n      if (customTexShape != null) {\n        var size = util.sizeFromShape(shape);\n        var texSize = customTexShape[0] * customTexShape[1] * 4;\n        util.assert(size <= texSize, function () {\n          return 'customTexShape is too small. ' + 'Row * Column * 4 should be equal or larger than the ' + 'size of the tensor data.';\n        });\n      }\n      var shapeAs3D = webgl_util.getShapeAs3D(shape);\n      var program;\n      if (isPacked) {\n        program = new DecodeMatrixPackedProgram(shapeAs3D);\n      } else {\n        program = new DecodeMatrixProgram(shapeAs3D);\n      }\n      var preventEagerUnpackingOfOutput = true;\n      var customValues = [customTexShape != null ? customTexShape : tex_util.getDenseTexShape(shapeAs3D)];\n      var out = this.runWebGLProgram(program, [{\n        shape: shapeAs3D,\n        dtype: dtype,\n        dataId: dataId\n      }], dtype, customValues, preventEagerUnpackingOfOutput, customTexShape);\n      return {\n        dtype: dtype,\n        shape: shape,\n        dataId: out.dataId\n      };\n    }\n  }, {\n    key: \"runWebGLProgram\",\n    value: function runWebGLProgram(program, inputs, outputDtype, customUniformValues) {\n      var _this4 = this;\n      var preventEagerUnpackingOfOutput = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var customTexShape = arguments.length > 5 ? arguments[5] : undefined;\n      var output = this.makeTensorInfo(program.outputShape, outputDtype);\n      var outData = this.texData.get(output.dataId);\n      if (program.packedOutput) {\n        outData.isPacked = true;\n      }\n      if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {\n        var texelShape = customTexShape != null ? customTexShape : tex_util.getDenseTexShape(program.outputShape);\n        // For a densely packed output, we explicitly set texShape\n        // so it doesn't get assigned later according to our typical packing\n        // scheme wherein a single texel can only contain values from adjacent\n        // rows/cols.\n        outData.texShape = texelShape.map(function (d) {\n          return d * 2;\n        });\n      }\n      if (program.outTexUsage != null) {\n        outData.usage = program.outTexUsage;\n      }\n      if (util.sizeFromShape(output.shape) === 0) {\n        // Short-circuit the computation since the result is empty (has 0 in its\n        // shape).\n        outData.values = util.getTypedArrayFromDType(output.dtype, 0);\n        return output;\n      }\n      var dataToDispose = [];\n      var inputsData = inputs.map(function (input) {\n        if (input.dtype === 'complex64') {\n          throw new Error(\"GPGPUProgram does not support complex64 input. For complex64 \" + \"dtypes, please separate the program into real and imaginary \" + \"parts.\");\n        }\n        var texData = _this4.texData.get(input.dataId);\n        if (texData.texture == null) {\n          if (!program.packedInputs && util.sizeFromShape(input.shape) <= env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n            // Upload small tensors that live on the CPU as uniforms, not as\n            // textures. Do this only when the environment supports 32bit floats\n            // due to problems when comparing 16bit floats with 32bit floats.\n            // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n            // possible for packed shaders to sample from uniforms.\n            return {\n              shape: input.shape,\n              texData: null,\n              isUniform: true,\n              uniformValues: texData.values\n            };\n          }\n          // This ensures that if a packed program's inputs have not yet been\n          // uploaded to the GPU, they get uploaded as packed right off the bat.\n          if (program.packedInputs) {\n            texData.isPacked = true;\n            texData.shape = input.shape;\n          }\n        }\n        _this4.uploadToGPU(input.dataId);\n        if (!!texData.isPacked !== !!program.packedInputs) {\n          input = texData.isPacked ? _this4.unpackTensor(input) : _this4.packTensor(input);\n          dataToDispose.push(input);\n          texData = _this4.texData.get(input.dataId);\n        } else if (texData.isPacked && !webgl_util.isReshapeFree(texData.shape, input.shape)) {\n          // This is a special case where a texture exists for a tensor\n          // but the shapes are incompatible (due to packing constraints) because\n          // the tensor did not have a chance to go through the packed reshape\n          // shader. This only happens when we reshape the *same* tensor to form\n          // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n          // case will disappear once packed uploading is the default.\n          var savedInput = input;\n          var targetShape = input.shape;\n          input.shape = texData.shape;\n          input = _this4.packedReshape(input, targetShape);\n          dataToDispose.push(input);\n          texData = _this4.texData.get(input.dataId);\n          savedInput.shape = targetShape;\n        }\n        return {\n          shape: input.shape,\n          texData: texData,\n          isUniform: false\n        };\n      });\n      this.uploadToGPU(output.dataId);\n      var outputData = {\n        shape: output.shape,\n        texData: outData,\n        isUniform: false\n      };\n      var key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n      var binary = this.getAndSaveBinary(key, function () {\n        return gpgpu_math.compileProgram(_this4.gpgpu, program, inputsData, outputData);\n      });\n      var shouldTimeProgram = this.activeTimers != null;\n      var query;\n      if (shouldTimeProgram) {\n        query = this.startTimer();\n      }\n      if (!env().get('ENGINE_COMPILE_ONLY')) {\n        gpgpu_math.runProgram(this.gpgpu, binary, inputsData, outputData, customUniformValues);\n      }\n      dataToDispose.forEach(function (info) {\n        return _this4.disposeIntermediateTensorInfo(info);\n      });\n      if (shouldTimeProgram) {\n        query = this.endTimer(query);\n        this.activeTimers.push({\n          name: program.constructor.name,\n          query: this.getQueryTime(query)\n        });\n      }\n      var glFlushThreshold = env().get('WEBGL_FLUSH_THRESHOLD');\n      // Manually GL flush requested\n      if (glFlushThreshold > 0) {\n        var time = util.now();\n        if (time - this.lastGlFlushTime > glFlushThreshold) {\n          this.gpgpu.gl.flush();\n          this.lastGlFlushTime = time;\n        }\n      }\n      if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked && preventEagerUnpackingOfOutput === false) {\n        var unpacked = this.unpackTensor(output);\n        this.disposeIntermediateTensorInfo(output);\n        return unpacked;\n      }\n      return output;\n    }\n  }, {\n    key: \"compileAndRun\",\n    value: function compileAndRun(program, inputs, outputDtype, customUniformValues) {\n      var preventEagerUnpackingOfOutput = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      outputDtype = outputDtype || inputs[0].dtype;\n      var outInfo = this.runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput);\n      return outInfo;\n    }\n  }, {\n    key: \"getAndSaveBinary\",\n    value: function getAndSaveBinary(key, getBinary) {\n      if (!(key in this.binaryCache)) {\n        this.binaryCache[key] = getBinary();\n      }\n      return this.binaryCache[key];\n    }\n  }, {\n    key: \"getTextureManager\",\n    value: function getTextureManager() {\n      return this.textureManager;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this5 = this;\n      if (this.disposed) {\n        return;\n      }\n      // Avoid disposing the compiled webgl programs during unit testing because\n      // it slows down test execution.\n      if (!env().getBool('IS_TEST')) {\n        var allKeys = Object.keys(this.binaryCache);\n        allKeys.forEach(function (key) {\n          _this5.gpgpu.deleteProgram(_this5.binaryCache[key].webGLProgram);\n          delete _this5.binaryCache[key];\n        });\n      }\n      this.textureManager.dispose();\n      if (this.canvas != null && typeof HTMLCanvasElement !== 'undefined' && this.canvas instanceof HTMLCanvasElement) {\n        this.canvas.remove();\n      } else {\n        this.canvas = null;\n      }\n      if (this.gpgpuCreatedLocally) {\n        this.gpgpu.program = null;\n        this.gpgpu.dispose();\n      }\n      this.disposed = true;\n    }\n  }, {\n    key: \"floatPrecision\",\n    value: function floatPrecision() {\n      var _this6 = this;\n      if (this.floatPrecisionValue == null) {\n        this.floatPrecisionValue = tidy(function () {\n          if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n            // Momentarily switching DEBUG flag to false so we don't throw an\n            // error trying to upload a small value.\n            var debugFlag = env().getBool('DEBUG');\n            env().set('DEBUG', false);\n            var underflowCheckValue = _this6.abs(scalar(1e-8)).dataSync()[0];\n            env().set('DEBUG', debugFlag);\n            if (underflowCheckValue > 0) {\n              return 32;\n            }\n          }\n          return 16;\n        });\n      }\n      return this.floatPrecisionValue;\n    }\n    /** Returns the smallest representable number.  */\n  }, {\n    key: \"epsilon\",\n    value: function epsilon() {\n      return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n    }\n  }, {\n    key: \"uploadToGPU\",\n    value: function uploadToGPU(dataId) {\n      var texData = this.texData.get(dataId);\n      var shape = texData.shape,\n        dtype = texData.dtype,\n        values = texData.values,\n        texture = texData.texture,\n        usage = texData.usage,\n        isPacked = texData.isPacked;\n      if (texture != null) {\n        // Array is already on GPU. No-op.\n        return;\n      }\n      var shouldTimeProgram = this.activeTimers != null;\n      var start;\n      if (shouldTimeProgram) {\n        start = util.now();\n      }\n      var texShape = texData.texShape;\n      if (texShape == null) {\n        // This texShape may not be the final texture shape. For packed or dense\n        // textures, the texShape will be changed when textures are created.\n        texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);\n        texData.texShape = texShape;\n      }\n      if (values != null) {\n        var shapeAs3D = webgl_util.getShapeAs3D(shape);\n        var program;\n        var width = texShape[1],\n          height = texShape[0];\n        var isByteArray = values instanceof Uint8Array || values instanceof Uint8ClampedArray;\n        // texture for float array is PhysicalTextureType.PACKED_2X2_FLOAT32, we\n        // need to make sure the upload uses the same packed size\n        if (isPacked || !isByteArray) {\n          var _tex_util$getPackedMa = tex_util.getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);\n          var _tex_util$getPackedMa2 = _slicedToArray(_tex_util$getPackedMa, 2);\n          width = _tex_util$getPackedMa2[0];\n          height = _tex_util$getPackedMa2[1];\n        }\n        if (isPacked) {\n          program = new EncodeMatrixPackedProgram(shapeAs3D, isByteArray);\n        } else {\n          program = new EncodeMatrixProgram(shapeAs3D, isByteArray);\n        }\n        // TexShape for float array needs to be the original shape, which byte\n        // array needs to be packed size. This allow the data upload shape to be\n        // matched with texture creation logic.\n        var tempDenseInputTexShape = isByteArray ? [height, width] : texShape;\n        var tempDenseInputHandle = this.makeTensorInfo(tempDenseInputTexShape, dtype);\n        var tempDenseInputTexData = this.texData.get(tempDenseInputHandle.dataId);\n        if (isByteArray) {\n          tempDenseInputTexData.usage = TextureUsage.PIXELS;\n        } else {\n          tempDenseInputTexData.usage = TextureUsage.UPLOAD;\n        }\n        tempDenseInputTexData.texShape = tempDenseInputTexShape;\n        this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);\n        var customValues = [[height, width]];\n        // We want the output to remain packed regardless of the value of\n        // WEBGL_PACK.\n        var preventEagerUnpacking = true;\n        var encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, customValues, preventEagerUnpacking);\n        // Have the original texture assume the identity of the encoded output.\n        var outputTexData = this.texData.get(encodedOutputTarget.dataId);\n        texData.texShape = outputTexData.texShape;\n        texData.isPacked = outputTexData.isPacked;\n        texData.usage = outputTexData.usage;\n        if (!env().get('ENGINE_COMPILE_ONLY')) {\n          texData.texture = outputTexData.texture;\n          // Once uploaded, don't store the values on cpu.\n          texData.values = null;\n          this.texData.delete(encodedOutputTarget.dataId);\n        } else {\n          this.disposeData(encodedOutputTarget.dataId);\n        }\n        this.disposeIntermediateTensorInfo(tempDenseInputHandle);\n        if (shouldTimeProgram) {\n          this.uploadWaitMs += util.now() - start;\n        }\n      } else {\n        var newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n        texData.texture = newTexture;\n      }\n    }\n  }, {\n    key: \"convertAndCacheOnCPU\",\n    value: function convertAndCacheOnCPU(dataId, float32Values) {\n      var texData = this.texData.get(dataId);\n      var dtype = texData.dtype;\n      if (float32Values != null) {\n        texData.values = float32ToTypedArray(float32Values, dtype);\n      }\n      return texData.values;\n    }\n  }, {\n    key: \"acquireTexture\",\n    value: function acquireTexture(texShape, texType, dtype, isPacked) {\n      this.numBytesInGPU += this.computeBytes(texShape, dtype);\n      if (!this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n        var mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n        this.warnedAboutMemory = true;\n        console.warn(\"High memory usage in GPU: \".concat(mb, \" MB, \") + \"most likely due to a memory leak\");\n      }\n      return this.textureManager.acquireTexture(texShape, texType, isPacked);\n    }\n  }, {\n    key: \"computeBytes\",\n    value: function computeBytes(shape, dtype) {\n      return shape[0] * shape[1] * util.bytesPerElement(dtype);\n    }\n  }, {\n    key: \"checkCompileCompletion\",\n    value: function checkCompileCompletion() {\n      for (var _i = 0, _Object$entries = Object.entries(this.binaryCache); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          binary = _Object$entries$_i[1];\n        this.checkCompletion_(binary);\n      }\n    }\n  }, {\n    key: \"checkCompileCompletionAsync\",\n    value: function () {\n      var _checkCompileCompletionAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this7 = this;\n        var ps, _i2, _Object$entries2, _Object$entries2$_i, binary, _loop, _i3, _Object$entries3;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              ps = [];\n              if (!this.gpgpu.parallelCompilationExtension) {\n                _context5.next = 6;\n                break;\n              }\n              for (_i2 = 0, _Object$entries2 = Object.entries(this.binaryCache); _i2 < _Object$entries2.length; _i2++) {\n                _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2), binary = _Object$entries2$_i[1];\n                ps.push(this.checkCompletionAsync_(binary));\n              }\n              return _context5.abrupt(\"return\", Promise.all(ps));\n            case 6:\n              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                var _Object$entries3$_i, binary, p;\n                return _regeneratorRuntime().wrap(function _loop$(_context4) {\n                  while (1) switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2), binary = _Object$entries3$_i[1];\n                      p = new Promise(function (resolve) {\n                        try {\n                          _this7.checkCompletion_(binary);\n                          resolve(true);\n                        } catch (error) {\n                          throw error;\n                        }\n                      });\n                      ps.push(p);\n                    case 3:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }, _loop);\n              });\n              _i3 = 0, _Object$entries3 = Object.entries(this.binaryCache);\n            case 8:\n              if (!(_i3 < _Object$entries3.length)) {\n                _context5.next = 13;\n                break;\n              }\n              return _context5.delegateYield(_loop(), \"t0\", 10);\n            case 10:\n              _i3++;\n              _context5.next = 8;\n              break;\n            case 13:\n              return _context5.abrupt(\"return\", Promise.all(ps));\n            case 14:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee4, this);\n      }));\n      function checkCompileCompletionAsync() {\n        return _checkCompileCompletionAsync.apply(this, arguments);\n      }\n      return checkCompileCompletionAsync;\n    }()\n  }, {\n    key: \"checkCompletionAsync_\",\n    value: function () {\n      var _checkCompletionAsync_ = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(binary) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) {\n                _context6.next = 4;\n                break;\n              }\n              return _context6.abrupt(\"return\", this.checkCompletion_(binary));\n            case 4:\n              _context6.next = 6;\n              return nextFrame();\n            case 6:\n              return _context6.abrupt(\"return\", this.checkCompletionAsync_(binary));\n            case 7:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee5, this);\n      }));\n      function checkCompletionAsync_(_x3) {\n        return _checkCompletionAsync_.apply(this, arguments);\n      }\n      return checkCompletionAsync_;\n    }()\n  }, {\n    key: \"checkCompletion_\",\n    value: function checkCompletion_(binary) {\n      if (this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) {\n        console.log(this.gpgpu.gl.getProgramInfoLog(binary.webGLProgram));\n        if (this.gpgpu.gl.getShaderParameter(binary.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false) {\n          webgl_util.logShaderSourceAndInfoLog(binary.source, this.gpgpu.gl.getShaderInfoLog(binary.fragmentShader));\n          throw new Error('Failed to compile fragment shader.');\n        }\n        throw new Error('Failed to link vertex and fragment shaders.');\n      }\n      return true;\n    }\n  }, {\n    key: \"getUniformLocations\",\n    value: function getUniformLocations() {\n      for (var _i4 = 0, _Object$entries4 = Object.entries(this.binaryCache); _i4 < _Object$entries4.length; _i4++) {\n        var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i4], 2),\n          binary = _Object$entries4$_i[1];\n        var _getUniformLocations2 = _getUniformLocations(this.gpgpu, binary.program, binary.webGLProgram),\n          uniformLocations = _getUniformLocations2.uniformLocations,\n          customUniformLocations = _getUniformLocations2.customUniformLocations,\n          infLoc = _getUniformLocations2.infLoc,\n          nanLoc = _getUniformLocations2.nanLoc,\n          inShapesLocations = _getUniformLocations2.inShapesLocations,\n          inTexShapesLocations = _getUniformLocations2.inTexShapesLocations,\n          outShapeLocation = _getUniformLocations2.outShapeLocation,\n          outShapeStridesLocation = _getUniformLocations2.outShapeStridesLocation,\n          outTexShapeLocation = _getUniformLocations2.outTexShapeLocation;\n        binary.uniformLocations = uniformLocations;\n        binary.customUniformLocations = customUniformLocations;\n        binary.infLoc = infLoc;\n        binary.nanLoc = nanLoc;\n        binary.inShapesLocations = inShapesLocations;\n        binary.inTexShapesLocations = inTexShapesLocations;\n        binary.outShapeLocation = outShapeLocation;\n        binary.outShapeStridesLocation = outShapeStridesLocation;\n        binary.outTexShapeLocation = outTexShapeLocation;\n      }\n    }\n    /**\n     * Create a TF.js tensor out of an existing WebGL texture. A new texture will\n     * be created.\n     */\n  }, {\n    key: \"createTensorFromGPUData\",\n    value: function createTensorFromGPUData(values, shape, dtype) {\n      values.channels = values.channels || 'RGBA';\n      var texture = values.texture,\n        height = values.height,\n        width = values.width,\n        channels = values.channels;\n      var backend = engine().backend;\n      // Have to throw an error, otherwise WebGL just warns and returns wrong\n      // values.\n      if (!backend.gpgpu.gl.isTexture(texture)) {\n        throw new Error(\"The texture is invalid. Also, please make sure the texture and \" + \"the TFJS WebGL backend are using the same canvas. If you want to \" + \"use your own custom canvas, you have to create and use the custom \" + \"TFJS WebGL backend created from the canvas through \" + \"'new tf.MathBackendWebGL(customCanvas)'.\");\n      }\n      var dataId = backend.writeTexture(texture, shape, dtype, height, width, channels);\n      return engine().makeTensorFromDataId(dataId, shape, dtype, backend);\n    }\n  }]);\n  return MathBackendWebGL;\n}(KernelBackend);\nMathBackendWebGL.nextDataId = 0;\nfunction float32ToTypedArray(a, dtype) {\n  if (dtype === 'float32' || dtype === 'complex64') {\n    return a;\n  } else if (dtype === 'int32' || dtype === 'bool') {\n    var result = dtype === 'int32' ? new Int32Array(a.length) : new Uint8Array(a.length);\n    for (var i = 0; i < result.length; ++i) {\n      result[i] = Math.round(a[i]);\n    }\n    return result;\n  } else {\n    throw new Error(\"Unknown dtype \".concat(dtype));\n  }\n}","map":{"version":3,"mappings":";;;;;;;;;AAAA;;;;;;;;;;;;;;;;AAiBA;AACA,OAAO,eAAe;AAGtB,SAAQA,YAAY,EAAiBC,MAAM,EAAUC,WAAW,EAAkCC,MAAM,EAAEC,GAAG,EAAWC,YAAY,EAAEC,aAAa,EAAcC,SAAS,EAAyCC,MAAM,EAAwDC,IAAI,EAA0BC,IAAI,QAAkB,uBAAuB;AAC5V,SAAQC,eAAe,QAAO,eAAe;AAC7C,SAAQC,mBAAmB,QAAO,qBAAqB;AACvD,SAAQC,yBAAyB,QAAO,4BAA4B;AACpE,SAAQC,kBAAkB,QAAO,oBAAoB;AACrD,SAAQC,wBAAwB,QAAO,2BAA2B;AAClE,SAAQC,mBAAmB,QAAO,qBAAqB;AACvD,SAAQC,yBAAyB,QAAO,4BAA4B;AACpE,SAAQC,YAAY,QAAO,iBAAiB;AAC5C,OAAO,KAAKC,UAAU,MAAM,cAAc;AAC1C,SAAQC,mBAAmB,IAAnBA,oBAAmB,QAA8C,cAAc;AACvF,SAAQC,gBAAgB,QAAO,uBAAuB;AACtD,SAAQC,WAAW,QAAO,YAAY;AACtC,SAAQC,oBAAoB,QAAO,sBAAsB;AACzD,OAAO,KAAKC,QAAQ,MAAM,YAAY;AACtC,SAA8BC,YAAY,QAAO,YAAY;AAC7D,SAAQC,cAAc,QAAO,mBAAmB;AAChD,OAAO,KAAKC,QAAQ,MAAM,eAAe;AACzC,SAAQC,cAAc,QAAO,eAAe;AAC5C,SAAQC,oBAAoB,QAAO,sBAAsB;AACzD,SAAQC,aAAa,QAAO,cAAc;AAC1C,OAAO,KAAKC,UAAU,MAAM,cAAc;AAE1C,IAAMC,SAAS,GAAG3B,YAAY,CAAC2B,SAAS;AAExC,OAAO,IAAMC,eAAe,GAAG,IAAI;AACnC,OAAO,IAAMC,eAAe,GAAG,IAAI;AA4BnC,IAAMC,YAAY,GAA2D,EAAE;AAE/E,OAAM,SAAUC,cAAc,CAACC,YAAoB;EACjD,IAAIA,YAAY,IAAIF,YAAY,EAAE;IAChC,OAAOA,YAAY,CAACE,YAAY,CAAC;;EAEnCF,YAAY,CAACE,YAAY,CAAC,GAAG,EAAE;EAC/B,OAAOF,YAAY,CAACE,YAAY,CAAC;AACnC;AAEA;AACA;AACA,IAAMC,0BAA0B,GAC5BlC,GAAG,EAAE,CAACmC,SAAS,CAAC,4BAA4B,CAAC;AAEjD;AACA;AACA;AACA,IAAMC,sBAAsB,GAAG,GAAG;AAClC,SAASC,kBAAkB;EACzB,IAAIrC,GAAG,EAAE,CAACsC,MAAM,CAACC,MAAM,IAAI,IAAI,EAAE;IAC/B,OAAO,IAAI,CAAC,CAAE;;;EAEhB,OAAQvC,GAAG,EAAE,CAACsC,MAAM,CAACC,MAAM,CAACC,MAAM,GAAGxC,GAAG,EAAE,CAACsC,MAAM,CAACC,MAAM,CAACE,KAAK,GACtDC,MAAM,CAACC,gBAAgB,GAC3BP,sBAAsB,GAAG,IAAI,GAAG,IAAI;AAC1C;AAEA,WAAaQ,gBAAiB;EAAA;EAAA;EAwC5B,0BAAYC,WAA4D;IAAA;IAAA;IACtE;IAjCF;IACQ,iBAAW,GAAG,IAAIC,OAAO,EAA4C;IAC7E;IACA;IACQ,qBAAe,GAAG,IAAIC,OAAO,EAAU;IAE/C;IACA;IACA,kBAAY,GAAG,IAAID,OAAO,EAAkB;IACpC,mBAAa,GAAG,CAAC;IAMzB;IACQ,kBAAY,GAAG,CAAC;IACxB;IACQ,oBAAc,GAAG,CAAC;IAE1B;IACQ,qBAAe,GAAG,CAAC;IASnB,uBAAiB,GAAG,KAAK;IAkfzB,oBAAc,GAAG,CAAC;IAgZlB,cAAQ,GAAG,KAAK;IA93BtB,IAAI,CAAC9C,GAAG,EAAE,CAACgD,OAAO,CAAC,WAAW,CAAC,EAAE;MAC/B,MAAM,IAAIC,KAAK,CAAC,uCAAuC,CAAC;;IAG1D,IAAIC,QAAQ;IACZ,IAAIL,WAAW,IAAI,IAAI,EAAE;MACvB,IAAIA,WAAW,YAAY/B,YAAY,EAAE;QACvCoC,QAAQ,GAAGL,WAAW;OACvB,MAAM;QACL,IAAMM,EAAE,GACJ5C,eAAe,CAACP,GAAG,EAAE,CAACmC,SAAS,CAAC,eAAe,CAAC,EAAEU,WAAW,CAAC;QAClEK,QAAQ,GAAG,IAAIpC,YAAY,CAACqC,EAAE,CAAC;;MAEjC,MAAKC,WAAW,GAAG,EAAE;MACrB,MAAKC,mBAAmB,GAAG,KAAK;KACjC,MAAM;MACL,IAAMF,GAAE,GAAG5C,eAAe,CAACP,GAAG,EAAE,CAACmC,SAAS,CAAC,eAAe,CAAC,CAAC;MAC5De,QAAQ,GAAG,IAAIpC,YAAY,CAACqC,GAAE,CAAC;MAC/B,MAAKC,WAAW,GAAGpB,cAAc,CAAChC,GAAG,EAAE,CAACmC,SAAS,CAAC,eAAe,CAAC,CAAC;MACnE,MAAKkB,mBAAmB,GAAG,IAAI;;IAGjC,MAAKC,KAAK,GAAGJ,QAAQ;IACrB,MAAKK,MAAM,GAAG,MAAKD,KAAK,CAACH,EAAE,CAACI,MAAM;IAClC,MAAKC,cAAc,GAAG,IAAIlC,cAAc,CAAC,MAAKgC,KAAK,CAAC;IACpD,MAAKjB,kBAAkB,GAAGA,kBAAkB,EAAE;IAC9C,MAAKoB,OAAO,GAAG,IAAI3D,WAAW,gCAAOC,MAAM,EAAE,CAAC;IAAC;EACjD;EAAC;IAAA;IAAA,OAhEO,sBAAU;MAChB,OAAO6C,gBAAgB,CAACc,UAAU,EAAE;IACtC;EAAC;IAAA;IAAA,OAgEQ,sBAAU;MACjB,OAAO,IAAI,CAACD,OAAO,CAACE,UAAU,EAAE,GAAG,IAAI,CAACC,cAAc;IACxD;IAEA;IACA;EAAA;IAAA;IAAA,OACA,sBACIC,OAAqB,EAAEC,KAAe,EAAEC,KAAe,EACvDC,SAAiB,EAAEC,QAAgB,EAAEC,QAAgB;MACvD;MACA;MACA,IAAMC,KAAK,GAAG,IAAI,CAACC,cAAc,CAACN,KAAK,EAAEC,KAAK,CAAC;MAC/C,IAAMM,MAAM,GAAG,IAAI,CAACZ,OAAO,CAACa,GAAG,CAACH,KAAK,CAACI,MAAM,CAAC;MAC7C;MACA;MACAF,MAAM,CAACG,QAAQ,GAAG,KAAK;MAEvB;MACAH,MAAM,CAACR,OAAO,GAAG;QAACA,OAAO,EAAPA,OAAO;QAAEY,QAAQ,EAAE,CAACT,SAAS,EAAEC,QAAQ;MAAC,CAAC;MAC3DI,MAAM,CAACI,QAAQ,GAAG,CAACT,SAAS,EAAEC,QAAQ,CAAC;MAEvC,IAAMS,SAAS,GAAG/C,UAAU,CAACgD,YAAY,CAACb,KAAK,CAAC;MAChD,IAAMc,OAAO,GACT,IAAIhE,mBAAmB,CAAC8D,SAAS,EAAE,KAAK,CAAC,mBAAmBR,QAAQ,CAAC;MACzE,IAAMW,MAAM,GACR,IAAI,CAACC,eAAe,CAACF,OAAO,EAAE,CAACT,KAAK,CAAC,EAAEJ,KAAK,EAAE,CAAC,CAACC,SAAS,EAAEC,QAAQ,CAAC,CAAC,CAAC;MAC1EY,MAAM,CAACf,KAAK,GAAGA,KAAK;MAEpB;MACA;MACAO,MAAM,CAACR,OAAO,GAAG,IAAI;MACrB,IAAI,CAACkB,6BAA6B,CAACZ,KAAK,CAAC;MAEzC,OAAOU,MAAM,CAACN,MAAM;IACtB;EAAC;IAAA;IAAA,OAEQ,eAAMS,MAAqB,EAAElB,KAAe,EAAEC,KAAe;MAEpE,IAAI/D,GAAG,EAAE,CAACgD,OAAO,CAAC,gCAAgC,CAAC,IAC/ChD,GAAG,EAAE,CAACgD,OAAO,CAAC,OAAO,CAAC,EAAE;QAC1B,IAAI,CAACiC,sBAAsB,CAACD,MAAM,CAAC;;MAErC,IAAIjB,KAAK,KAAK,WAAW,IAAIiB,MAAM,IAAI,IAAI,EAAE;QAC3C,MAAM,IAAI/B,KAAK,CACX,4EACoC,CAAC;;MAE3C,IAAMsB,MAAM,GAAG;QAACW,EAAE,EAAE,IAAI,CAACxB,UAAU;MAAE,CAAC;MACtC,IAAI,CAACD,OAAO,CAAC0B,GAAG,CACZZ,MAAM,EACN;QAACT,KAAK,EAALA,KAAK;QAAEC,KAAK,EAALA,KAAK;QAAEiB,MAAM,EAANA,MAAM;QAAEI,KAAK,EAAE/D,YAAY,CAACgE,MAAM;QAAEC,QAAQ,EAAE;MAAC,CAAC,CAAC;MACpE,OAAOf,MAAM;IACf;IAEA;EAAA;IAAA;IAAA,OACS,kBAASA,MAAc;MAC9B,IAAI,IAAI,CAACd,OAAO,CAAC8B,GAAG,CAAChB,MAAM,CAAC,EAAE;QAC5B,IAAMiB,UAAU,GAAG,IAAI,CAAC/B,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;QAC3C,OAAOiB,UAAU,CAACF,QAAQ;;MAE5B,OAAO,CAAC;IACV;IAEA;EAAA;IAAA;IAAA,OACS,gBAAOf,MAAc;MAC5B,IAAMd,OAAO,GAAG,IAAI,CAACA,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;MACxCd,OAAO,CAAC6B,QAAQ,EAAE;IACpB;IAEA;EAAA;IAAA;IAAA,OACA,gBAAOf,MAAc;MACnB,IAAI,IAAI,CAACd,OAAO,CAAC8B,GAAG,CAAChB,MAAM,CAAC,EAAE;QAC5B,IAAMd,OAAO,GAAG,IAAI,CAACA,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;QACxCd,OAAO,CAAC6B,QAAQ,EAAE;;IAEtB;EAAC;IAAA;IAAA,OAEQ,cACLf,MAAc,EAAES,MAAqB,EAAElB,KAAe,EAAEC,KAAe,EACvEuB,QAAgB;MAClB,IAAItF,GAAG,EAAE,CAACgD,OAAO,CAAC,OAAO,CAAC,EAAE;QAC1B,IAAI,CAACiC,sBAAsB,CAACD,MAAM,CAAC;;MAErC,IAAIjB,KAAK,KAAK,WAAW,EAAE;QACzB,MAAM,IAAId,KAAK,CACX,4EACoC,CAAC;;MAE3C,IAAI,CAACQ,OAAO,CAAC0B,GAAG,CACZZ,MAAM,EAAE;QAACT,KAAK,EAALA,KAAK;QAAEC,KAAK,EAALA,KAAK;QAAEiB,MAAM,EAANA,MAAM;QAAEI,KAAK,EAAE/D,YAAY,CAACgE,MAAM;QAAEC,QAAQ,EAARA;MAAQ,CAAC,CAAC;IAC3E;EAAC;IAAA;IAAA,OAED,uCAA8BG,UAAsB;MAClD,IAAI,CAACC,WAAW,CAACD,UAAU,CAAClB,MAAM,CAAC;IACrC;EAAC;IAAA;IAAA,OAEQ,kBAASA,MAAc;MAC9B,IAAMd,OAAO,GAAG,IAAI,CAACA,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;MACxC,IAAOS,MAAM,GAAuDvB,OAAO,CAApEuB,MAAM;QAAEjB,KAAK,GAAgDN,OAAO,CAA5DM,KAAK;QAAE4B,kBAAkB,GAA4BlC,OAAO,CAArDkC,kBAAkB;QAAEC,KAAK,GAAqBnC,OAAO,CAAjCmC,KAAK;QAAE9B,KAAK,GAAcL,OAAO,CAA1BK,KAAK;QAAEU,QAAQ,GAAIf,OAAO,CAAnBe,QAAQ;MAEhE;MACA;MACA;MACA,IAAIoB,KAAK,IAAI,IAAI,EAAE;QACjB,IAAIhB,OAAO;QACX,IAAIJ,QAAQ,EAAE;UACZI,OAAO,GAAG,IAAInD,oBAAoB,CAACqC,KAAK,EAAEvC,QAAQ,CAACsE,KAAK,CAAC;SAC1D,MAAM;UACLjB,OAAO,GAAG,IAAIpD,cAAc,CAACsC,KAAK,EAAEvC,QAAQ,CAACsE,KAAK,CAAC;;QAErD,IAAMC,GAAG,GACL,IAAI,CAAChB,eAAe,CAACF,OAAO,EAAE,CAAC;UAACL,MAAM,EAANA,MAAM;UAAET,KAAK,EAALA,KAAK;UAAEC,KAAK,EAALA;QAAK,CAAC,CAAC,EAAEA,KAAK,CAAC;QAClE,IAAMgC,IAAI,GAAG,IAAI,CAACC,QAAQ,CAACF,GAAG,CAACvB,MAAM,CAAC;QACtC,IAAI,CAACQ,6BAA6B,CAACe,GAAG,CAAC;QACvC,OAAOC,IAAI;;MAEb,IAAIf,MAAM,IAAI,IAAI,EAAE;QAClB,OAAO,IAAI,CAACiB,oBAAoB,CAAC1B,MAAM,CAAC;;MAE1C,IAAIR,KAAK,KAAK,QAAQ,EAAE;QACtB,OAAOiB,MAAM;;MAEf,IAAMkB,iBAAiB,GAAG,IAAI,CAACC,YAAY,IAAI,IAAI;MACnD,IAAIC,KAAa;MACjB,IAAIF,iBAAiB,EAAE;QACrBE,KAAK,GAAG9F,IAAI,CAAC+F,GAAG,EAAE;;MAGpB,IAAIC,MAAoB;MACxB,IAAIvC,KAAK,KAAK,WAAW,EAAE;QACzB,IAAMwC,UAAU,GACZ,IAAI,CAACP,QAAQ,CAACL,kBAAkB,CAACa,IAAI,CAACjC,MAAM,CAAiB;QACjE,IAAMkC,UAAU,GACZ,IAAI,CAACT,QAAQ,CAACL,kBAAkB,CAACe,IAAI,CAACnC,MAAM,CAAiB;QACjE+B,MAAM,GAAG1G,YAAY,CAAC+G,sBAAsB,CAACJ,UAAU,EAAEE,UAAU,CAAC;OACrE,MAAM;QACLH,MAAM,GAAG,IAAI,CAACM,oBAAoB,CAACrC,MAAM,CAAC;;MAG5C,IAAI2B,iBAAiB,EAAE;QACrB,IAAI,CAACW,cAAc,IAAIvG,IAAI,CAAC+F,GAAG,EAAE,GAAGD,KAAK;;MAE3C,OAAO,IAAI,CAACH,oBAAoB,CAAC1B,MAAM,EAAE+B,MAAM,CAAC;IAClD;EAAC;IAAA;IAAA;MAAA,uEAEQ,iBAAW/B,MAAc;QAAA;QAAA;UAAA;YAAA;cAAA,KAC5B,IAAI,CAACuC,WAAW,CAACvB,GAAG,CAAChB,MAAM,CAAC;gBAAA;gBAAA;cAAA;cACxBwC,YAAW,GAAG,IAAI,CAACD,WAAW,CAACxC,GAAG,CAACC,MAAM,CAAC;cAAA,iCACzC,IAAIyC,OAAO,CAAa,iBAAO;gBAAA,OAAID,YAAW,CAACE,IAAI,CAACC,OAAO,CAAC;cAAA,EAAC;YAAA;cAEhEzD,OAAO,GAAG,IAAI,CAACA,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;cACjCS,MAAM,GAAuDvB,OAAO,CAApEuB,MAAM,EAAElB,KAAK,GAAgDL,OAAO,CAA5DK,KAAK,EAAE8B,KAAK,GAAyCnC,OAAO,CAArDmC,KAAK,EAAE7B,KAAK,GAAkCN,OAAO,CAA9CM,KAAK,EAAE4B,kBAAkB,GAAclC,OAAO,CAAvCkC,kBAAkB,EAAEnB,QAAQ,GAAIf,OAAO,CAAnBe,QAAQ,EAEhE;cACA;cACA;cAAA,MACIoB,KAAK,IAAI,IAAI;gBAAA;gBAAA;cAAA;cAEf,IAAIpB,QAAQ,EAAE;gBACZI,OAAO,GAAG,IAAInD,oBAAoB,CAACqC,KAAK,EAAEvC,QAAQ,CAACsE,KAAK,CAAC;eAC1D,MAAM;gBACLjB,OAAO,GAAG,IAAIpD,cAAc,CAACsC,KAAK,EAAEvC,QAAQ,CAACsE,KAAK,CAAC;;cAE/CC,GAAG,GACL,IAAI,CAAChB,eAAe,CAACF,OAAO,EAAE,CAAC;gBAACL,MAAM,EAANA,MAAM;gBAAET,KAAK,EAALA,KAAK;gBAAEC,KAAK,EAALA;cAAK,CAAC,CAAC,EAAEA,KAAK,CAAC;cAC5DgC,IAAI,GAAG,IAAI,CAACoB,IAAI,CAACrB,GAAG,CAACvB,MAAM,CAAC;cAClC,IAAI,CAACQ,6BAA6B,CAACe,GAAG,CAAC;cAAC,iCACjCC,IAAI;YAAA;cAAA,MAGTf,MAAM,IAAI,IAAI;gBAAA;gBAAA;cAAA;cAAA,iCACT,IAAI,CAACiB,oBAAoB,CAAC1B,MAAM,CAAC;YAAA;cAAA,KAGtCvE,GAAG,EAAE,CAACgD,OAAO,CAAC,OAAO,CAAC;gBAAA;gBAAA;cAAA;cAAA,MAIpB,CAAChD,GAAG,EAAE,CAACgD,OAAO,CAAC,8BAA8B,CAAC,IAC9ChD,GAAG,EAAE,CAACmC,SAAS,CAAC,eAAe,CAAC,KAAK,CAAC;gBAAA;gBAAA;cAAA;cAAA,MAClC,IAAIc,KAAK,CACX,mGACoC,CAAC;YAAA;cAIzCpD,MAAM,GAAgB,IAAI;cAG9B,IAAIkE,KAAK,KAAK,WAAW,IAAI/D,GAAG,EAAE,CAACsE,GAAG,CAAC,wBAAwB,CAAC,EAAE;gBAChE;gBACA8C,iBAAiB,GAAG,IAAI,CAACC,MAAM,CAAC9C,MAAM,CAAC;gBACjC+C,OAAO,GAAG,IAAI,CAAC7D,OAAO,CAACa,GAAG,CAAC8C,iBAAiB,CAAC7C,MAAM,CAAC;gBAE1D1E,MAAM,GAAG,mBAAI,CAACyD,KAAK,EAACiE,uBAAuB,qBACvCD,OAAO,CAACzD,OAAO,CAACA,OAAO,4BAAKzC,QAAQ,CAACoG,gBAAgB,CAAC1D,KAAK,CAAC,GAAC;;cAGnE,IAAI,CAACgD,WAAW,CAAC3B,GAAG,CAACZ,MAAM,EAAE,EAAE,CAAC;cAAC,MAE7BR,KAAK,KAAK,WAAW;gBAAA;gBAAA;cAAA;cAAA;cAAA,OAEjB,IAAI,CAACT,KAAK,CAACmE,qBAAqB,EAAE;YAAA;cAAA,MAKtC1D,KAAK,KAAK,WAAW;gBAAA;gBAAA;cAAA;cAAA;cAAA,OACNiD,OAAO,CAACU,GAAG,CAAC,CAC3B,IAAI,CAACP,IAAI,CAACxB,kBAAkB,CAACa,IAAI,CAACjC,MAAM,CAAC,EACzC,IAAI,CAAC4C,IAAI,CAACxB,kBAAkB,CAACe,IAAI,CAACnC,MAAM,CAAC,CAC1C,CAAC;YAAA;cAHIoD,EAAE;cAKFpB,UAAU,GAAGoB,EAAE,CAAC,CAAC,CAAC;cAClBlB,UAAU,GAAGkB,EAAE,CAAC,CAAC,CAAC;cACxBC,IAAI,GAAGhI,YAAY,CAAC+G,sBAAsB,CACtCJ,UAA0B,EAAEE,UAA0B,CAAC;cAAC;cAAA;YAAA;cACvD,IAAI5G,MAAM,IAAI,IAAI,EAAE;gBACzB+H,IAAI,GAAG,IAAI,CAAChB,oBAAoB,CAACrC,MAAM,CAAC;eACzC,MAAM;gBACCsD,IAAI,GAAGvH,IAAI,CAACwH,aAAa,CAAChE,KAAK,CAAC;gBACtC8D,IAAI,GAAG,IAAI,CAACtE,KAAK,CAACyE,+BAA+B,CAAClI,MAAM,EAAEgI,IAAI,CAAC;;YAChE;cACD,IAAIT,iBAAiB,IAAI,IAAI,EAAE;gBAC7B,IAAI,CAACrC,6BAA6B,CAACqC,iBAAiB,CAAC;;cAEvD,IAAIvH,MAAM,IAAI,IAAI,EAAE;gBACZsD,EAAE,GAAG,IAAI,CAACG,KAAK,CAACH,EAAE;gBACxBxB,UAAU,CAACqG,YAAY,CAAC7E,EAAE,EAAE;kBAAA,OAAMA,EAAE,CAAC8E,YAAY,CAACpI,MAAM,CAAC;gBAAA,EAAC;;cAEtDqI,SAAS,GAAG,IAAI,CAACjC,oBAAoB,CAAC1B,MAAM,EAAEqD,IAAI,CAAC;cAEnDb,WAAW,GAAG,IAAI,CAACD,WAAW,CAACxC,GAAG,CAACC,MAAM,CAAC;cAChD,IAAI,CAACuC,WAAW,CAACqB,MAAM,CAAC5D,MAAM,CAAC;cAE/B;cACAwC,WAAW,CAACqB,OAAO,CAAC,iBAAO;gBAAA,OAAIlB,OAAO,CAACgB,SAAS,CAAC;cAAA,EAAC;cAClD,IAAI,IAAI,CAACG,eAAe,CAAC9C,GAAG,CAAChB,MAAM,CAAC,EAAE;gBACpC,IAAI,CAAC8D,eAAe,CAACF,MAAM,CAAC5D,MAAM,CAAC;gBACnC,IAAI,IAAI,CAACmB,WAAW,CAACnB,MAAM,CAAC,EAAE;kBAC5BxE,MAAM,EAAE,CAACuI,YAAY,CAAC/D,MAAM,EAAE,IAAI,CAAC;;gBAErC,IAAI,CAACX,cAAc,EAAE;;cACtB,iCACMsE,SAAS;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CACjB;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;EAAA;IAAA;IAAA,OAOS,mBAAU3D,MAAc,EAAoC;MAAA,IAAlCgE,8EAAgC,EAAE;MAEnE,IAAM9E,OAAO,GAAG,IAAI,CAACA,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;MACxC,IAAOS,MAAM,GAA4CvB,OAAO,CAAzDuB,MAAM;QAAElB,KAAK,GAAqCL,OAAO,CAAjDK,KAAK;QAAE8B,KAAK,GAA8BnC,OAAO,CAA1CmC,KAAK;QAAE7B,KAAK,GAAuBN,OAAO,CAAnCM,KAAK;QAAES,QAAQ,GAAaf,OAAO,CAA5Be,QAAQ;QAAEX,OAAO,GAAIJ,OAAO,CAAlBI,OAAO;MAErD,IAAIE,KAAK,KAAK,WAAW,EAAE;QACzB,MAAM,IAAId,KAAK,CAAC,uDAAuD,CAAC;;MAG1E;MACA;MACA;MACA,IAAI2C,KAAK,IAAI,IAAI,EAAE;QACjB,IAAIhB,OAAO;QACX,IAAIJ,QAAQ,EAAE;UACZI,OAAO,GAAG,IAAInD,oBAAoB,CAACqC,KAAK,EAAEvC,QAAQ,CAACsE,KAAK,CAAC;SAC1D,MAAM;UACLjB,OAAO,GAAG,IAAIpD,cAAc,CAACsC,KAAK,EAAEvC,QAAQ,CAACsE,KAAK,CAAC;;QAErD,IAAMC,GAAG,GACL,IAAI,CAAChB,eAAe,CAACF,OAAO,EAAE,CAAC;UAACL,MAAM,EAANA,MAAM;UAAET,KAAK,EAALA,KAAK;UAAEC,KAAK,EAALA;QAAK,CAAC,CAAC,EAAEA,KAAK,CAAC;QAClE,IAAMyE,YAAY,GAAG,IAAI,CAACC,SAAS,CAAC3C,GAAG,EAAEyC,OAAO,CAAC;QACjD,IAAI,CAACxD,6BAA6B,CAACe,GAAG,CAAC;QACvC,OAAO0C,YAAY;;MAGrB,IAAI3E,OAAO,IAAI,IAAI,EAAE;QACnB,IAAImB,MAAM,IAAI,IAAI,EAAE;UAClB,MAAM,IAAI/B,KAAK,CAAC,gCAAgC,CAAC;SAClD,MAAM;UACL,MAAM,IAAIA,KAAK,CAAC,iCAAiC,CAAC;;;MAItD;MACA,IAAMyF,SAAS,GAAG,IAAI,CAACrB,MAAM,CAAC9C,MAAM,EAAEgE,OAAO,CAACI,cAAc,CAAC;MAE7D;MACA,IAAMC,SAAS,GAAG7I,MAAM,EAAE,CAAC8I,wBAAwB,CAACH,SAAS,CAAC;MAE9D,IAAMpB,OAAO,GAAG,IAAI,CAAC7D,OAAO,CAACa,GAAG,CAACoE,SAAS,CAACnE,MAAM,CAAC;MAClD;QAAQqE,SAAS,EAATA;MAAS,GAAKtB,OAAO,CAACzD,OAAO;IACvC;EAAC;IAAA;IAAA,OAED,oBAA+CiF,CAAa;MAE1D,IAAM/C,IAAI,GAAG,IAAI,CAACC,QAAQ,CAAC8C,CAAC,CAACvE,MAAM,CAAC;MACpC,IAAIuE,CAAC,CAAC/E,KAAK,KAAK,QAAQ,EAAE;QACxB,IAAI;UACF;UACA,IAAMgF,OAAO,GAAIhD,IAAqB,CAACiD,GAAG,CAAC,WAAC;YAAA,OAAI1I,IAAI,CAAC2I,YAAY,CAACC,CAAC,CAAC;UAAA,EAAC;UACrE,OAAOrJ,MAAM,CAACiJ,CAAC,CAAChF,KAAoB,EAAEgF,CAAC,CAAC/E,KAAK,EAAEgF,OAAO,CAChC;SACvB,CAAC,WAAM;UACN,MAAM,IAAI9F,KAAK,CAAC,kDAAkD,CAAC;;;MAGvE,OAAOpD,MAAM,CAACiJ,CAAC,CAAChF,KAAoB,EAAEgF,CAAC,CAAC/E,KAAK,EAAEgC,IAAkB,CAC3C;IACxB;EAAC;IAAA;IAAA,OAEO,gCAAuBf,MAAqB;MAClD,IAAIA,MAAM,IAAI,IAAI,EAAE;QAClB;;MAEF,KAAK,IAAImE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnE,MAAM,CAACoE,MAAM,EAAED,CAAC,EAAE,EAAE;QACtC,IAAME,GAAG,GAAGrE,MAAM,CAACmE,CAAC,CAAW;QAC/B,IAAI,CAACxH,UAAU,CAAC2H,gBAAgB,CAACD,GAAG,CAAC,EAAE;UACrC,IAAIrJ,GAAG,EAAE,CAACgD,OAAO,CAAC,8BAA8B,CAAC,EAAE;YACjD,MAAMC,KAAK,CACP,oBAAaoG,GAAG,kGACyC,0DACF,CAAC;;UAE9D,MAAMpG,KAAK,qBAAcoG,GAAG,4CAAyC;;;IAG3E;EAAC;IAAA;IAAA,OAEO,8BAAqB9E,MAAc;MACzC,wBAAiC,IAAI,CAACd,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;QAAlDT,KAAK,qBAALA,KAAK;QAAEC,KAAK,qBAALA,KAAK;QAAES,QAAQ,qBAARA,QAAQ;MAC7B,IAAMqD,IAAI,GAAGvH,IAAI,CAACwH,aAAa,CAAChE,KAAK,CAAC;MACtC,IAAI9D,GAAG,EAAE,CAACgD,OAAO,CAAC,8BAA8B,CAAC,EAAE;QAAA;QACjD,IAAM0F,SAAS,GAAG,IAAI,CAACrB,MAAM,CAAC9C,MAAM,CAAC;QACrC,IAAM+C,QAAO,GAAG,IAAI,CAAC7D,OAAO,CAACa,GAAG,CAACoE,SAAS,CAACnE,MAAM,CAAC;QAClD,IAAMqD,KAAI,GACN,oBAAI,CAACtE,KAAK,EACLiG,+BAA+B,sBAC5BjC,QAAO,CAACzD,OAAO,CAACA,OAAO,4BAAKzC,QAAQ,CAACoG,gBAAgB,CAAC1D,KAAK,CAAC,GAAC,CAChE0F,QAAQ,CAAC,CAAC,EAAE3B,IAAI,CAAC;QAE1B,IAAI,CAAC9C,6BAA6B,CAAC2D,SAAS,CAAC;QAE7C,OAAOd,KAAI;;MAGb,IAAM6B,sBAAsB,GACxBzJ,GAAG,EAAE,CAACgD,OAAO,CAAC,YAAY,CAAC,IAAIwB,QAAQ,KAAK,IAAI;MACpD,IAAMkF,WAAW,GACbD,sBAAsB,GAAG9H,UAAU,CAACgD,YAAY,CAACb,KAAK,CAAC,GAAGA,KAAK;MACnE,IAAMc,OAAO,GAAG6E,sBAAsB,GAClC,IAAI9I,wBAAwB,CAAC+I,WAAuC,CAAC,GACrE,IAAIhJ,kBAAkB,CAACgJ,WAAW,CAAC;MACvC,IAAM7E,MAAM,GAAG,IAAI,CAACC,eAAe,CAC/BF,OAAO,EAAE,CAAC;QAACd,KAAK,EAAE4F,WAAW;QAAE3F,KAAK,EAALA,KAAK;QAAEQ,MAAM,EAANA;MAAM,CAAC,CAAC,EAAE,SAAS,CAAC;MAC9D,IAAM+C,OAAO,GAAG,IAAI,CAAC7D,OAAO,CAACa,GAAG,CAACO,MAAM,CAACN,MAAM,CAAC;MAC/C,IAAMqD,IAAI,GAAG,IAAI,CAACtE,KAAK,CACLqG,+CAA+C,CAC5CrC,OAAO,CAACzD,OAAO,CAACA,OAAO,EAAEyD,OAAO,CAAC7C,QAAQ,CAAC,CAAC,CAAC,EAC5C6C,OAAO,CAAC7C,QAAQ,CAAC,CAAC,CAAC,CAAC,CACvB+E,QAAQ,CAAC,CAAC,EAAE3B,IAAI,CAAC;MACnC,IAAI,CAAC9C,6BAA6B,CAACF,MAAM,CAAC;MAE1C,OAAO+C,IAAI;IACb;EAAC;IAAA;IAAA,OAEQ,0BAAc;MACrB,OAAO5H,GAAG,EAAE,CAACmC,SAAS,CAAC,+CAA+C,CAAC,GAAG,CAAC;IAC7E;EAAC;IAAA;IAAA,OAEQ,cAAKyH,CAAa;MAAA;MACzB,IAAMC,eAAe,GAAG,IAAI,CAAC1D,YAAY;MACzC,IAAM2D,eAAe,GAAgB,EAAE;MAEvC,IAAIC,aAAa,GAAG,KAAK;MACzB,IAAI,IAAI,CAACC,kBAAkB,IAAI,IAAI,EAAE;QACnC,IAAI,CAACA,kBAAkB,GAAGF,eAAe;QACzCC,aAAa,GAAG,IAAI;OACrB,MAAM;QACL,IAAI,CAAC5D,YAAY,CAACc,IAAI,CAAC6C,eAAe,CAAC;;MAEzC,IAAI,CAAC3D,YAAY,GAAG2D,eAAe;MAEnCF,CAAC,EAAE;MAEH;MACA,IAAMK,2BAA2B,GAC7B3J,IAAI,CAAC4J,OAAO,CAAC,IAAI,CAAC/D,YAAY,CAAC6C,GAAG,CAAC,UAACE,CAAa;QAAA,OAAKA,CAAC,CAACiB,KAAK;MAAA,EAAC,CAAC,CAC1DC,MAAM,CAAC,WAAC;QAAA,OAAIlB,CAAC,IAAI,IAAI;MAAA,EAAC;MAC/B,IAAMmB,yBAAyB,GAC3B/J,IAAI,CAAC4J,OAAO,CAAC,IAAI,CAAC/D,YAAY,CAAC6C,GAAG,CAAC,UAACE,CAAa;QAAA,OAAKA,CAAC,CAACoB,IAAI;MAAA,EAAC,CAAC,CACzDF,MAAM,CAAC,WAAC;QAAA,OAAIlB,CAAC,IAAI,IAAI;MAAA,EAAC;MAE/B,IAAI,CAAC/C,YAAY,GAAG0D,eAAe;MAEnC,IAAIE,aAAa,EAAE;QACjB,IAAI,CAACC,kBAAkB,GAAG,IAAI;;MAGhC,IAAMlE,GAAG,GAAoB;QAC3ByE,YAAY,EAAE,IAAI,CAACA,YAAY;QAC/B1D,cAAc,EAAE,IAAI,CAACA,cAAc;QACnC2D,QAAQ,EAAE,IAAI;QACdC,MAAM,EAAE,IAAI,CAAE;OACf;;MAED,OAAO,2DAAC;QAAA;QAAA;UAAA;YAAA;cAAA,MACFzK,GAAG,EAAE,CAACmC,SAAS,CAAC,+CAA+C,CAAC,GAChE,CAAC;gBAAA;gBAAA;cAAA;cAAA;cAAA,OACoB6E,OAAO,CAACU,GAAG,CAACuC,2BAA2B,CAAC;YAAA;cAAzDO,QAAQ;cAEd1E,GAAG,CAAC,UAAU,CAAC,GAAGxF,IAAI,CAACoK,GAAG,CAACF,QAAQ,CAAC;cACpC1E,GAAG,CAAC,qBAAqB,CAAC,GAAG;gBAAA,OACzB0E,QAAQ,CACHxB,GAAG,CAAC,UAACE,CAAC,EAAEC,CAAC;kBAAA,OAAM;oBAACmB,IAAI,EAAED,yBAAyB,CAAClB,CAAC,CAAC;oBAAEwB,EAAE,EAAEzB;kBAAC,CAAC;gBAAA,CAAC,CAAC,CAC5DF,GAAG,CAAC,WAAC;kBAAA,iBAAOE,CAAC,CAACoB,IAAI,eAAKpB,CAAC,CAACyB,EAAE;gBAAA,CAAE,CAAC,CAC9BC,IAAI,CAAC,IAAI,CAAC;cAAA;cAAC;cAAA;YAAA;cAEpB9E,GAAG,CAAC,UAAU,CAAC,GAAG;gBAChB+E,KAAK,EAAE;eACR;YAAC;cAGJ,MAAI,CAACN,YAAY,GAAG,CAAC;cACrB,MAAI,CAAC1D,cAAc,GAAG,CAAC;cAAC,kCACjBf,GAAG;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CACX,IAAG;IACN;EAAC;IAAA;IAAA,OACQ,kBAAM;MACb,OAAO;QACLgF,UAAU,EAAE,KAAK;QACjBC,aAAa,EAAE,IAAI,CAACA,aAAa;QACjCC,sBAAsB,EAAE,IAAI,CAACxH,cAAc,CAACyH,iBAAiB;QAC7DC,iBAAiB,EAAE,IAAI,CAAC1H,cAAc,CAAC2H;OACrB;IACtB;EAAC;IAAA;IAAA,OAEO,sBAAU;MAChB,IAAInL,GAAG,EAAE,CAACmC,SAAS,CAAC,+CAA+C,CAAC,GAAG,CAAC,EAAE;QACxE,OAAO,IAAI,CAACmB,KAAK,CAAC8H,UAAU,EAAE;;MAEhC,OAAO;QAACC,OAAO,EAAE/K,IAAI,CAAC+F,GAAG,EAAE;QAAEiF,KAAK,EAAE;MAAI,CAAC;IAC3C;EAAC;IAAA;IAAA,OAEO,kBAASnB,KAA+B;MAC9C,IAAInK,GAAG,EAAE,CAACmC,SAAS,CAAC,+CAA+C,CAAC,GAAG,CAAC,EAAE;QACxE,IAAI,CAACmB,KAAK,CAACiI,QAAQ,EAAE;QACrB,OAAOpB,KAAK;;MAEbA,KAAuB,CAACmB,KAAK,GAAGhL,IAAI,CAAC+F,GAAG,EAAE;MAC3C,OAAO8D,KAAK;IACd;EAAC;IAAA;IAAA;MAAA,+EAEO,kBAAmBA,KAA+B;QAAA;QAAA;UAAA;YAAA;cAAA,MACpDnK,GAAG,EAAE,CAACmC,SAAS,CAAC,+CAA+C,CAAC,GAAG,CAAC;gBAAA;gBAAA;cAAA;cAAA,kCAC/D,IAAI,CAACmB,KAAK,CAACkI,sBAAsB,CAACrB,KAAmB,CAAC;YAAA;cAEzDsB,UAAU,GAAGtB,KAAsB;cAAA,kCAClCsB,UAAU,CAACH,KAAK,GAAGG,UAAU,CAACJ,OAAO;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CAC7C;MAAA;QAAA;MAAA;MAAA;IAAA;IAID;;;;;;;;;;EAAA;IAAA;IAAA,OAUS,qBAAY9G,MAAc,EAAe;MAAA,IAAbmH,KAAK,uEAAG,KAAK;MAChD,IAAI,IAAI,CAACrD,eAAe,CAAC9C,GAAG,CAAChB,MAAM,CAAC,EAAE;QACpC,OAAO,KAAK;;MAGd;MACA,IAAI,CAAC,IAAI,CAACd,OAAO,CAAC8B,GAAG,CAAChB,MAAM,CAAC,EAAE;QAC7B,OAAO,IAAI;;MAGb;MACA;MACA;MACA,IAAImH,KAAK,EAAE;QACT,IAAI,CAACjI,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC,CAACe,QAAQ,GAAG,CAAC;OACtC,MAAM;QACL,IAAI,CAAC7B,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC,CAACe,QAAQ,EAAE;;MAGrC,IAAI,CAACoG,KAAK,IAAI,IAAI,CAACjI,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC,CAACe,QAAQ,GAAG,CAAC,EAAE;QACnD,OAAO,KAAK;;MAGd,IAAI,IAAI,CAACwB,WAAW,CAACvB,GAAG,CAAChB,MAAM,CAAC,EAAE;QAChC,IAAI,CAAC8D,eAAe,CAACsD,GAAG,CAACpH,MAAM,CAAC;QAChC,IAAI,CAACX,cAAc,EAAE;QACrB,OAAO,KAAK;;MAGd,IAAI,CAACgI,cAAc,CAACrH,MAAM,CAAC;MAC3B,yBAA6B,IAAI,CAACd,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;QAA9CoB,kBAAkB,sBAAlBA,kBAAkB;MACzB,IAAIA,kBAAkB,IAAI,IAAI,EAAE;QAC9B,IAAI,CAACD,WAAW,CAACC,kBAAkB,CAACa,IAAI,CAACjC,MAAM,EAAEmH,KAAK,CAAC;QACvD,IAAI,CAAChG,WAAW,CAACC,kBAAkB,CAACe,IAAI,CAACnC,MAAM,EAAEmH,KAAK,CAAC;;MAGzD,IAAI,CAACjI,OAAO,CAAC0E,MAAM,CAAC5D,MAAM,CAAC;MAE3B,OAAO,IAAI;IACb;EAAC;IAAA;IAAA,OAEO,wBAAeA,MAAc;MACnC,yBACI,IAAI,CAACd,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;QADrBV,OAAO,sBAAPA,OAAO;QAAEE,KAAK,sBAALA,KAAK;QAAEU,QAAQ,sBAARA,QAAQ;QAAEW,KAAK,sBAALA,KAAK;QAAEZ,QAAQ,sBAARA,QAAQ;QAAEoB,KAAK,sBAALA,KAAK;MAEvD,IAAMiG,GAAG,GAAGjG,KAAK,IAAIA,KAAK,CAACkG,UAAU,IAAIvH,MAAM;MAC/C,IAAMe,QAAQ,GAAG,IAAI,CAACyG,YAAY,CAACzH,GAAG,CAACuH,GAAG,CAAC;MAE3C,IAAIvG,QAAQ,GAAG,CAAC,EAAE;QAChB,IAAI,CAACyG,YAAY,CAAC5G,GAAG,CAAC0G,GAAG,EAAEvG,QAAQ,GAAG,CAAC,CAAC;OACzC,MAAM;QACL,IAAI,CAACyG,YAAY,CAAC5D,MAAM,CAAC0D,GAAG,CAAC;QAC7B,IAAIhI,OAAO,IAAI,IAAI,EAAE;UACnB,IAAI,CAACkH,aAAa,IAAI,IAAI,CAACiB,YAAY,CAACvH,QAAQ,EAAEV,KAAK,CAAC;UACxD,IAAI,CAACP,cAAc,CAACyI,cAAc,CAACpI,OAAO,EAAEY,QAAQ,EAAEW,KAAK,EAAEZ,QAAQ,CAAC;;;MAI1E,IAAMf,OAAO,GAAG,IAAI,CAACA,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;MACxCd,OAAO,CAACI,OAAO,GAAG,IAAI;MACtBJ,OAAO,CAACgB,QAAQ,GAAG,IAAI;MACvBhB,OAAO,CAACe,QAAQ,GAAG,KAAK;MACxBf,OAAO,CAACmC,KAAK,GAAG,IAAI;IACtB;EAAC;IAAA;IAAA,OAED,oBAAWrB,MAAc;MACvB,IAAI,CAAC2H,WAAW,CAAC3H,MAAM,CAAC;MACxB,OAAO,IAAI,CAACd,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC,CAACV,OAAO,CAACA,OAAO;IACjD;IAEA;;;;EAAA;IAAA;IAAA,OAIA,qBAAYU,MAAc;MACxB,OAAO,IAAI,CAACd,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;IACjC;IAEA;;;;;;;EAAA;IAAA;IAAA,OAOA,4BACI4H,MAAoB,EACsB;MAAA;MAAA,IAA1CC,aAAa,uEAAGlK,0BAA0B;MAC5C,OAAOlC,GAAG,EAAE,CAACgD,OAAO,CAAC,mBAAmB,CAAC,IACrCmJ,MAAM,CAACE,KAAK,CACR,eAAK;QAAA,OAAI,MAAI,CAAC5I,OAAO,CAACa,GAAG,CAACH,KAAK,CAACI,MAAM,CAAC,CAACV,OAAO,IAAI,IAAI,IACnDvD,IAAI,CAACwH,aAAa,CAAC3D,KAAK,CAACL,KAAK,CAAC,GAAGsI,aAAa;MAAA,EAAC;IAC9D;EAAC;IAAA;IAAA,OAED,2BAAe;MACb,OAAO,IAAI,CAAC9I,KAAK;IACnB;EAAC;IAAA;IAAA,OAED,eAAMgJ,SAAiB;MACrB1M,YAAY,CAAC2M,IAAI,CACb,2CAA2C,GAC3C,8BAA8B,CAAC;MACnC,IAAMC,QAAQ,GAAGF,SAAS,CAACG,QAAQ,EAAE;MACrC,OAAO7K,SAAS,CAAC0K,SAAS,CAACxI,KAAK,EAAE0I,QAAQ,CAAC;IAC7C;EAAC;IAAA;IAAA,OAEO,uBAAcE,CAAa,EAAEC,EAAU,EAAE5I,KAAe;MAC9D,IAAMa,OAAO,GAAG,IAAInD,oBAAoB,CAACiL,CAAC,CAAC5I,KAAK,EAAE6I,EAAE,CAAC;MACrD,IAAMC,OAAO,GAAG,IAAI,CAACC,aAAa,CAACjI,OAAO,EAAE,CAAC8H,CAAC,CAAC,EAAE3I,KAAK,CAAC;MACvD,OAAOhE,MAAM,EAAE,CAAC8I,wBAAwB,CAAC+D,OAAO,CAAC;IACnD;IAEA;IACA;IACA;EAAA;IAAA;IAAA,OACA,aAAsBF,CAAI;MACxB;MACA,IAAI,IAAI,CAACI,kBAAkB,CAAC,CAACJ,CAAC,CAAC,CAAC,IAAIA,CAAC,CAAC3I,KAAK,KAAK,WAAW,EAAE;QAC3D,IAAMgJ,SAAS,GACX9L,gBAAgB,CAAC,IAAI,CAACwC,OAAO,CAACa,GAAG,CAACoI,CAAC,CAACnI,MAAM,CAAC,CAACS,MAAoB,CAAC;QACrE,OAAO,IAAI,CAACgI,UAAU,CAACN,CAAC,CAAC5I,KAAK,EAAE4I,CAAC,CAAC3I,KAAK,EAAEgJ,SAAS,CAAC;;MAGrD,IAAI/M,GAAG,EAAE,CAACgD,OAAO,CAAC,6BAA6B,CAAC,EAAE;QAChD,OAAO,IAAI,CAACiK,aAAa,CAACP,CAAC,EAAEnL,QAAQ,CAAC2L,GAAG,EAAER,CAAC,CAAC3I,KAAK,CAAM;;MAG1D,IAAMa,OAAO,GAAG,IAAIpD,cAAc,CAACkL,CAAC,CAAC5I,KAAK,EAAEvC,QAAQ,CAAC2L,GAAG,CAAC;MACzD,IAAMN,OAAO,GAAG,IAAI,CAACC,aAAa,CAACjI,OAAO,EAAE,CAAC8H,CAAC,CAAC,CAAC;MAChD,OAAO3M,MAAM,EAAE,CAAC8I,wBAAwB,CAAC+D,OAAO,CAAM;IACxD;EAAC;IAAA;IAAA,OAED,wBACI9I,KAAe,EAAEC,KAAe,EAChCiB,MAA+B;MACjC,IAAIT,MAAM;MACV,IAAIR,KAAK,KAAK,QAAQ,IAAIiB,MAAM,IAAI,IAAI,IAAIA,MAAM,CAACoE,MAAM,GAAG,CAAC,IACzD9I,IAAI,CAAC6M,QAAQ,CAACnI,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;QAC5B,IAAMoI,aAAa,GACdpI,MAA8B,CAACgE,GAAG,CAAC,WAAC;UAAA,OAAI1I,IAAI,CAAC+M,YAAY,CAACnE,CAAC,CAAC;QAAA,EAAC;QAElE3E,MAAM,GAAG,IAAI,CAAC+I,KAAK,CAACF,aAAa,EAAEtJ,KAAK,EAAEC,KAAK,CAAC;OACjD,MAAM;QACLQ,MAAM,GAAG,IAAI,CAAC+I,KAAK,CAACtI,MAAoB,EAAElB,KAAK,EAAEC,KAAK,CAAC;;MAGzD,IAAI,CAACN,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC,CAACa,KAAK,GAAG,IAAI;MACrC,OAAO;QAACb,MAAM,EAANA,MAAM;QAAET,KAAK,EAALA,KAAK;QAAEC,KAAK,EAALA;MAAK,CAAC;IAC/B;EAAC;IAAA;IAAA,OAEO,oBACJD,KAAe,EAAEC,KAAe,EAAEiB,MAAsB;MAC1D,OAAOjF,MAAM,EAAE,CAAC8I,wBAAwB,CAC7B,IAAI,CAACzE,cAAc,CAACN,KAAK,EAAEC,KAAK,EAAEiB,MAAM,CAAC,EAAE,IAAI,CAAM;IAClE;EAAC;IAAA;IAAA,OAED,sBAAab,KAAiB;MAC5B,IAAMS,OAAO,GAAG,IAAIlD,aAAa,CAACyC,KAAK,CAACL,KAAK,CAAC;MAC9C,OAAO,IAAI,CAACgB,eAAe,CAACF,OAAO,EAAE,CAACT,KAAK,CAAC,EAAEA,KAAK,CAACJ,KAAK,CAAC;IAC5D;EAAC;IAAA;IAAA,OAED,oBAAWI,KAAiB;MAC1B,IAAMS,OAAO,GAAG,IAAI1D,WAAW,CAACiD,KAAK,CAACL,KAAK,CAAC;MAC5C,IAAMyJ,2BAA2B,GAAG,IAAI;MACxC,OAAO,IAAI,CAACzI,eAAe,CACvBF,OAAO,EAAE,CAACT,KAAK,CAAC,EAAEA,KAAK,CAACJ,KAAK,EAAE,IAAI,CAAC,2BACpCwJ,2BAA2B,CAAC;IAClC;EAAC;IAAA;IAAA,OAEO,uBAAcpJ,KAAiB,EAAEqJ,UAAoB;MAC3D,IAAMC,YAAY,IAChB9L,UAAU,CAAC+L,WAAW,CAACvJ,KAAK,CAACL,KAAK,CAAC,4BAChCnC,UAAU,CAACgM,WAAW,CAACxJ,KAAK,CAACL,KAAK,CAAC,EACX;MAC7B,IAAM8J,OAAO,GAAe;QAC1B7J,KAAK,EAAEI,KAAK,CAACJ,KAAK;QAClBD,KAAK,EAAE2J,YAAY;QACnBlJ,MAAM,EAAEJ,KAAK,CAACI;OACf;MACD,IAAMsJ,cAAc,IAClBlM,UAAU,CAAC+L,WAAW,CAACF,UAAU,CAAC,4BAAK7L,UAAU,CAACgM,WAAW,CAACH,UAAU,CAAC,EAC9C;MAE7B,IAAM5I,OAAO,GAAG,IAAIzD,oBAAoB,CAAC0M,cAAc,EAAEJ,YAAY,CAAC;MACtE,IAAMK,6BAA6B,GAAG,IAAI;MAC1C,IAAMC,YAAY,GAAG,CAACN,YAAY,CAAC;MACnC,IAAM5I,MAAM,GAAG,IAAI,CAACC,eAAe,CAC/BF,OAAO,EAAE,CAACgJ,OAAO,CAAC,EAAEzJ,KAAK,CAACJ,KAAK,EAAEgK,YAAY,EAC7CD,6BAA6B,CAAC;MAClC,OAAO;QAACvJ,MAAM,EAAEM,MAAM,CAACN,MAAM;QAAET,KAAK,EAAE0J,UAAU;QAAEzJ,KAAK,EAAEc,MAAM,CAACd;MAAK,CAAC;IACxE;EAAC;IAAA;IAAA,OAEO,gBAAOQ,MAAc,EAAEoE,cAAiC;MAE9D,IAAMlF,OAAO,GAAG,IAAI,CAACA,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;MACxC,IAAOC,QAAQ,GAAkBf,OAAO,CAAjCe,QAAQ;QAAEV,KAAK,GAAWL,OAAO,CAAvBK,KAAK;QAAEC,KAAK,GAAIN,OAAO,CAAhBM,KAAK;MAC7B,IAAI4E,cAAc,IAAI,IAAI,EAAE;QAC1B,IAAMd,IAAI,GAAGvH,IAAI,CAACwH,aAAa,CAAChE,KAAK,CAAC;QACtC,IAAMkK,OAAO,GAAGrF,cAAc,CAAC,CAAC,CAAC,GAAGA,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC;QACzDrI,IAAI,CAAC2N,MAAM,CACPpG,IAAI,IAAImG,OAAO,EACf;UAAA,OAAM,+BAA+B,GACjC,sDAAsD,GACtD,0BAA0B;QAAA,EAAC;;MAErC,IAAMtJ,SAAS,GACX/C,UAAU,CAACgD,YAAY,CAACb,KAAK,CAA6B;MAC9D,IAAIc,OAAO;MACX,IAAIJ,QAAQ,EAAE;QACZI,OAAO,GAAG,IAAInE,yBAAyB,CAACiE,SAAS,CAAC;OACnD,MAAM;QACLE,OAAO,GAAG,IAAIpE,mBAAmB,CAACkE,SAAS,CAAC;;MAE9C,IAAMoJ,6BAA6B,GAAG,IAAI;MAC1C,IAAMC,YAAY,GACd,CAACpF,cAAc,IAAI,IAAI,GAAGA,cAAc,GACdvH,QAAQ,CAACoG,gBAAgB,CAAC9C,SAAS,CAAC,CAAC;MACnE,IAAMwJ,GAAG,GAAG,IAAI,CAACpJ,eAAe,CAC5BF,OAAO,EAAE,CAAC;QAACd,KAAK,EAAEY,SAAS;QAAEX,KAAK,EAALA,KAAK;QAAEQ,MAAM,EAANA;MAAM,CAAC,CAAC,EAAER,KAAK,EAAEgK,YAAY,EACjED,6BAA6B,EAAEnF,cAAc,CAAC;MAClD,OAAO;QAAC5E,KAAK,EAALA,KAAK;QAAED,KAAK,EAALA,KAAK;QAAES,MAAM,EAAE2J,GAAG,CAAC3J;MAAM,CAAC;IAC3C;EAAC;IAAA;IAAA,OAED,yBACIK,OAAqB,EAAEuH,MAAoB,EAAEgC,WAAqB,EAClEC,mBAAgC,EACC;MAAA;MAAA,IADCN,6BAA6B,uEAAG,KAAK;MAAA,IACvEnF,cAAiC;MACnC,IAAM9D,MAAM,GAAG,IAAI,CAACT,cAAc,CAACQ,OAAO,CAAC8E,WAAW,EAAEyE,WAAW,CAAC;MACpE,IAAME,OAAO,GAAG,IAAI,CAAC5K,OAAO,CAACa,GAAG,CAACO,MAAM,CAACN,MAAM,CAAC;MAC/C,IAAIK,OAAO,CAAC0J,YAAY,EAAE;QACxBD,OAAO,CAAC7J,QAAQ,GAAG,IAAI;;MAEzB,IAAII,OAAO,CAAC2J,gBAAgB,KAAKnN,QAAQ,CAACoN,aAAa,CAACC,KAAK,EAAE;QAC7D,IAAMC,UAAU,GAAG/F,cAAc,IAAI,IAAI,GACrCA,cAAc,GACdvH,QAAQ,CAACoG,gBAAgB,CAAC5C,OAAO,CAAC8E,WAAW,CAAC;QAClD;QACA;QACA;QACA;QACA2E,OAAO,CAAC5J,QAAQ,GAAGiK,UAAU,CAAC1F,GAAG,CAAC,WAAC;UAAA,OAAIE,CAAC,GAAG,CAAC;QAAA,EAAqB;;MAEnE,IAAItE,OAAO,CAAC+J,WAAW,IAAI,IAAI,EAAE;QAC/BN,OAAO,CAACjJ,KAAK,GAAGR,OAAO,CAAC+J,WAAW;;MAGrC,IAAIrO,IAAI,CAACwH,aAAa,CAACjD,MAAM,CAACf,KAAK,CAAC,KAAK,CAAC,EAAE;QAC1C;QACA;QACAuK,OAAO,CAACrJ,MAAM,GACV1E,IAAI,CAACsO,sBAAsB,CAAC/J,MAAM,CAACd,KAAkB,EAAE,CAAC,CAAC;QAC7D,OAAOc,MAAM;;MAGf,IAAMgK,aAAa,GAAiB,EAAE;MACtC,IAAMC,UAAU,GAAiB3C,MAAM,CAACnD,GAAG,CAAC,eAAK,EAAG;QAClD,IAAI7E,KAAK,CAACJ,KAAK,KAAK,WAAW,EAAE;UAC/B,MAAM,IAAId,KAAK,CACX,gIAC8D,WACtD,CAAC;;QAGf,IAAIQ,OAAO,GAAG,MAAI,CAACA,OAAO,CAACa,GAAG,CAACH,KAAK,CAACI,MAAM,CAAC;QAE5C,IAAId,OAAO,CAACI,OAAO,IAAI,IAAI,EAAE;UAC3B,IAAI,CAACe,OAAO,CAACmK,YAAY,IACrBzO,IAAI,CAACwH,aAAa,CAAC3D,KAAK,CAACL,KAAK,CAAC,IAC3B9D,GAAG,EAAE,CAACmC,SAAS,CAAC,2BAA2B,CAAC,EAAE;YACpD;YACA;YACA;YACA;YACA;YACA,OAAO;cACL2B,KAAK,EAAEK,KAAK,CAACL,KAAK;cAClBL,OAAO,EAAE,IAAI;cACbuL,SAAS,EAAE,IAAI;cACfC,aAAa,EAAExL,OAAO,CAACuB;aACxB;;UAGH;UACA;UACA,IAAIJ,OAAO,CAACmK,YAAY,EAAE;YACxBtL,OAAO,CAACe,QAAQ,GAAG,IAAI;YACvBf,OAAO,CAACK,KAAK,GAAGK,KAAK,CAACL,KAAK;;;QAI/B,MAAI,CAACoI,WAAW,CAAC/H,KAAK,CAACI,MAAM,CAAC;QAC9B,IAAI,CAAC,CAACd,OAAO,CAACe,QAAQ,KAAK,CAAC,CAACI,OAAO,CAACmK,YAAY,EAAE;UACjD5K,KAAK,GAAGV,OAAO,CAACe,QAAQ,GAAG,MAAI,CAAC0K,YAAY,CAAC/K,KAAK,CAAC,GACxB,MAAI,CAACgL,UAAU,CAAChL,KAAK,CAAC;UACjD0K,aAAa,CAAC5H,IAAI,CAAC9C,KAAK,CAAC;UACzBV,OAAO,GAAG,MAAI,CAACA,OAAO,CAACa,GAAG,CAACH,KAAK,CAACI,MAAM,CAAC;SACzC,MAAM,IACHd,OAAO,CAACe,QAAQ,IAChB,CAAC7C,UAAU,CAACyN,aAAa,CAAC3L,OAAO,CAACK,KAAK,EAAEK,KAAK,CAACL,KAAK,CAAC,EAAE;UACzD;UACA;UACA;UACA;UACA;UACA;UAEA,IAAMuL,UAAU,GAAGlL,KAAK;UACxB,IAAMmL,WAAW,GAAGnL,KAAK,CAACL,KAAK;UAE/BK,KAAK,CAACL,KAAK,GAAGL,OAAO,CAACK,KAAK;UAC3BK,KAAK,GAAG,MAAI,CAACoL,aAAa,CAACpL,KAAe,EAAEmL,WAAW,CAAC;UACxDT,aAAa,CAAC5H,IAAI,CAAC9C,KAAK,CAAC;UACzBV,OAAO,GAAG,MAAI,CAACA,OAAO,CAACa,GAAG,CAACH,KAAK,CAACI,MAAM,CAAC;UAExC8K,UAAU,CAACvL,KAAK,GAAGwL,WAAW;;QAGhC,OAAO;UAACxL,KAAK,EAAEK,KAAK,CAACL,KAAK;UAAEL,OAAO,EAAPA,OAAO;UAAEuL,SAAS,EAAE;QAAK,CAAC;MACxD,CAAC,CAAC;MAEF,IAAI,CAAC9C,WAAW,CAACrH,MAAM,CAACN,MAAM,CAAC;MAC/B,IAAMiL,UAAU,GACC;QAAC1L,KAAK,EAAEe,MAAM,CAACf,KAAK;QAAEL,OAAO,EAAE4K,OAAO;QAAEW,SAAS,EAAE;MAAK,CAAC;MAC1E,IAAMnD,GAAG,GAAG9K,UAAU,CAAC0O,aAAa,CAAC7K,OAAO,EAAEkK,UAAU,EAAEU,UAAU,CAAC;MACrE,IAAME,MAAM,GAAG,IAAI,CAACC,gBAAgB,CAAC9D,GAAG,EAAE,YAAK;QAC7C,OAAO9K,UAAU,CAAC6O,cAAc,CAC5B,MAAI,CAACtM,KAAK,EAAEsB,OAAO,EAAEkK,UAAU,EAAEU,UAAU,CAAC;MAClD,CAAC,CAAC;MACF,IAAMtJ,iBAAiB,GAAG,IAAI,CAACC,YAAY,IAAI,IAAI;MACnD,IAAIgE,KAA+B;MACnC,IAAIjE,iBAAiB,EAAE;QACrBiE,KAAK,GAAG,IAAI,CAAC0F,UAAU,EAAE;;MAG3B,IAAI,CAAC7P,GAAG,EAAE,CAACsE,GAAG,CAAC,qBAAqB,CAAC,EAAE;QACrCvD,UAAU,CAAC+O,UAAU,CACjB,IAAI,CAACxM,KAAK,EAAEoM,MAAM,EAAEZ,UAAU,EAAEU,UAAU,EAAEpB,mBAAmB,CAAC;;MAGtES,aAAa,CAACzG,OAAO,CAAC,cAAI;QAAA,OAAI,MAAI,CAACrD,6BAA6B,CAACgL,IAAI,CAAC;MAAA,EAAC;MAEvE,IAAI7J,iBAAiB,EAAE;QACrBiE,KAAK,GAAG,IAAI,CAAC6F,QAAQ,CAAC7F,KAAK,CAAC;QAC5B,IAAI,CAAChE,YAAY,CAACc,IAAI,CAClB;UAACqD,IAAI,EAAE1F,OAAO,CAACqL,WAAW,CAAC3F,IAAI;UAAEH,KAAK,EAAE,IAAI,CAAC+F,YAAY,CAAC/F,KAAK;QAAC,CAAC,CAAC;;MAGxE,IAAMgG,gBAAgB,GAAGnQ,GAAG,EAAE,CAACsE,GAAG,CAAC,uBAAuB,CAAC;MAC3D;MACA,IAAI6L,gBAAgB,GAAG,CAAC,EAAE;QACxB,IAAMC,IAAI,GAAG9P,IAAI,CAAC+F,GAAG,EAAE;QACvB,IAAK+J,IAAI,GAAG,IAAI,CAACC,eAAe,GAAIF,gBAAgB,EAAE;UACpD,IAAI,CAAC7M,KAAK,CAACH,EAAE,CAACmN,KAAK,EAAE;UACrB,IAAI,CAACD,eAAe,GAAGD,IAAI;;;MAI/B,IAAI,CAACpQ,GAAG,EAAE,CAACgD,OAAO,CAAC,qBAAqB,CAAC,IAAIqL,OAAO,CAAC7J,QAAQ,IACzDsJ,6BAA6B,KAAK,KAAK,EAAE;QAC3C,IAAMyC,QAAQ,GAAG,IAAI,CAACrB,YAAY,CAACrK,MAAM,CAAC;QAC1C,IAAI,CAACE,6BAA6B,CAACF,MAAM,CAAC;QAC1C,OAAO0L,QAAQ;;MAEjB,OAAO1L,MAAM;IACf;EAAC;IAAA;IAAA,OAED,uBACID,OAAqB,EAAEuH,MAAoB,EAAEgC,WAAsB,EACnEC,mBAAgC,EACK;MAAA,IAArCN,6BAA6B,uEAAG,KAAK;MACvCK,WAAW,GAAGA,WAAW,IAAIhC,MAAM,CAAC,CAAC,CAAC,CAACpI,KAAK;MAC5C,IAAM6I,OAAO,GAAG,IAAI,CAAC9H,eAAe,CAChCF,OAAO,EAAEuH,MAAM,EAAEgC,WAAW,EAAEC,mBAAmB,EACjDN,6BAA6B,CAAC;MAClC,OAAOlB,OAAO;IAChB;EAAC;IAAA;IAAA,OAEO,0BAAiBf,GAAW,EAAE2E,SAA4B;MAEhE,IAAI,EAAE3E,GAAG,IAAI,IAAI,CAACzI,WAAW,CAAC,EAAE;QAC9B,IAAI,CAACA,WAAW,CAACyI,GAAG,CAAC,GAAG2E,SAAS,EAAE;;MAErC,OAAO,IAAI,CAACpN,WAAW,CAACyI,GAAG,CAAC;IAC9B;EAAC;IAAA;IAAA,OAED,6BAAiB;MACf,OAAO,IAAI,CAACrI,cAAc;IAC5B;EAAC;IAAA;IAAA,OAIQ,mBAAO;MAAA;MACd,IAAI,IAAI,CAACiN,QAAQ,EAAE;QACjB;;MAEF;MACA;MACA,IAAI,CAACzQ,GAAG,EAAE,CAACgD,OAAO,CAAC,SAAS,CAAC,EAAE;QAC7B,IAAM0N,OAAO,GAAGC,MAAM,CAACC,IAAI,CAAC,IAAI,CAACxN,WAAW,CAAC;QAC7CsN,OAAO,CAACtI,OAAO,CAAC,aAAG,EAAG;UACpB,MAAI,CAAC9E,KAAK,CAACuN,aAAa,CAAC,MAAI,CAACzN,WAAW,CAACyI,GAAG,CAAC,CAACiF,YAAY,CAAC;UAC5D,OAAO,MAAI,CAAC1N,WAAW,CAACyI,GAAG,CAAC;QAC9B,CAAC,CAAC;;MAEJ,IAAI,CAACrI,cAAc,CAACuN,OAAO,EAAE;MAC7B,IAAI,IAAI,CAACxN,MAAM,IAAI,IAAI,IAClB,OAAQyN,iBAAkB,KAAK,WAAW,IAC1C,IAAI,CAACzN,MAAM,YAAYyN,iBAAkB,EAAE;QAC9C,IAAI,CAACzN,MAAM,CAAC0N,MAAM,EAAE;OACrB,MAAM;QACL,IAAI,CAAC1N,MAAM,GAAG,IAAI;;MAEpB,IAAI,IAAI,CAACF,mBAAmB,EAAE;QAC5B,IAAI,CAACC,KAAK,CAACsB,OAAO,GAAG,IAAI;QACzB,IAAI,CAACtB,KAAK,CAACyN,OAAO,EAAE;;MAEtB,IAAI,CAACN,QAAQ,GAAG,IAAI;IACtB;EAAC;IAAA;IAAA,OAEQ,0BAAc;MAAA;MACrB,IAAI,IAAI,CAACS,mBAAmB,IAAI,IAAI,EAAE;QACpC,IAAI,CAACA,mBAAmB,GAAG7Q,IAAI,CAAC,YAAK;UACnC,IAAI,CAACL,GAAG,EAAE,CAACsE,GAAG,CAAC,8BAA8B,CAAC,EAAE;YAC9C;YACA;YACA,IAAM6M,SAAS,GAAGnR,GAAG,EAAE,CAACgD,OAAO,CAAC,OAAO,CAAC;YACxChD,GAAG,EAAE,CAACmF,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC;YACzB,IAAMiM,mBAAmB,GAAG,MAAI,CAACC,GAAG,CAACjR,MAAM,CAAC,IAAI,CAAC,CAAC,CAACqM,QAAQ,EAAE,CAAC,CAAC,CAAC;YAChEzM,GAAG,EAAE,CAACmF,GAAG,CAAC,OAAO,EAAEgM,SAAS,CAAC;YAE7B,IAAIC,mBAAmB,GAAG,CAAC,EAAE;cAC3B,OAAO,EAAE;;;UAGb,OAAO,EAAE;QACX,CAAC,CAAC;;MAEJ,OAAO,IAAI,CAACF,mBAAmB;IACjC;IAEA;EAAA;IAAA;IAAA,OACS,mBAAO;MACd,OAAO,IAAI,CAACI,cAAc,EAAE,KAAK,EAAE,GAAGzP,eAAe,GAAGC,eAAe;IACzE;EAAC;IAAA;IAAA,OAED,qBAAYyC,MAAc;MACxB,IAAMd,OAAO,GAAG,IAAI,CAACA,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;MACxC,IAAOT,KAAK,GAA6CL,OAAO,CAAzDK,KAAK;QAAEC,KAAK,GAAsCN,OAAO,CAAlDM,KAAK;QAAEiB,MAAM,GAA8BvB,OAAO,CAA3CuB,MAAM;QAAEnB,OAAO,GAAqBJ,OAAO,CAAnCI,OAAO;QAAEuB,KAAK,GAAc3B,OAAO,CAA1B2B,KAAK;QAAEZ,QAAQ,GAAIf,OAAO,CAAnBe,QAAQ;MAErD,IAAIX,OAAO,IAAI,IAAI,EAAE;QACnB;QACA;;MAEF,IAAMqC,iBAAiB,GAAG,IAAI,CAACC,YAAY,IAAI,IAAI;MACnD,IAAIC,KAAa;MACjB,IAAIF,iBAAiB,EAAE;QACrBE,KAAK,GAAG9F,IAAI,CAAC+F,GAAG,EAAE;;MAGpB,IAAI5B,QAAQ,GAAGhB,OAAO,CAACgB,QAAQ;MAC/B,IAAIA,QAAQ,IAAI,IAAI,EAAE;QACpB;QACA;QACAA,QAAQ,GAAG9C,UAAU,CAAC4P,+BAA+B,CAACzN,KAAK,EAAEU,QAAQ,CAAC;QACtEf,OAAO,CAACgB,QAAQ,GAAGA,QAAQ;;MAG7B,IAAIO,MAAM,IAAI,IAAI,EAAE;QAClB,IAAMN,SAAS,GAAG/C,UAAU,CAACgD,YAAY,CAACb,KAAK,CAAC;QAEhD,IAAIc,OAAO;QACX,IAAInC,KAAK,GAAGgC,QAAQ,CAAC,CAAC,CAAC;UAAEjC,MAAM,GAAGiC,QAAQ,CAAC,CAAC,CAAC;QAC7C,IAAM+M,WAAW,GACbxM,MAAM,YAAYyM,UAAU,IAAIzM,MAAM,YAAY0M,iBAAiB;QAEvE;QACA;QACA,IAAIlN,QAAQ,IAAI,CAACgN,WAAW,EAAE;UAAA,4BACVpQ,QAAQ,CAACuQ,sCAAsC,CAC7DlN,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC;UAAA;UAD5BhC,KAAK;UAAED,MAAM;;QAIhB,IAAIgC,QAAQ,EAAE;UACZI,OAAO,GAAG,IAAI/D,yBAAyB,CAAC6D,SAAS,EAAE8M,WAAW,CAAC;SAChE,MAAM;UACL5M,OAAO,GAAG,IAAIhE,mBAAmB,CAAC8D,SAAS,EAAE8M,WAAW,CAAC;;QAG3D;QACA;QACA;QACA,IAAMI,sBAAsB,GACxBJ,WAAW,GAAG,CAAChP,MAAM,EAAEC,KAAK,CAAC,GAAGgC,QAAQ;QAC5C,IAAMoN,oBAAoB,GACtB,IAAI,CAACzN,cAAc,CAACwN,sBAAsB,EAAE7N,KAAK,CAAC;QACtD,IAAM+N,qBAAqB,GACvB,IAAI,CAACrO,OAAO,CAACa,GAAG,CAACuN,oBAAoB,CAACtN,MAAM,CAAC;QACjD,IAAIiN,WAAW,EAAE;UACfM,qBAAqB,CAAC1M,KAAK,GAAG/D,YAAY,CAAC0Q,MAAM;SAClD,MAAM;UACLD,qBAAqB,CAAC1M,KAAK,GAAG/D,YAAY,CAACgE,MAAM;;QAEnDyM,qBAAqB,CAACrN,QAAQ,GAAGmN,sBAAsB;QACvD,IAAI,CAACtO,KAAK,CAAC0O,0BAA0B,CACjC,IAAI,CAACC,UAAU,CAACJ,oBAAoB,CAACtN,MAAM,CAAC,EAAE9B,KAAK,EAAED,MAAM,EAC3DwC,MAAoB,CAAC;QAEzB,IAAM+I,YAAY,GAAG,CAAC,CAACvL,MAAM,EAAEC,KAAK,CAAC,CAAC;QACtC;QACA;QACA,IAAMyP,qBAAqB,GAAG,IAAI;QAClC,IAAMC,mBAAmB,GAAG,IAAI,CAACrN,eAAe,CAC5CF,OAAO,EAAE,CAACiN,oBAAoB,CAAC,EAAE9N,KAAK,EAAEgK,YAAY,EACpDmE,qBAAqB,CAAC;QAE1B;QACA,IAAME,aAAa,GAAG,IAAI,CAAC3O,OAAO,CAACa,GAAG,CAAC6N,mBAAmB,CAAC5N,MAAM,CAAC;QAClEd,OAAO,CAACgB,QAAQ,GAAG2N,aAAa,CAAC3N,QAAQ;QACzChB,OAAO,CAACe,QAAQ,GAAG4N,aAAa,CAAC5N,QAAQ;QACzCf,OAAO,CAAC2B,KAAK,GAAGgN,aAAa,CAAChN,KAAK;QAEnC,IAAI,CAACpF,GAAG,EAAE,CAACsE,GAAG,CAAC,qBAAqB,CAAC,EAAE;UACrCb,OAAO,CAACI,OAAO,GAAGuO,aAAa,CAACvO,OAAO;UACvC;UACAJ,OAAO,CAACuB,MAAM,GAAG,IAAI;UACrB,IAAI,CAACvB,OAAO,CAAC0E,MAAM,CAACgK,mBAAmB,CAAC5N,MAAM,CAAC;SAChD,MAAM;UACL,IAAI,CAACmB,WAAW,CAACyM,mBAAmB,CAAC5N,MAAM,CAAC;;QAG9C,IAAI,CAACQ,6BAA6B,CAAC8M,oBAAoB,CAAC;QAExD,IAAI3L,iBAAiB,EAAE;UACrB,IAAI,CAACqE,YAAY,IAAIjK,IAAI,CAAC+F,GAAG,EAAE,GAAGD,KAAK;;OAE1C,MAAM;QACL,IAAMiM,UAAU,GAAG,IAAI,CAACC,cAAc,CAAC7N,QAAQ,EAAEW,KAAK,EAAErB,KAAK,EAAES,QAAQ,CAAC;QACxEf,OAAO,CAACI,OAAO,GAAGwO,UAAU;;IAEhC;EAAC;IAAA;IAAA,OAEO,8BAAqB9N,MAAc,EAAEgO,aAA4B;MAEvE,IAAM9O,OAAO,GAAG,IAAI,CAACA,OAAO,CAACa,GAAG,CAACC,MAAM,CAAC;MACxC,IAAOR,KAAK,GAAIN,OAAO,CAAhBM,KAAK;MAEZ,IAAIwO,aAAa,IAAI,IAAI,EAAE;QACzB9O,OAAO,CAACuB,MAAM,GAAGwN,mBAAmB,CAACD,aAAa,EAAExO,KAAkB,CAAC;;MAEzE,OAAON,OAAO,CAACuB,MAAoB;IACrC;EAAC;IAAA;IAAA,OAEO,wBACJP,QAA0B,EAAEgO,OAAqB,EAAE1O,KAAe,EAClES,QAAiB;MACnB,IAAI,CAACuG,aAAa,IAAI,IAAI,CAACiB,YAAY,CAACvH,QAAQ,EAAEV,KAAK,CAAC;MACxD,IAAI,CAAC,IAAI,CAAC2O,iBAAiB,IACvB,IAAI,CAAC3H,aAAa,GAAG,IAAI,CAAC1I,kBAAkB,GAAG,IAAI,GAAG,IAAI,EAAE;QAC9D,IAAMsQ,EAAE,GAAG,CAAC,IAAI,CAAC5H,aAAa,GAAG,IAAI,GAAG,IAAI,EAAE6H,OAAO,CAAC,CAAC,CAAC;QACxD,IAAI,CAACF,iBAAiB,GAAG,IAAI;QAC7BG,OAAO,CAACtG,IAAI,CACR,oCAA6BoG,EAAE,+CACG,CAAC;;MAEzC,OAAO,IAAI,CAACnP,cAAc,CAAC8O,cAAc,CAAC7N,QAAQ,EAAEgO,OAAO,EAAEjO,QAAQ,CAAC;IACxE;EAAC;IAAA;IAAA,OAEO,sBAAaV,KAAuB,EAAEC,KAAe;MAC3D,OAAOD,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAGxD,IAAI,CAACwS,eAAe,CAAC/O,KAAK,CAAC;IAC1D;EAAC;IAAA;IAAA,OAED,kCAAsB;MACpB,mCAAyB4M,MAAM,CAACoC,OAAO,CAAC,IAAI,CAAC3P,WAAW,CAAC,qCAAE;QAAtD;UAASsM,MAAM;QAClB,IAAI,CAACsD,gBAAgB,CAACtD,MAAM,CAAC;;IAEjC;EAAC;IAAA;IAAA;MAAA,8FAED;QAAA;QAAA;QAAA;UAAA;YAAA;cACQ/H,EAAE,GAAG,EAAE;cAAA,KACT,IAAI,CAACrE,KAAK,CAAC2P,4BAA4B;gBAAA;gBAAA;cAAA;cACzC,iCAAyBtC,MAAM,CAACoC,OAAO,CAAC,IAAI,CAAC3P,WAAW,CAAC,wCAAE;gBAAA,gEAA7CsM,MAAM;gBAClB/H,EAAE,CAACV,IAAI,CAAC,IAAI,CAACiM,qBAAqB,CAACxD,MAAM,CAAC,CAAC;;cAC5C,kCACM1I,OAAO,CAACU,GAAG,CAACC,EAAE,CAAC;YAAA;cAAA;gBAAA;gBAAA;kBAAA;oBAAA;sBAAA,gEAER+H,MAAM;sBACZyD,CAAC,GAAqB,IAAInM,OAAO,CAAC,UAACE,OAAO,EAAI;wBAClD,IAAI;0BACF,MAAI,CAAC8L,gBAAgB,CAACtD,MAAM,CAAC;0BAC7BxI,OAAO,CAAC,IAAI,CAAC;yBACd,CAAC,OAAO2D,KAAK,EAAE;0BACd,MAAMA,KAAK;;sBAEf,CAAC,CAAC;sBACFlD,EAAE,CAACV,IAAI,CAACkM,CAAC,CAAC;oBAAC;oBAAA;sBAAA;kBAAA;gBAAA;cAAA;cAAA,4BATYxC,MAAM,CAACoC,OAAO,CAAC,IAAI,CAAC3P,WAAW,CAAC;YAAA;cAAA;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAAA;cAAA;cAAA;YAAA;cAAA,kCAWlD4D,OAAO,CAACU,GAAG,CAACC,EAAE,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CAEzB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,wFAEO,kBAA4B+H,MAAmB;QAAA;UAAA;YAAA;cAAA,KACjD,IAAI,CAACpM,KAAK,CAACH,EAAE,CAACiQ,mBAAmB,CAC7B1D,MAAM,CAACoB,YAAY,EACnB,IAAI,CAACxN,KAAK,CAAC2P,4BAA4B,CAACI,qBAAqB,CAAC;gBAAA;gBAAA;cAAA;cAAA,kCAC7D,IAAI,CAACL,gBAAgB,CAACtD,MAAM,CAAC;YAAA;cAAA;cAAA,OAE9BvP,SAAS,EAAE;YAAA;cAAA,kCACV,IAAI,CAAC+S,qBAAqB,CAACxD,MAAM,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CAE5C;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OAEO,0BAAiBA,MAAmB;MAC1C,IAAI,IAAI,CAACpM,KAAK,CAACH,EAAE,CAACiQ,mBAAmB,CAC7B1D,MAAM,CAACoB,YAAY,EAAE,IAAI,CAACxN,KAAK,CAACH,EAAE,CAACmQ,WAAW,CAAC,KAAK,KAAK,EAAE;QACjET,OAAO,CAACU,GAAG,CAAC,IAAI,CAACjQ,KAAK,CAACH,EAAE,CAACqQ,iBAAiB,CAAC9D,MAAM,CAACoB,YAAY,CAAC,CAAC;QACjE,IAAI,IAAI,CAACxN,KAAK,CAACH,EAAE,CAACsQ,kBAAkB,CAC5B/D,MAAM,CAACgE,cAAc,EAAE,IAAI,CAACpQ,KAAK,CAACH,EAAE,CAACwQ,cAAc,CAAC,KAAK,KAAK,EAAE;UACtEhS,UAAU,CAACiS,yBAAyB,CAChClE,MAAM,CAACmE,MAAM,EACb,IAAI,CAACvQ,KAAK,CAACH,EAAE,CAAC2Q,gBAAgB,CAACpE,MAAM,CAACgE,cAAc,CAAC,CAAC;UAC1D,MAAM,IAAIzQ,KAAK,CAAC,oCAAoC,CAAC;;QAEvD,MAAM,IAAIA,KAAK,CAAC,6CAA6C,CAAC;;MAEhE,OAAO,IAAI;IACb;EAAC;IAAA;IAAA,OAED,+BAAmB;MACjB,qCAAyB0N,MAAM,CAACoC,OAAO,CAAC,IAAI,CAAC3P,WAAW,CAAC,wCAAE;QAAtD;UAASsM,MAAM;QAClB,4BAUI1O,oBAAmB,CAAC,IAAI,CAACsC,KAAK,EAAEoM,MAAM,CAAC9K,OAAO,EAAE8K,MAAM,CAACoB,YAAY,CAAC;UATtEiD,gBAAgB,yBAAhBA,gBAAgB;UAChBC,sBAAsB,yBAAtBA,sBAAsB;UACtBC,MAAM,yBAANA,MAAM;UACNC,MAAM,yBAANA,MAAM;UACNC,iBAAiB,yBAAjBA,iBAAiB;UACjBC,oBAAoB,yBAApBA,oBAAoB;UACpBC,gBAAgB,yBAAhBA,gBAAgB;UAChBC,uBAAuB,yBAAvBA,uBAAuB;UACvBC,mBAAmB,yBAAnBA,mBAAmB;QAErB7E,MAAM,CAACqE,gBAAgB,GAAGA,gBAAgB;QAC1CrE,MAAM,CAACsE,sBAAsB,GAAGA,sBAAsB;QACtDtE,MAAM,CAACuE,MAAM,GAAGA,MAAM;QACtBvE,MAAM,CAACwE,MAAM,GAAGA,MAAM;QACtBxE,MAAM,CAACyE,iBAAiB,GAAGA,iBAAiB;QAC5CzE,MAAM,CAAC0E,oBAAoB,GAAGA,oBAAoB;QAClD1E,MAAM,CAAC2E,gBAAgB,GAAGA,gBAAgB;QAC1C3E,MAAM,CAAC4E,uBAAuB,GAAGA,uBAAuB;QACxD5E,MAAM,CAAC6E,mBAAmB,GAAGA,mBAAmB;;IAEpD;IAEA;;;;EAAA;IAAA;IAAA,OAIS,iCACLvP,MAAiB,EAAElB,KAAe,EAAEC,KAAe;MACrDiB,MAAM,CAACd,QAAQ,GAAGc,MAAM,CAACd,QAAQ,IAAI,MAAM;MAC3C,IAAOL,OAAO,GAA6BmB,MAAM,CAA1CnB,OAAO;QAAErB,MAAM,GAAqBwC,MAAM,CAAjCxC,MAAM;QAAEC,KAAK,GAAcuC,MAAM,CAAzBvC,KAAK;QAAEyB,QAAQ,GAAIc,MAAM,CAAlBd,QAAQ;MACvC,IAAMsQ,OAAO,GAAGzU,MAAM,EAAE,CAACyU,OAA2B;MAEpD;MACA;MACA,IAAI,CAACA,OAAO,CAAClR,KAAK,CAACH,EAAE,CAACsR,SAAS,CAAC5Q,OAAO,CAAC,EAAE;QACxC,MAAM,IAAIZ,KAAK,CACX,uIACmE,uEACC,wDACf,6CACX,CAAC;;MAGjD,IAAMsB,MAAM,GACRiQ,OAAO,CAACE,YAAY,CAAC7Q,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEvB,MAAM,EAAEC,KAAK,EAAEyB,QAAQ,CAAC;MACxE,OAAOnE,MAAM,EAAE,CAAC4U,oBAAoB,CAACpQ,MAAM,EAAET,KAAK,EAAEC,KAAK,EAAEyQ,OAAO,CAAC;IACrE;EAAC;EAAA;AAAA,EAvsCmCtU,aAAa;AAIlC0C,2BAAU,GAAG,CAAC;AAssC/B,SAAS4P,mBAAmB,CACxBoC,CAAe,EAAE7Q,KAAQ;EAC3B,IAAIA,KAAK,KAAK,SAAS,IAAIA,KAAK,KAAK,WAAW,EAAE;IAChD,OAAO6Q,CAAsB;GAC9B,MAAM,IAAI7Q,KAAK,KAAK,OAAO,IAAIA,KAAK,KAAK,MAAM,EAAE;IAChD,IAAMuC,MAAM,GAAIvC,KAAK,KAAK,OAAO,GAAI,IAAI8Q,UAAU,CAACD,CAAC,CAACxL,MAAM,CAAC,GACxB,IAAIqI,UAAU,CAACmD,CAAC,CAACxL,MAAM,CAAC;IAC7D,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7C,MAAM,CAAC8C,MAAM,EAAE,EAAED,CAAC,EAAE;MACtC7C,MAAM,CAAC6C,CAAC,CAAC,GAAG2L,IAAI,CAACC,KAAK,CAACH,CAAC,CAACzL,CAAC,CAAC,CAAC;;IAE9B,OAAO7C,MAA2B;GACnC,MAAM;IACL,MAAM,IAAIrD,KAAK,yBAAkBc,KAAK,EAAG;;AAE7C","names":["backend_util","buffer","DataStorage","engine","env","kernel_impls","KernelBackend","nextFrame","scalar","tidy","util","getWebGLContext","DecodeMatrixProgram","DecodeMatrixPackedProgram","EncodeFloatProgram","EncodeFloatPackedProgram","EncodeMatrixProgram","EncodeMatrixPackedProgram","GPGPUContext","gpgpu_math","getUniformLocations","simpleAbsImplCPU","PackProgram","ReshapePackedProgram","tex_util","TextureUsage","TextureManager","unary_op","UnaryOpProgram","UnaryOpPackedProgram","UnpackProgram","webgl_util","whereImpl","EPSILON_FLOAT32","EPSILON_FLOAT16","binaryCaches","getBinaryCache","webGLVersion","CPU_HANDOFF_SIZE_THRESHOLD","getNumber","BEFORE_PAGING_CONSTANT","numMBBeforeWarning","global","screen","height","width","window","devicePixelRatio","MathBackendWebGL","gpuResource","WeakMap","WeakSet","getBool","Error","newGPGPU","gl","binaryCache","gpgpuCreatedLocally","gpgpu","canvas","textureManager","texData","nextDataId","numDataIds","pendingDeletes","texture","shape","dtype","texHeight","texWidth","channels","input","makeTensorInfo","inData","get","dataId","isPacked","texShape","shapeAs3D","getShapeAs3D","program","output","runWebGLProgram","disposeIntermediateTensorInfo","values","checkNumericalProblems","id","set","usage","UPLOAD","refCount","has","tensorData","tensorInfo","disposeData","complexTensorInfos","slice","CLONE","res","data","readSync","convertAndCacheOnCPU","shouldTimeProgram","activeTimers","start","now","result","realValues","real","imagValues","imag","mergeRealAndImagArrays","getValuesFromTexture","downloadWaitMs","pendingRead","subscribers","Promise","push","resolve","read","tmpDownloadTarget","decode","tmpData","createBufferFromTexture","getDenseTexShape","createAndWaitForFence","all","ps","vals","size","sizeFromShape","downloadFloat32MatrixFromBuffer","callAndCheck","deleteBuffer","dTypeVals","delete","forEach","pendingDisposal","removeDataId","options","gpuResouorce","readToGPU","tmpTarget","customTexShape","tensorRef","makeTensorFromTensorInfo","t","strings","map","decodeString","d","i","length","num","canBeRepresented","downloadMatrixFromPackedTexture","subarray","shouldUsePackedProgram","outputShape","downloadByteEncodedFloatMatrixFromOutputTexture","f","oldActiveTimers","newActiveTimers","outerMostTime","programTimersStack","flattenedActiveTimerQueries","flatten","query","filter","flattenedActiveTimerNames","name","uploadWaitMs","kernelMs","wallMs","sum","ms","join","error","unreliable","numBytesInGPU","numBytesInGPUAllocated","numBytesAllocated","numBytesInGPUFree","numBytesFree","beginQuery","startMs","endMs","endQuery","waitForQueryAndGetTime","timerQuery","force","add","releaseGPUData","key","origDataId","dataRefCount","computeBytes","releaseTexture","uploadToGPU","inputs","sizeThreshold","every","condition","warn","condVals","dataSync","x","op","outInfo","compileAndRun","shouldExecuteOnCPU","outValues","makeOutput","packedUnaryOp","ABS","isString","encodedValues","encodeString","write","preventEagerUnpackingOutput","afterShape","input3DShape","getBatchDim","getRowsCols","input3D","afterShapeAs3D","preventEagerUnpackingOfOutput","customValues","texSize","assert","out","outputDtype","customUniformValues","outData","packedOutput","outPackingScheme","PackingScheme","DENSE","texelShape","outTexUsage","getTypedArrayFromDType","dataToDispose","inputsData","packedInputs","isUniform","uniformValues","unpackTensor","packTensor","isReshapeFree","savedInput","targetShape","packedReshape","outputData","makeShaderKey","binary","getAndSaveBinary","compileProgram","startTimer","runProgram","info","endTimer","constructor","getQueryTime","glFlushThreshold","time","lastGlFlushTime","flush","unpacked","getBinary","disposed","allKeys","Object","keys","deleteProgram","webGLProgram","dispose","HTMLCanvasElement","remove","floatPrecisionValue","debugFlag","underflowCheckValue","abs","floatPrecision","getTextureShapeFromLogicalShape","isByteArray","Uint8Array","Uint8ClampedArray","getPackedMatrixTextureShapeWidthHeight","tempDenseInputTexShape","tempDenseInputHandle","tempDenseInputTexData","PIXELS","uploadDenseMatrixToTexture","getTexture","preventEagerUnpacking","encodedOutputTarget","outputTexData","newTexture","acquireTexture","float32Values","float32ToTypedArray","texType","warnedAboutMemory","mb","toFixed","console","bytesPerElement","entries","checkCompletion_","parallelCompilationExtension","checkCompletionAsync_","p","getProgramParameter","COMPLETION_STATUS_KHR","LINK_STATUS","log","getProgramInfoLog","getShaderParameter","fragmentShader","COMPILE_STATUS","logShaderSourceAndInfoLog","source","getShaderInfoLog","uniformLocations","customUniformLocations","infLoc","nanLoc","inShapesLocations","inTexShapesLocations","outShapeLocation","outShapeStridesLocation","outTexShapeLocation","backend","isTexture","writeTexture","makeTensorFromDataId","a","Int32Array","Math","round"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-backend-webgl\\src\\backend_webgl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Import webgl flags.\nimport './flags_webgl';\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport {backend_util, BackendValues, buffer, DataId, DataStorage, DataToGPUWebGLOption, DataType, engine, env, GPUData, kernel_impls, KernelBackend, MemoryInfo, nextFrame, NumericDataType, Rank, RecursiveArray, scalar, ShapeMap, Tensor, Tensor2D, TensorBuffer, TensorInfo, tidy, TimingInfo, TypedArray, util, WebGLData} from '@tensorflow/tfjs-core';\nimport {getWebGLContext} from './canvas_util';\nimport {DecodeMatrixProgram} from './decode_matrix_gpu';\nimport {DecodeMatrixPackedProgram} from './decode_matrix_packed_gpu';\nimport {EncodeFloatProgram} from './encode_float_gpu';\nimport {EncodeFloatPackedProgram} from './encode_float_packed_gpu';\nimport {EncodeMatrixProgram} from './encode_matrix_gpu';\nimport {EncodeMatrixPackedProgram} from './encode_matrix_packed_gpu';\nimport {GPGPUContext} from './gpgpu_context';\nimport * as gpgpu_math from './gpgpu_math';\nimport {getUniformLocations, GPGPUBinary, GPGPUProgram, TensorData} from './gpgpu_math';\nimport {simpleAbsImplCPU} from './kernel_utils/shared';\nimport {PackProgram} from './pack_gpu';\nimport {ReshapePackedProgram} from './reshape_packed_gpu';\nimport * as tex_util from './tex_util';\nimport {Texture, TextureData, TextureUsage} from './tex_util';\nimport {TextureManager} from './texture_manager';\nimport * as unary_op from './unaryop_gpu';\nimport {UnaryOpProgram} from './unaryop_gpu';\nimport {UnaryOpPackedProgram} from './unaryop_packed_gpu';\nimport {UnpackProgram} from './unpack_gpu';\nimport * as webgl_util from './webgl_util';\n\nconst whereImpl = kernel_impls.whereImpl;\n\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\n\ntype KernelInfo = {\n  name: string; query: Promise<number>;\n};\n\nexport type TimerNode = RecursiveArray<KernelInfo>|KernelInfo;\nexport interface CPUTimerQuery {\n  startMs: number;\n  endMs?: number;\n}\n\nexport interface WebGLMemoryInfo extends MemoryInfo {\n  numBytesInGPU: number;\n  // Tracks the total number of bytes allocated on the GPU, accounting for the\n  // physical texture type.\n  numBytesInGPUAllocated: number;\n  // Tracks byte size of textures that were created and then made available for\n  // reuse (disposed).\n  numBytesInGPUFree: number;\n  unreliable: boolean;\n}\n\nexport interface WebGLTimingInfo extends TimingInfo {\n  uploadWaitMs: number;\n  downloadWaitMs: number;\n}\n\nconst binaryCaches: {[webGLVersion: string]: {[key: string]: GPGPUBinary}} = {};\n\nexport function getBinaryCache(webGLVersion: number) {\n  if (webGLVersion in binaryCaches) {\n    return binaryCaches[webGLVersion];\n  }\n  binaryCaches[webGLVersion] = {};\n  return binaryCaches[webGLVersion];\n}\n\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nconst CPU_HANDOFF_SIZE_THRESHOLD =\n    env().getNumber('CPU_HANDOFF_SIZE_THRESHOLD');\n\n// Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\nconst BEFORE_PAGING_CONSTANT = 600;\nfunction numMBBeforeWarning(): number {\n  if (env().global.screen == null) {\n    return 1024;  // 1 GB.\n  }\n  return (env().global.screen.height * env().global.screen.width *\n          window.devicePixelRatio) *\n      BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\n\nexport class MathBackendWebGL extends KernelBackend {\n  texData: DataStorage<TextureData>;\n  gpgpu: GPGPUContext;\n\n  private static nextDataId = 0;\n  private nextDataId(): number {\n    return MathBackendWebGL.nextDataId++;\n  }\n  // Maps data ids that have a pending read operation, to list of subscribers.\n  private pendingRead = new WeakMap<DataId, Array<(arr: TypedArray) => void>>();\n  // List of data ids that are scheduled for disposal, but are waiting on a\n  // pending read operation.\n  private pendingDisposal = new WeakSet<DataId>();\n\n  // Used to count the number of 'shallow' sliced tensors that point to the\n  // same data id.\n  dataRefCount = new WeakMap<DataId, number>();\n  private numBytesInGPU = 0;\n\n  private canvas: HTMLCanvasElement|OffscreenCanvas;\n\n  private programTimersStack: TimerNode[];\n  private activeTimers: TimerNode[];\n  // Accumulated time spent (including blocking) in uploading data to webgl.\n  private uploadWaitMs = 0;\n  // Accumulated time spent (including blocking in downloading data from webgl.\n  private downloadWaitMs = 0;\n\n  // record the last manual GL Flush time.\n  private lastGlFlushTime = 0;\n\n  // Number of bits of precision of this backend.\n  private floatPrecisionValue: 32|16;\n\n  private textureManager: TextureManager;\n  private binaryCache: {[key: string]: GPGPUBinary};\n  private gpgpuCreatedLocally: boolean;\n  private numMBBeforeWarning: number;\n  private warnedAboutMemory = false;\n\n  constructor(gpuResource?: GPGPUContext|HTMLCanvasElement|OffscreenCanvas) {\n    super();\n    if (!env().getBool('HAS_WEBGL')) {\n      throw new Error('WebGL is not supported on this device');\n    }\n\n    let newGPGPU;\n    if (gpuResource != null) {\n      if (gpuResource instanceof GPGPUContext) {\n        newGPGPU = gpuResource;\n      } else {\n        const gl =\n            getWebGLContext(env().getNumber('WEBGL_VERSION'), gpuResource);\n        newGPGPU = new GPGPUContext(gl);\n      }\n      this.binaryCache = {};\n      this.gpgpuCreatedLocally = false;\n    } else {\n      const gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));\n      newGPGPU = new GPGPUContext(gl);\n      this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));\n      this.gpgpuCreatedLocally = true;\n    }\n\n    this.gpgpu = newGPGPU;\n    this.canvas = this.gpgpu.gl.canvas;\n    this.textureManager = new TextureManager(this.gpgpu);\n    this.numMBBeforeWarning = numMBBeforeWarning();\n    this.texData = new DataStorage(this, engine());\n  }\n\n  override numDataIds() {\n    return this.texData.numDataIds() - this.pendingDeletes;\n  }\n\n  // Writes a new entry to the data store with a WebGL texture, and registers it\n  // to the texture manager.\n  writeTexture(\n      texture: WebGLTexture, shape: number[], dtype: DataType,\n      texHeight: number, texWidth: number, channels: string): DataId {\n    // Temporarily create an tensor info to make the texture compatible with\n    // the runWebGLProgram's input.\n    const input = this.makeTensorInfo(shape, dtype);\n    const inData = this.texData.get(input.dataId);\n    // Even though the input texture could be unpacked or dense packed, it is\n    // always considered as unpacked for EncodeMatrixProgram.\n    inData.isPacked = false;\n\n    // Bind texture to the input tensor.\n    inData.texture = {texture, texShape: [texHeight, texWidth]};\n    inData.texShape = [texHeight, texWidth];\n\n    const shapeAs3D = webgl_util.getShapeAs3D(shape);\n    const program =\n        new EncodeMatrixProgram(shapeAs3D, false /* isByteArray */, channels);\n    const output =\n        this.runWebGLProgram(program, [input], dtype, [[texHeight, texWidth]]);\n    output.shape = shape;\n\n    // Unbind the texture from the input tensor to avoid the texture being\n    // released.\n    inData.texture = null;\n    this.disposeIntermediateTensorInfo(input);\n\n    return output.dataId;\n  }\n\n  override write(values: BackendValues, shape: number[], dtype: DataType):\n      DataId {\n    if (env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') ||\n        env().getBool('DEBUG')) {\n      this.checkNumericalProblems(values);\n    }\n    if (dtype === 'complex64' && values != null) {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    const dataId = {id: this.nextDataId()};\n    this.texData.set(\n        dataId,\n        {shape, dtype, values, usage: TextureUsage.UPLOAD, refCount: 1});\n    return dataId;\n  }\n\n  /** Return refCount of a `TensorData`. */\n  override refCount(dataId: DataId): number {\n    if (this.texData.has(dataId)) {\n      const tensorData = this.texData.get(dataId);\n      return tensorData.refCount;\n    }\n    return 0;\n  }\n\n  /** Increase refCount of a `TextureData`. */\n  override incRef(dataId: DataId): void {\n    const texData = this.texData.get(dataId);\n    texData.refCount++;\n  }\n\n  /** Decrease refCount of a `TextureData`. */\n  decRef(dataId: DataId): void {\n    if (this.texData.has(dataId)) {\n      const texData = this.texData.get(dataId);\n      texData.refCount--;\n    }\n  }\n\n  override move(\n      dataId: DataId, values: BackendValues, shape: number[], dtype: DataType,\n      refCount: number): void {\n    if (env().getBool('DEBUG')) {\n      this.checkNumericalProblems(values);\n    }\n    if (dtype === 'complex64') {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    this.texData.set(\n        dataId, {shape, dtype, values, usage: TextureUsage.UPLOAD, refCount});\n  }\n\n  disposeIntermediateTensorInfo(tensorInfo: TensorInfo): void {\n    this.disposeData(tensorInfo.dataId);\n  }\n\n  override readSync(dataId: DataId): BackendValues {\n    const texData = this.texData.get(dataId);\n    const {values, dtype, complexTensorInfos, slice, shape, isPacked} = texData;\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const data = this.readSync(res.dataId);\n      this.disposeIntermediateTensorInfo(res);\n      return data;\n    }\n    if (values != null) {\n      return this.convertAndCacheOnCPU(dataId);\n    }\n    if (dtype === 'string') {\n      return values;\n    }\n    const shouldTimeProgram = this.activeTimers != null;\n    let start: number;\n    if (shouldTimeProgram) {\n      start = util.now();\n    }\n\n    let result: Float32Array;\n    if (dtype === 'complex64') {\n      const realValues =\n          this.readSync(complexTensorInfos.real.dataId) as Float32Array;\n      const imagValues =\n          this.readSync(complexTensorInfos.imag.dataId) as Float32Array;\n      result = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    } else {\n      result = this.getValuesFromTexture(dataId);\n    }\n\n    if (shouldTimeProgram) {\n      this.downloadWaitMs += util.now() - start;\n    }\n    return this.convertAndCacheOnCPU(dataId, result);\n  }\n\n  override async read(dataId: DataId): Promise<BackendValues> {\n    if (this.pendingRead.has(dataId)) {\n      const subscribers = this.pendingRead.get(dataId);\n      return new Promise<TypedArray>(resolve => subscribers.push(resolve));\n    }\n    const texData = this.texData.get(dataId);\n    const {values, shape, slice, dtype, complexTensorInfos, isPacked} = texData;\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const data = this.read(res.dataId);\n      this.disposeIntermediateTensorInfo(res);\n      return data;\n    }\n\n    if (values != null) {\n      return this.convertAndCacheOnCPU(dataId);\n    }\n\n    if (env().getBool('DEBUG')) {\n      // getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') caused a blocking GPU call.\n      // For performance reason, only check it for debugging. In production,\n      // it doesn't handle this use case anyway, so behavior is not changed.\n      if (!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&\n          env().getNumber('WEBGL_VERSION') === 2) {\n        throw new Error(\n            `tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` +\n            `WEBGL_VERSION=2 not yet supported.`);\n      }\n    }\n\n    let buffer: WebGLBuffer = null;\n    let tmpDownloadTarget: TensorInfo;\n\n    if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {\n      // Possibly copy the texture into a buffer before inserting a fence.\n      tmpDownloadTarget = this.decode(dataId);\n      const tmpData = this.texData.get(tmpDownloadTarget.dataId);\n\n      buffer = this.gpgpu.createBufferFromTexture(\n          tmpData.texture.texture, ...tex_util.getDenseTexShape(shape));\n    }\n\n    this.pendingRead.set(dataId, []);\n\n    if (dtype !== 'complex64') {\n      // Create a fence and wait for it to resolve.\n      await this.gpgpu.createAndWaitForFence();\n    }\n\n    // Download the values from the GPU.\n    let vals: Float32Array;\n    if (dtype === 'complex64') {\n      const ps = await Promise.all([\n        this.read(complexTensorInfos.real.dataId),\n        this.read(complexTensorInfos.imag.dataId)\n      ]);\n\n      const realValues = ps[0];\n      const imagValues = ps[1];\n      vals = backend_util.mergeRealAndImagArrays(\n          realValues as Float32Array, imagValues as Float32Array);\n    } else if (buffer == null) {\n      vals = this.getValuesFromTexture(dataId);\n    } else {\n      const size = util.sizeFromShape(shape);\n      vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n    }\n    if (tmpDownloadTarget != null) {\n      this.disposeIntermediateTensorInfo(tmpDownloadTarget);\n    }\n    if (buffer != null) {\n      const gl = this.gpgpu.gl;\n      webgl_util.callAndCheck(gl, () => gl.deleteBuffer(buffer));\n    }\n    const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n\n    const subscribers = this.pendingRead.get(dataId);\n    this.pendingRead.delete(dataId);\n\n    // Notify all pending reads.\n    subscribers.forEach(resolve => resolve(dTypeVals));\n    if (this.pendingDisposal.has(dataId)) {\n      this.pendingDisposal.delete(dataId);\n      if (this.disposeData(dataId)) {\n        engine().removeDataId(dataId, this);\n      }\n      this.pendingDeletes--;\n    }\n    return dTypeVals;\n  }\n\n  /**\n   * Read tensor to a new texture that is densely packed for ease of use.\n   * @param dataId The source tensor.\n   * @param options\n   *     customTexShape: Optional. If set, will use the user defined texture\n   *     shape to create the texture.\n   */\n  override readToGPU(dataId: DataId, options: DataToGPUWebGLOption = {}):\n      GPUData {\n    const texData = this.texData.get(dataId);\n    const {values, shape, slice, dtype, isPacked, texture} = texData;\n\n    if (dtype === 'complex64') {\n      throw new Error('Does not support reading texture for complex64 dtype.');\n    }\n\n    // The presence of `slice` indicates this tensor is a shallow slice of a\n    // different tensor, and is using that original tensor's texture. Run\n    // `clone` in order to copy that texture and read from it.\n    if (slice != null) {\n      let program;\n      if (isPacked) {\n        program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n      } else {\n        program = new UnaryOpProgram(shape, unary_op.CLONE);\n      }\n      const res =\n          this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);\n      const gpuResouorce = this.readToGPU(res, options);\n      this.disposeIntermediateTensorInfo(res);\n      return gpuResouorce;\n    }\n\n    if (texture == null) {\n      if (values != null) {\n        throw new Error('Data is not on GPU but on CPU.');\n      } else {\n        throw new Error('There is no data on GPU or CPU.');\n      }\n    }\n\n    // Decode the texture so that it is stored densely (using four channels).\n    const tmpTarget = this.decode(dataId, options.customTexShape);\n\n    // Make engine track this tensor, so that we can dispose it later.\n    const tensorRef = engine().makeTensorFromTensorInfo(tmpTarget);\n\n    const tmpData = this.texData.get(tmpTarget.dataId);\n    return {tensorRef, ...tmpData.texture};\n  }\n\n  bufferSync<R extends Rank, D extends DataType>(t: TensorInfo):\n      TensorBuffer<R, D> {\n    const data = this.readSync(t.dataId);\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        const strings = (data as Uint8Array[]).map(d => util.decodeString(d));\n        return buffer(t.shape as ShapeMap[R], t.dtype, strings) as\n            TensorBuffer<R, D>;\n      } catch {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n    return buffer(t.shape as ShapeMap[R], t.dtype, data as TypedArray) as\n        TensorBuffer<R, D>;\n  }\n\n  private checkNumericalProblems(values: BackendValues): void {\n    if (values == null) {\n      return;\n    }\n    for (let i = 0; i < values.length; i++) {\n      const num = values[i] as number;\n      if (!webgl_util.canBeRepresented(num)) {\n        if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n          throw Error(\n              `The value ${num} cannot be represented with your ` +\n              `current settings. Consider enabling float32 rendering: ` +\n              `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);\n        }\n        throw Error(`The value ${num} cannot be represented on this device.`);\n      }\n    }\n  }\n\n  private getValuesFromTexture(dataId: DataId): Float32Array {\n    const {shape, dtype, isPacked} = this.texData.get(dataId);\n    const size = util.sizeFromShape(shape);\n    if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n      const tmpTarget = this.decode(dataId);\n      const tmpData = this.texData.get(tmpTarget.dataId);\n      const vals =\n          this.gpgpu\n              .downloadMatrixFromPackedTexture(\n                  tmpData.texture.texture, ...tex_util.getDenseTexShape(shape))\n              .subarray(0, size);\n\n      this.disposeIntermediateTensorInfo(tmpTarget);\n\n      return vals;\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK') && isPacked === true;\n    const outputShape =\n        shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;\n    const program = shouldUsePackedProgram ?\n        new EncodeFloatPackedProgram(outputShape as [number, number, number]) :\n        new EncodeFloatProgram(outputShape);\n    const output = this.runWebGLProgram(\n        program, [{shape: outputShape, dtype, dataId}], 'float32');\n    const tmpData = this.texData.get(output.dataId);\n    const vals = this.gpgpu\n                     .downloadByteEncodedFloatMatrixFromOutputTexture(\n                         tmpData.texture.texture, tmpData.texShape[0],\n                         tmpData.texShape[1])\n                     .subarray(0, size);\n    this.disposeIntermediateTensorInfo(output);\n\n    return vals;\n  }\n\n  override timerAvailable(): boolean {\n    return env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0;\n  }\n\n  override time(f: () => void): Promise<WebGLTimingInfo> {\n    const oldActiveTimers = this.activeTimers;\n    const newActiveTimers: TimerNode[] = [];\n\n    let outerMostTime = false;\n    if (this.programTimersStack == null) {\n      this.programTimersStack = newActiveTimers;\n      outerMostTime = true;\n    } else {\n      this.activeTimers.push(newActiveTimers);\n    }\n    this.activeTimers = newActiveTimers;\n\n    f();\n\n    // needing to split these up because util.flatten only accepts certain types\n    const flattenedActiveTimerQueries =\n        util.flatten(this.activeTimers.map((d: KernelInfo) => d.query))\n            .filter(d => d != null);\n    const flattenedActiveTimerNames =\n        util.flatten(this.activeTimers.map((d: KernelInfo) => d.name))\n            .filter(d => d != null);\n\n    this.activeTimers = oldActiveTimers;\n\n    if (outerMostTime) {\n      this.programTimersStack = null;\n    }\n\n    const res: WebGLTimingInfo = {\n      uploadWaitMs: this.uploadWaitMs,\n      downloadWaitMs: this.downloadWaitMs,\n      kernelMs: null,\n      wallMs: null  // will be filled by the engine\n    };\n\n    return (async () => {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') >\n          0) {\n        const kernelMs = await Promise.all(flattenedActiveTimerQueries);\n\n        res['kernelMs'] = util.sum(kernelMs);\n        res['getExtraProfileInfo'] = () =>\n            kernelMs\n                .map((d, i) => ({name: flattenedActiveTimerNames[i], ms: d}))\n                .map(d => `${d.name}: ${d.ms}`)\n                .join(', ');\n      } else {\n        res['kernelMs'] = {\n          error: 'WebGL query timers are not supported in this environment.'\n        };\n      }\n\n      this.uploadWaitMs = 0;\n      this.downloadWaitMs = 0;\n      return res;\n    })();\n  }\n  override memory(): WebGLMemoryInfo {\n    return {\n      unreliable: false,\n      numBytesInGPU: this.numBytesInGPU,\n      numBytesInGPUAllocated: this.textureManager.numBytesAllocated,\n      numBytesInGPUFree: this.textureManager.numBytesFree\n    } as WebGLMemoryInfo;\n  }\n\n  private startTimer(): WebGLQuery|CPUTimerQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      return this.gpgpu.beginQuery();\n    }\n    return {startMs: util.now(), endMs: null};\n  }\n\n  private endTimer(query: WebGLQuery|CPUTimerQuery): WebGLQuery|CPUTimerQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      this.gpgpu.endQuery();\n      return query;\n    }\n    (query as CPUTimerQuery).endMs = util.now();\n    return query;\n  }\n\n  private async getQueryTime(query: WebGLQuery|CPUTimerQuery): Promise<number> {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n      return this.gpgpu.waitForQueryAndGetTime(query as WebGLQuery);\n    }\n    const timerQuery = query as CPUTimerQuery;\n    return timerQuery.endMs - timerQuery.startMs;\n  }\n\n  private pendingDeletes = 0;\n\n  /**\n   * Decrease the RefCount on the dataId and dispose the memory if the dataId\n   * has 0 refCount. If there are pending read on the data, the disposal would\n   * added to the pending delete queue. Return true if the dataId is removed\n   * from backend or the backend does not contain the dataId, false if the\n   * dataId is not removed. Memory may or may not be released even when dataId\n   * is removed, which also depends on dataRefCount, see `releaseGPU`.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n  override disposeData(dataId: DataId, force = false): boolean {\n    if (this.pendingDisposal.has(dataId)) {\n      return false;\n    }\n\n    // No-op if already disposed.\n    if (!this.texData.has(dataId)) {\n      return true;\n    }\n\n    // if force flag is set, change refCount to 0, this would ensure disposal\n    // when added to the pendingDisposal queue. Memory may or may not be\n    // released, which also depends on dataRefCount, see `releaseGPU`.\n    if (force) {\n      this.texData.get(dataId).refCount = 0;\n    } else {\n      this.texData.get(dataId).refCount--;\n    }\n\n    if (!force && this.texData.get(dataId).refCount > 0) {\n      return false;\n    }\n\n    if (this.pendingRead.has(dataId)) {\n      this.pendingDisposal.add(dataId);\n      this.pendingDeletes++;\n      return false;\n    }\n\n    this.releaseGPUData(dataId);\n    const {complexTensorInfos} = this.texData.get(dataId);\n    if (complexTensorInfos != null) {\n      this.disposeData(complexTensorInfos.real.dataId, force);\n      this.disposeData(complexTensorInfos.imag.dataId, force);\n    }\n\n    this.texData.delete(dataId);\n\n    return true;\n  }\n\n  private releaseGPUData(dataId: DataId): void {\n    const {texture, dtype, texShape, usage, isPacked, slice} =\n        this.texData.get(dataId);\n    const key = slice && slice.origDataId || dataId;\n    const refCount = this.dataRefCount.get(key);\n\n    if (refCount > 1) {\n      this.dataRefCount.set(key, refCount - 1);\n    } else {\n      this.dataRefCount.delete(key);\n      if (texture != null) {\n        this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n        this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n      }\n    }\n\n    const texData = this.texData.get(dataId);\n    texData.texture = null;\n    texData.texShape = null;\n    texData.isPacked = false;\n    texData.slice = null;\n  }\n\n  getTexture(dataId: DataId): WebGLTexture {\n    this.uploadToGPU(dataId);\n    return this.texData.get(dataId).texture.texture;\n  }\n\n  /**\n   * Returns internal information for the specific data bucket. Used in unit\n   * tests.\n   */\n  getDataInfo(dataId: DataId): TextureData {\n    return this.texData.get(dataId);\n  }\n\n  /*\n  Tests whether all the inputs to an op are small and on the CPU. This heuristic\n  determines when it would be faster to execute a kernel on the CPU. WebGL\n  kernels opt into running this check and forwarding when appropriate.\n  TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n  sustainable strategy for optimizing backend execution of ops.\n   */\n  shouldExecuteOnCPU(\n      inputs: TensorInfo[],\n      sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD): boolean {\n    return env().getBool('WEBGL_CPU_FORWARD') &&\n        inputs.every(\n            input => this.texData.get(input.dataId).texture == null &&\n                util.sizeFromShape(input.shape) < sizeThreshold);\n  }\n\n  getGPGPUContext(): GPGPUContext {\n    return this.gpgpu;\n  }\n\n  where(condition: Tensor): Tensor2D {\n    backend_util.warn(\n        'tf.where() in webgl locks the UI thread. ' +\n        'Call tf.whereAsync() instead');\n    const condVals = condition.dataSync();\n    return whereImpl(condition.shape, condVals);\n  }\n\n  private packedUnaryOp(x: TensorInfo, op: string, dtype: DataType) {\n    const program = new UnaryOpPackedProgram(x.shape, op);\n    const outInfo = this.compileAndRun(program, [x], dtype);\n    return engine().makeTensorFromTensorInfo(outInfo);\n  }\n\n  // TODO(msoulanille) remove this once the backend has been modularized\n  // a copy is needed here to break a circular dependency.\n  // Also remove the op from unary_op.\n  abs<T extends Tensor>(x: T): T {\n    // TODO: handle cases when x is complex.\n    if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n      const outValues =\n          simpleAbsImplCPU(this.texData.get(x.dataId).values as TypedArray);\n      return this.makeOutput(x.shape, x.dtype, outValues);\n    }\n\n    if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n      return this.packedUnaryOp(x, unary_op.ABS, x.dtype) as T;\n    }\n\n    const program = new UnaryOpProgram(x.shape, unary_op.ABS);\n    const outInfo = this.compileAndRun(program, [x]);\n    return engine().makeTensorFromTensorInfo(outInfo) as T;\n  }\n\n  makeTensorInfo(\n      shape: number[], dtype: DataType,\n      values?: BackendValues|string[]): TensorInfo {\n    let dataId;\n    if (dtype === 'string' && values != null && values.length > 0 &&\n        util.isString(values[0])) {\n      const encodedValues =\n          (values as unknown as string[]).map(d => util.encodeString(d));\n\n      dataId = this.write(encodedValues, shape, dtype);\n    } else {\n      dataId = this.write(values as TypedArray, shape, dtype);\n    }\n\n    this.texData.get(dataId).usage = null;\n    return {dataId, shape, dtype};\n  }\n\n  private makeOutput<T extends Tensor>(\n      shape: number[], dtype: DataType, values?: BackendValues): T {\n    return engine().makeTensorFromTensorInfo(\n               this.makeTensorInfo(shape, dtype, values), this) as T;\n  }\n\n  unpackTensor(input: TensorInfo): TensorInfo {\n    const program = new UnpackProgram(input.shape);\n    return this.runWebGLProgram(program, [input], input.dtype);\n  }\n\n  packTensor(input: TensorInfo): TensorInfo {\n    const program = new PackProgram(input.shape);\n    const preventEagerUnpackingOutput = true;\n    return this.runWebGLProgram(\n        program, [input], input.dtype, null /* customUniformValues */,\n        preventEagerUnpackingOutput);\n  }\n\n  private packedReshape(input: TensorInfo, afterShape: number[]): TensorInfo {\n    const input3DShape = [\n      webgl_util.getBatchDim(input.shape),\n      ...webgl_util.getRowsCols(input.shape)\n    ] as [number, number, number];\n    const input3D: TensorInfo = {\n      dtype: input.dtype,\n      shape: input3DShape,\n      dataId: input.dataId\n    };\n    const afterShapeAs3D = [\n      webgl_util.getBatchDim(afterShape), ...webgl_util.getRowsCols(afterShape)\n    ] as [number, number, number];\n\n    const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n    const preventEagerUnpackingOfOutput = true;\n    const customValues = [input3DShape];\n    const output = this.runWebGLProgram(\n        program, [input3D], input.dtype, customValues,\n        preventEagerUnpackingOfOutput);\n    return {dataId: output.dataId, shape: afterShape, dtype: output.dtype};\n  }\n\n  private decode(dataId: DataId, customTexShape?: [number, number]):\n      TensorInfo {\n    const texData = this.texData.get(dataId);\n    const {isPacked, shape, dtype} = texData;\n    if (customTexShape != null) {\n      const size = util.sizeFromShape(shape);\n      const texSize = customTexShape[0] * customTexShape[1] * 4;\n      util.assert(\n          size <= texSize,\n          () => 'customTexShape is too small. ' +\n              'Row * Column * 4 should be equal or larger than the ' +\n              'size of the tensor data.');\n    }\n    const shapeAs3D =\n        webgl_util.getShapeAs3D(shape) as [number, number, number];\n    let program;\n    if (isPacked) {\n      program = new DecodeMatrixPackedProgram(shapeAs3D);\n    } else {\n      program = new DecodeMatrixProgram(shapeAs3D);\n    }\n    const preventEagerUnpackingOfOutput = true;\n    const customValues =\n        [customTexShape != null ? customTexShape :\n                                  tex_util.getDenseTexShape(shapeAs3D)];\n    const out = this.runWebGLProgram(\n        program, [{shape: shapeAs3D, dtype, dataId}], dtype, customValues,\n        preventEagerUnpackingOfOutput, customTexShape);\n    return {dtype, shape, dataId: out.dataId};\n  }\n\n  runWebGLProgram(\n      program: GPGPUProgram, inputs: TensorInfo[], outputDtype: DataType,\n      customUniformValues?: number[][], preventEagerUnpackingOfOutput = false,\n      customTexShape?: [number, number]): TensorInfo {\n    const output = this.makeTensorInfo(program.outputShape, outputDtype);\n    const outData = this.texData.get(output.dataId);\n    if (program.packedOutput) {\n      outData.isPacked = true;\n    }\n    if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {\n      const texelShape = customTexShape != null ?\n          customTexShape :\n          tex_util.getDenseTexShape(program.outputShape);\n      // For a densely packed output, we explicitly set texShape\n      // so it doesn't get assigned later according to our typical packing\n      // scheme wherein a single texel can only contain values from adjacent\n      // rows/cols.\n      outData.texShape = texelShape.map(d => d * 2) as [number, number];\n    }\n    if (program.outTexUsage != null) {\n      outData.usage = program.outTexUsage;\n    }\n\n    if (util.sizeFromShape(output.shape) === 0) {\n      // Short-circuit the computation since the result is empty (has 0 in its\n      // shape).\n      outData.values =\n          util.getTypedArrayFromDType(output.dtype as 'float32', 0);\n      return output;\n    }\n\n    const dataToDispose: TensorInfo[] = [];\n    const inputsData: TensorData[] = inputs.map(input => {\n      if (input.dtype === 'complex64') {\n        throw new Error(\n            `GPGPUProgram does not support complex64 input. For complex64 ` +\n            `dtypes, please separate the program into real and imaginary ` +\n            `parts.`);\n      }\n\n      let texData = this.texData.get(input.dataId);\n\n      if (texData.texture == null) {\n        if (!program.packedInputs &&\n            util.sizeFromShape(input.shape) <=\n                env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n          // Upload small tensors that live on the CPU as uniforms, not as\n          // textures. Do this only when the environment supports 32bit floats\n          // due to problems when comparing 16bit floats with 32bit floats.\n          // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n          // possible for packed shaders to sample from uniforms.\n          return {\n            shape: input.shape,\n            texData: null,\n            isUniform: true,\n            uniformValues: texData.values as TypedArray\n          };\n        }\n\n        // This ensures that if a packed program's inputs have not yet been\n        // uploaded to the GPU, they get uploaded as packed right off the bat.\n        if (program.packedInputs) {\n          texData.isPacked = true;\n          texData.shape = input.shape;\n        }\n      }\n\n      this.uploadToGPU(input.dataId);\n      if (!!texData.isPacked !== !!program.packedInputs) {\n        input = texData.isPacked ? this.unpackTensor(input) :\n                                   this.packTensor(input);\n        dataToDispose.push(input);\n        texData = this.texData.get(input.dataId);\n      } else if (\n          texData.isPacked &&\n          !webgl_util.isReshapeFree(texData.shape, input.shape)) {\n        // This is a special case where a texture exists for a tensor\n        // but the shapes are incompatible (due to packing constraints) because\n        // the tensor did not have a chance to go through the packed reshape\n        // shader. This only happens when we reshape the *same* tensor to form\n        // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n        // case will disappear once packed uploading is the default.\n\n        const savedInput = input;\n        const targetShape = input.shape;\n\n        input.shape = texData.shape;\n        input = this.packedReshape(input as Tensor, targetShape);\n        dataToDispose.push(input);\n        texData = this.texData.get(input.dataId);\n\n        savedInput.shape = targetShape;\n      }\n\n      return {shape: input.shape, texData, isUniform: false};\n    });\n\n    this.uploadToGPU(output.dataId);\n    const outputData:\n        TensorData = {shape: output.shape, texData: outData, isUniform: false};\n    const key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n    const binary = this.getAndSaveBinary(key, () => {\n      return gpgpu_math.compileProgram(\n          this.gpgpu, program, inputsData, outputData);\n    });\n    const shouldTimeProgram = this.activeTimers != null;\n    let query: WebGLQuery|CPUTimerQuery;\n    if (shouldTimeProgram) {\n      query = this.startTimer();\n    }\n\n    if (!env().get('ENGINE_COMPILE_ONLY')) {\n      gpgpu_math.runProgram(\n          this.gpgpu, binary, inputsData, outputData, customUniformValues);\n    }\n\n    dataToDispose.forEach(info => this.disposeIntermediateTensorInfo(info));\n\n    if (shouldTimeProgram) {\n      query = this.endTimer(query);\n      this.activeTimers.push(\n          {name: program.constructor.name, query: this.getQueryTime(query)});\n    }\n\n    const glFlushThreshold = env().get('WEBGL_FLUSH_THRESHOLD');\n    // Manually GL flush requested\n    if (glFlushThreshold > 0) {\n      const time = util.now();\n      if ((time - this.lastGlFlushTime) > glFlushThreshold) {\n        this.gpgpu.gl.flush();\n        this.lastGlFlushTime = time;\n      }\n    }\n\n    if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked &&\n        preventEagerUnpackingOfOutput === false) {\n      const unpacked = this.unpackTensor(output);\n      this.disposeIntermediateTensorInfo(output);\n      return unpacked;\n    }\n    return output;\n  }\n\n  compileAndRun(\n      program: GPGPUProgram, inputs: TensorInfo[], outputDtype?: DataType,\n      customUniformValues?: number[][],\n      preventEagerUnpackingOfOutput = false): TensorInfo {\n    outputDtype = outputDtype || inputs[0].dtype;\n    const outInfo = this.runWebGLProgram(\n        program, inputs, outputDtype, customUniformValues,\n        preventEagerUnpackingOfOutput);\n    return outInfo;\n  }\n\n  private getAndSaveBinary(key: string, getBinary: () => GPGPUBinary):\n      GPGPUBinary {\n    if (!(key in this.binaryCache)) {\n      this.binaryCache[key] = getBinary();\n    }\n    return this.binaryCache[key];\n  }\n\n  getTextureManager(): TextureManager {\n    return this.textureManager;\n  }\n\n  private disposed = false;\n\n  override dispose() {\n    if (this.disposed) {\n      return;\n    }\n    // Avoid disposing the compiled webgl programs during unit testing because\n    // it slows down test execution.\n    if (!env().getBool('IS_TEST')) {\n      const allKeys = Object.keys(this.binaryCache);\n      allKeys.forEach(key => {\n        this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);\n        delete this.binaryCache[key];\n      });\n    }\n    this.textureManager.dispose();\n    if (this.canvas != null &&\n        (typeof (HTMLCanvasElement) !== 'undefined' &&\n         this.canvas instanceof HTMLCanvasElement)) {\n      this.canvas.remove();\n    } else {\n      this.canvas = null;\n    }\n    if (this.gpgpuCreatedLocally) {\n      this.gpgpu.program = null;\n      this.gpgpu.dispose();\n    }\n    this.disposed = true;\n  }\n\n  override floatPrecision(): 16|32 {\n    if (this.floatPrecisionValue == null) {\n      this.floatPrecisionValue = tidy(() => {\n        if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n          // Momentarily switching DEBUG flag to false so we don't throw an\n          // error trying to upload a small value.\n          const debugFlag = env().getBool('DEBUG');\n          env().set('DEBUG', false);\n          const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];\n          env().set('DEBUG', debugFlag);\n\n          if (underflowCheckValue > 0) {\n            return 32;\n          }\n        }\n        return 16;\n      });\n    }\n    return this.floatPrecisionValue;\n  }\n\n  /** Returns the smallest representable number.  */\n  override epsilon(): number {\n    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n  }\n\n  uploadToGPU(dataId: DataId): void {\n    const texData = this.texData.get(dataId);\n    const {shape, dtype, values, texture, usage, isPacked} = texData;\n\n    if (texture != null) {\n      // Array is already on GPU. No-op.\n      return;\n    }\n    const shouldTimeProgram = this.activeTimers != null;\n    let start: number;\n    if (shouldTimeProgram) {\n      start = util.now();\n    }\n\n    let texShape = texData.texShape;\n    if (texShape == null) {\n      // This texShape may not be the final texture shape. For packed or dense\n      // textures, the texShape will be changed when textures are created.\n      texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);\n      texData.texShape = texShape;\n    }\n\n    if (values != null) {\n      const shapeAs3D = webgl_util.getShapeAs3D(shape);\n\n      let program;\n      let width = texShape[1], height = texShape[0];\n      const isByteArray =\n          values instanceof Uint8Array || values instanceof Uint8ClampedArray;\n\n      // texture for float array is PhysicalTextureType.PACKED_2X2_FLOAT32, we\n      // need to make sure the upload uses the same packed size\n      if (isPacked || !isByteArray) {\n        [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(\n            texShape[0], texShape[1]);\n      }\n\n      if (isPacked) {\n        program = new EncodeMatrixPackedProgram(shapeAs3D, isByteArray);\n      } else {\n        program = new EncodeMatrixProgram(shapeAs3D, isByteArray);\n      }\n\n      // TexShape for float array needs to be the original shape, which byte\n      // array needs to be packed size. This allow the data upload shape to be\n      // matched with texture creation logic.\n      const tempDenseInputTexShape: [number, number] =\n          isByteArray ? [height, width] : texShape;\n      const tempDenseInputHandle =\n          this.makeTensorInfo(tempDenseInputTexShape, dtype);\n      const tempDenseInputTexData =\n          this.texData.get(tempDenseInputHandle.dataId);\n      if (isByteArray) {\n        tempDenseInputTexData.usage = TextureUsage.PIXELS;\n      } else {\n        tempDenseInputTexData.usage = TextureUsage.UPLOAD;\n      }\n      tempDenseInputTexData.texShape = tempDenseInputTexShape;\n      this.gpgpu.uploadDenseMatrixToTexture(\n          this.getTexture(tempDenseInputHandle.dataId), width, height,\n          values as TypedArray);\n\n      const customValues = [[height, width]];\n      // We want the output to remain packed regardless of the value of\n      // WEBGL_PACK.\n      const preventEagerUnpacking = true;\n      const encodedOutputTarget = this.runWebGLProgram(\n          program, [tempDenseInputHandle], dtype, customValues,\n          preventEagerUnpacking);\n\n      // Have the original texture assume the identity of the encoded output.\n      const outputTexData = this.texData.get(encodedOutputTarget.dataId);\n      texData.texShape = outputTexData.texShape;\n      texData.isPacked = outputTexData.isPacked;\n      texData.usage = outputTexData.usage;\n\n      if (!env().get('ENGINE_COMPILE_ONLY')) {\n        texData.texture = outputTexData.texture;\n        // Once uploaded, don't store the values on cpu.\n        texData.values = null;\n        this.texData.delete(encodedOutputTarget.dataId);\n      } else {\n        this.disposeData(encodedOutputTarget.dataId);\n      }\n\n      this.disposeIntermediateTensorInfo(tempDenseInputHandle);\n\n      if (shouldTimeProgram) {\n        this.uploadWaitMs += util.now() - start;\n      }\n    } else {\n      const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n      texData.texture = newTexture;\n    }\n  }\n\n  private convertAndCacheOnCPU(dataId: DataId, float32Values?: Float32Array):\n      TypedArray {\n    const texData = this.texData.get(dataId);\n    const {dtype} = texData;\n\n    if (float32Values != null) {\n      texData.values = float32ToTypedArray(float32Values, dtype as 'float32');\n    }\n    return texData.values as TypedArray;\n  }\n\n  private acquireTexture(\n      texShape: [number, number], texType: TextureUsage, dtype: DataType,\n      isPacked: boolean): Texture {\n    this.numBytesInGPU += this.computeBytes(texShape, dtype);\n    if (!this.warnedAboutMemory &&\n        this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n      const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n      this.warnedAboutMemory = true;\n      console.warn(\n          `High memory usage in GPU: ${mb} MB, ` +\n          `most likely due to a memory leak`);\n    }\n    return this.textureManager.acquireTexture(texShape, texType, isPacked);\n  }\n\n  private computeBytes(shape: [number, number], dtype: DataType) {\n    return shape[0] * shape[1] * util.bytesPerElement(dtype);\n  }\n\n  checkCompileCompletion() {\n    for (const [, binary] of Object.entries(this.binaryCache)) {\n      this.checkCompletion_(binary);\n    }\n  }\n\n  async checkCompileCompletionAsync(): Promise<boolean[]> {\n    const ps = [];\n    if (this.gpgpu.parallelCompilationExtension) {\n      for (const [, binary] of Object.entries(this.binaryCache)) {\n        ps.push(this.checkCompletionAsync_(binary));\n      }\n      return Promise.all(ps);\n    } else {\n      for (const [, binary] of Object.entries(this.binaryCache)) {\n        const p: Promise<boolean> = new Promise((resolve) => {\n          try {\n            this.checkCompletion_(binary);\n            resolve(true);\n          } catch (error) {\n            throw error;\n          }\n        });\n        ps.push(p);\n      }\n      return Promise.all(ps);\n    }\n  }\n\n  private async checkCompletionAsync_(binary: GPGPUBinary): Promise<boolean> {\n    if (this.gpgpu.gl.getProgramParameter(\n            binary.webGLProgram,\n            this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) {\n      return this.checkCompletion_(binary);\n    } else {\n      await nextFrame();\n      return this.checkCompletionAsync_(binary);\n    }\n  }\n\n  private checkCompletion_(binary: GPGPUBinary): boolean {\n    if (this.gpgpu.gl.getProgramParameter(\n            binary.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) {\n      console.log(this.gpgpu.gl.getProgramInfoLog(binary.webGLProgram));\n      if (this.gpgpu.gl.getShaderParameter(\n              binary.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false) {\n        webgl_util.logShaderSourceAndInfoLog(\n            binary.source,\n            this.gpgpu.gl.getShaderInfoLog(binary.fragmentShader));\n        throw new Error('Failed to compile fragment shader.');\n      }\n      throw new Error('Failed to link vertex and fragment shaders.');\n    }\n    return true;\n  }\n\n  getUniformLocations() {\n    for (const [, binary] of Object.entries(this.binaryCache)) {\n      const {\n        uniformLocations,\n        customUniformLocations,\n        infLoc,\n        nanLoc,\n        inShapesLocations,\n        inTexShapesLocations,\n        outShapeLocation,\n        outShapeStridesLocation,\n        outTexShapeLocation\n      } = getUniformLocations(this.gpgpu, binary.program, binary.webGLProgram);\n      binary.uniformLocations = uniformLocations;\n      binary.customUniformLocations = customUniformLocations;\n      binary.infLoc = infLoc;\n      binary.nanLoc = nanLoc;\n      binary.inShapesLocations = inShapesLocations;\n      binary.inTexShapesLocations = inTexShapesLocations;\n      binary.outShapeLocation = outShapeLocation;\n      binary.outShapeStridesLocation = outShapeStridesLocation;\n      binary.outTexShapeLocation = outTexShapeLocation;\n    }\n  }\n\n  /**\n   * Create a TF.js tensor out of an existing WebGL texture. A new texture will\n   * be created.\n   */\n  override createTensorFromGPUData(\n      values: WebGLData, shape: number[], dtype: DataType): Tensor {\n    values.channels = values.channels || 'RGBA';\n    const {texture, height, width, channels} = values;\n    const backend = engine().backend as MathBackendWebGL;\n\n    // Have to throw an error, otherwise WebGL just warns and returns wrong\n    // values.\n    if (!backend.gpgpu.gl.isTexture(texture)) {\n      throw new Error(\n          `The texture is invalid. Also, please make sure the texture and ` +\n          `the TFJS WebGL backend are using the same canvas. If you want to ` +\n          `use your own custom canvas, you have to create and use the custom ` +\n          `TFJS WebGL backend created from the canvas through ` +\n          `'new tf.MathBackendWebGL(customCanvas)'.`);\n    }\n\n    const dataId =\n        backend.writeTexture(texture, shape, dtype, height, width, channels);\n    return engine().makeTensorFromDataId(dataId, shape, dtype, backend);\n  }\n}\n\nfunction float32ToTypedArray<D extends NumericDataType>(\n    a: Float32Array, dtype: D): tf.DataTypeMap[D] {\n  if (dtype === 'float32' || dtype === 'complex64') {\n    return a as tf.DataTypeMap[D];\n  } else if (dtype === 'int32' || dtype === 'bool') {\n    const result = (dtype === 'int32') ? new Int32Array(a.length) :\n                                         new Uint8Array(a.length);\n    for (let i = 0; i < result.length; ++i) {\n      result[i] = Math.round(a[i]);\n    }\n    return result as tf.DataTypeMap[D];\n  } else {\n    throw new Error(`Unknown dtype ${dtype}`);\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}