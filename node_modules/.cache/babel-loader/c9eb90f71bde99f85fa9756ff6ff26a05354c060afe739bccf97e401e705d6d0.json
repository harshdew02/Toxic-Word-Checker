{"ast":null,"code":"import _toConsumableArray from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { computeStrides, sizeFromShape } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\nexport function prepareAndValidate(tensor, indices) {\n  var tensorRank = tensor.shape.length;\n  var indicesRank = indices.shape.length;\n  if (tensorRank < 1) {\n    throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' + \" but the rank was \".concat(tensorRank, \".\"));\n  }\n  if (indicesRank < 1) {\n    throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' + \" but the rank was \".concat(indicesRank, \".\"));\n  }\n  if (indices.dtype !== 'int32') {\n    throw new Error('tf.gatherND() expects the indices to be int32 type,' + \" but the dtype was \".concat(indices.dtype, \".\"));\n  }\n  if (indices.shape[indicesRank - 1] > tensorRank) {\n    throw new Error('index innermost dimension length must be <= tensor rank; saw: ' + \"\".concat(indices.shape[indicesRank - 1], \" vs. \").concat(tensorRank));\n  }\n  if (sizeFromShape(tensor.shape) === 0) {\n    throw new Error('Requested more than 0 entries, but input is empty.' + \" Input shape: \".concat(tensor.shape, \".\"));\n  }\n  var indicesShape = indices.shape;\n  var sliceRank = indicesShape[indicesShape.length - 1];\n  // The result shape is\n  //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n  var nResult = 1;\n  for (var i = 0; i < indicesShape.length - 1; ++i) {\n    nResult *= indicesShape[i];\n  }\n  var inputShape = tensor.shape;\n  var resultShape = indicesShape.slice();\n  resultShape.pop();\n  var sliceSize = 1;\n  for (var _i = sliceRank; _i < tensorRank; ++_i) {\n    sliceSize *= inputShape[_i];\n    resultShape.push(inputShape[_i]);\n  }\n  var strides = [].concat(_toConsumableArray(computeStrides(tensor.shape).map(function (stride) {\n    return stride / sliceSize;\n  })), [1]).slice(0, sliceRank);\n  return [resultShape, nResult, sliceSize, strides];\n}","map":{"version":3,"mappings":";AAiBA,SAAQA,cAAc,EAAEC,aAAa,QAAO,SAAS;AAErD;;;;;;;;AAQA,OAAM,SAAUC,kBAAkB,CAACC,MAAkB,EAAEC,OAAmB;EAExE,IAAMC,UAAU,GAAGF,MAAM,CAACG,KAAK,CAACC,MAAM;EACtC,IAAMC,WAAW,GAAGJ,OAAO,CAACE,KAAK,CAACC,MAAM;EACxC,IAAIF,UAAU,GAAG,CAAC,EAAE;IAClB,MAAM,IAAII,KAAK,CACX,yDAAyD,+BACpCJ,UAAU,MAAG,CAAC;;EAEzC,IAAIG,WAAW,GAAG,CAAC,EAAE;IACnB,MAAM,IAAIC,KAAK,CACX,2DAA2D,+BACtCD,WAAW,MAAG,CAAC;;EAE1C,IAAIJ,OAAO,CAACM,KAAK,KAAK,OAAO,EAAE;IAC7B,MAAM,IAAID,KAAK,CACX,qDAAqD,gCAC/BL,OAAO,CAACM,KAAK,MAAG,CAAC;;EAE7C,IAAIN,OAAO,CAACE,KAAK,CAACE,WAAW,GAAG,CAAC,CAAC,GAAGH,UAAU,EAAE;IAC/C,MAAM,IAAII,KAAK,CACX,gEAAgE,aAC7DL,OAAO,CAACE,KAAK,CAACE,WAAW,GAAG,CAAC,CAAC,kBAAQH,UAAU,CAAE,CAAC;;EAG5D,IAAIJ,aAAa,CAACE,MAAM,CAACG,KAAK,CAAC,KAAK,CAAC,EAAE;IACrC,MAAM,IAAIG,KAAK,CACX,oDAAoD,2BACnCN,MAAM,CAACG,KAAK,MAAG,CAAC;;EAGvC,IAAMK,YAAY,GAAGP,OAAO,CAACE,KAAK;EAClC,IAAMM,SAAS,GAAGD,YAAY,CAACA,YAAY,CAACJ,MAAM,GAAG,CAAC,CAAC;EAEvD;EACA;EACA,IAAIM,OAAO,GAAG,CAAC;EACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,YAAY,CAACJ,MAAM,GAAG,CAAC,EAAE,EAAEO,CAAC,EAAE;IAChDD,OAAO,IAAIF,YAAY,CAACG,CAAC,CAAC;;EAG5B,IAAMC,UAAU,GAAGZ,MAAM,CAACG,KAAK;EAE/B,IAAMU,WAAW,GAAGL,YAAY,CAACM,KAAK,EAAE;EACxCD,WAAW,CAACE,GAAG,EAAE;EAEjB,IAAIC,SAAS,GAAG,CAAC;EACjB,KAAK,IAAIL,EAAC,GAAGF,SAAS,EAAEE,EAAC,GAAGT,UAAU,EAAE,EAAES,EAAC,EAAE;IAC3CK,SAAS,IAAIJ,UAAU,CAACD,EAAC,CAAC;IAC1BE,WAAW,CAACI,IAAI,CAACL,UAAU,CAACD,EAAC,CAAC,CAAC;;EAGjC,IAAMO,OAAO,GACT,6BAAIrB,cAAc,CAACG,MAAM,CAACG,KAAK,CAAC,CAACgB,GAAG,CAAC,gBAAM;IAAA,OAAIC,MAAM,GAAGJ,SAAS;EAAA,EAAC,IACjE,CAAC,GAAEF,KAAK,CAAC,CAAC,EAAEL,SAAS,CAAC;EAE3B,OAAO,CAACI,WAAW,EAAEH,OAAO,EAAEM,SAAS,EAAEE,OAAO,CAAC;AACnD","names":["computeStrides","sizeFromShape","prepareAndValidate","tensor","indices","tensorRank","shape","length","indicesRank","Error","dtype","indicesShape","sliceRank","nResult","i","inputShape","resultShape","slice","pop","sliceSize","push","strides","map","stride"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-core\\src\\ops\\gather_nd_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { TensorInfo } from '../tensor_info';\nimport {computeStrides, sizeFromShape} from '../util';\n\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\nexport function prepareAndValidate(tensor: TensorInfo, indices: TensorInfo):\n    [number[], number, number, number[]] {\n  const tensorRank = tensor.shape.length;\n  const indicesRank = indices.shape.length;\n  if (tensorRank < 1) {\n    throw new Error(\n        'tf.gatherND() expects the input to be rank 1 or higher,' +\n        ` but the rank was ${tensorRank}.`);\n  }\n  if (indicesRank < 1) {\n    throw new Error(\n        'tf.gatherND() expects the indices to be rank 1 or higher,' +\n        ` but the rank was ${indicesRank}.`);\n  }\n  if (indices.dtype !== 'int32') {\n    throw new Error(\n        'tf.gatherND() expects the indices to be int32 type,' +\n        ` but the dtype was ${indices.dtype}.`);\n  }\n  if (indices.shape[indicesRank - 1] > tensorRank) {\n    throw new Error(\n        'index innermost dimension length must be <= tensor rank; saw: ' +\n        `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);\n  }\n\n  if (sizeFromShape(tensor.shape) === 0) {\n    throw new Error(\n        'Requested more than 0 entries, but input is empty.' +\n        ` Input shape: ${tensor.shape}.`);\n  }\n\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1];\n\n  // The result shape is\n  //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n  let nResult = 1;\n  for (let i = 0; i < indicesShape.length - 1; ++i) {\n    nResult *= indicesShape[i];\n  }\n\n  const inputShape = tensor.shape;\n\n  const resultShape = indicesShape.slice();\n  resultShape.pop();\n\n  let sliceSize = 1;\n  for (let i = sliceRank; i < tensorRank; ++i) {\n    sliceSize *= inputShape[i];\n    resultShape.push(inputShape[i]);\n  }\n\n  const strides =\n      [...computeStrides(tensor.shape).map(stride => stride / sliceSize),\n       1].slice(0, sliceRank);\n\n  return [resultShape, nResult, sliceSize, strides];\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}