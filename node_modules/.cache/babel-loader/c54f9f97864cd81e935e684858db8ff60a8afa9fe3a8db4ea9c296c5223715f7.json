{"ast":null,"code":"import _createForOfIteratorHelper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _inherits from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\nimport { deepClone } from '../util/deep_clone';\nimport { deepMapAndAwaitAll, deepZip, zipToList } from '../util/deep_map';\nimport { GrowingRingBuffer } from '../util/growing_ring_buffer';\nimport { RingBuffer } from '../util/ring_buffer';\n// Here we implement a simple asynchronous iterator.\n// This lets us avoid using either third-party stream libraries or\n// recent TypeScript language support requiring polyfills.\n/**\n * Create a `LazyIterator` from an array of items.\n */\nexport function iteratorFromItems(items) {\n  return new ArrayIterator(items);\n}\n/**\n * Create a `LazyIterator` of incrementing integers.\n */\nexport function iteratorFromIncrementing(start) {\n  var i = start;\n  return iteratorFromFunction(function () {\n    return {\n      value: i++,\n      done: false\n    };\n  });\n}\n/**\n * Create a `LazyIterator` from a function.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const iter = tf.data.iteratorFromFunction(func);\n * await iter.forEachAsync(e => console.log(e));\n * ```\n *\n * @param func A function that produces data on each call.\n */\nexport function iteratorFromFunction(func) {\n  return new FunctionCallIterator(func);\n}\n/**\n * Create a `LazyIterator` by concatenating underlying streams, which are\n * themselves provided as a stream.\n *\n * This can also be thought of as a \"stream flatten\" operation.\n *\n * @param baseIterators A stream of streams to be concatenated.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenated(baseIterators, baseErrorHandler) {\n  return new ChainedIterator(baseIterators, baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by concatenating streams produced by calling a\n * stream-generating function a given number of times.\n *\n * Since a `LazyIterator` is read-once, it cannot be repeated, but this\n * function can be used to achieve a similar effect:\n *\n *   LazyIterator.ofConcatenatedFunction(() => new MyIterator(), 6);\n *\n * @param iteratorFunc: A function that produces a new stream on each call.\n * @param count: The number of times to call the function.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenatedFunction(iteratorFunc, count, baseErrorHandler) {\n  return iteratorFromConcatenated(iteratorFromFunction(iteratorFunc).take(count), baseErrorHandler);\n}\n/**\n * Create a `LazyIterator` by zipping together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nexport function iteratorFromZipped(iterators) {\n  var mismatchMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZipMismatchMode.FAIL;\n  return new ZipIterator(iterators, mismatchMode);\n}\n/**\n * An asynchronous iterator, providing lazy access to a potentially\n * unbounded stream of elements.\n *\n * Iterator can be obtained from a dataset:\n * `const iter = await dataset.iterator();`\n */\nexport var LazyIterator = /*#__PURE__*/function () {\n  function LazyIterator() {\n    _classCallCheck(this, LazyIterator);\n  }\n  _createClass(LazyIterator, [{\n    key: \"toArray\",\n    value:\n    /**\n     * Collect all remaining elements of a bounded stream into an array.\n     * Obviously this will succeed only for small streams that fit in memory.\n     * Useful for testing.\n     *\n     * @returns A Promise for an array of stream elements, which will resolve\n     *   when the stream is exhausted.\n     */\n    function () {\n      var _toArray = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var result, x;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              result = [];\n              _context.next = 3;\n              return this.next();\n            case 3:\n              x = _context.sent;\n            case 4:\n              if (x.done) {\n                _context.next = 11;\n                break;\n              }\n              result.push(x.value);\n              _context.next = 8;\n              return this.next();\n            case 8:\n              x = _context.sent;\n              _context.next = 4;\n              break;\n            case 11:\n              return _context.abrupt(\"return\", result);\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function toArray() {\n        return _toArray.apply(this, arguments);\n      }\n      return toArray;\n    }()\n    /**\n     * Collect all elements of this dataset into an array with prefetching 100\n     * elements. This is useful for testing, because the prefetch changes the\n     * order in which the Promises are resolved along the processing pipeline.\n     * This may help expose bugs where results are dependent on the order of\n     * Promise resolution rather than on the logical order of the stream (i.e.,\n     * due to hidden mutable state).\n     *\n     * @returns A Promise for an array of stream elements, which will resolve\n     *   when the stream is exhausted.\n     */\n  }, {\n    key: \"toArrayForTest\",\n    value: function () {\n      var _toArrayForTest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var stream, result, x;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              stream = this.prefetch(100);\n              result = [];\n              _context2.next = 4;\n              return stream.next();\n            case 4:\n              x = _context2.sent;\n            case 5:\n              if (x.done) {\n                _context2.next = 12;\n                break;\n              }\n              result.push(x.value);\n              _context2.next = 9;\n              return stream.next();\n            case 9:\n              x = _context2.sent;\n              _context2.next = 5;\n              break;\n            case 12:\n              return _context2.abrupt(\"return\", result);\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function toArrayForTest() {\n        return _toArrayForTest.apply(this, arguments);\n      }\n      return toArrayForTest;\n    }()\n    /**\n     * Draw items from the stream until it is exhausted.\n     *\n     * This can be useful when the stream has side effects but no output.  In\n     * that case, calling this function guarantees that the stream will be\n     * fully processed.\n     */\n  }, {\n    key: \"resolveFully\",\n    value: function () {\n      var _resolveFully = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var x;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.next();\n            case 2:\n              x = _context3.sent;\n            case 3:\n              if (x.done) {\n                _context3.next = 9;\n                break;\n              }\n              _context3.next = 6;\n              return this.next();\n            case 6:\n              x = _context3.sent;\n              _context3.next = 3;\n              break;\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function resolveFully() {\n        return _resolveFully.apply(this, arguments);\n      }\n      return resolveFully;\n    }()\n    /**\n     * Draw items from the stream until it is exhausted, or a predicate fails.\n     *\n     * This can be useful when the stream has side effects but no output.  In\n     * that case, calling this function guarantees that the stream will be\n     * fully processed.\n     */\n  }, {\n    key: \"resolveWhile\",\n    value: function () {\n      var _resolveWhile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(predicate) {\n        var x, shouldContinue;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this.next();\n            case 2:\n              x = _context4.sent;\n              shouldContinue = predicate(x.value);\n            case 4:\n              if (!(!x.done && shouldContinue)) {\n                _context4.next = 11;\n                break;\n              }\n              _context4.next = 7;\n              return this.next();\n            case 7:\n              x = _context4.sent;\n              shouldContinue = predicate(x.value);\n              _context4.next = 4;\n              break;\n            case 11:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function resolveWhile(_x) {\n        return _resolveWhile.apply(this, arguments);\n      }\n      return resolveWhile;\n    }()\n    /**\n     * Handles errors thrown on this stream using a provided handler function.\n     *\n     * @param handler A function that handles any `Error` thrown during a `next()`\n     *   call and returns true if the stream should continue (dropping the failed\n     *   call) or false if the stream should quietly terminate.  If the handler\n     *   itself throws (or rethrows) an `Error`, that will be propagated.\n     *\n     * @returns A `LazyIterator` of elements passed through from upstream,\n     *   possibly filtering or terminating on upstream `next()` calls that\n     *   throw an `Error`.\n     */\n  }, {\n    key: \"handleErrors\",\n    value: function handleErrors(handler) {\n      return new ErrorHandlingLazyIterator(this, handler);\n    }\n    // TODO(soergel): Implement reduce() etc.\n    /**\n     * Filters this stream according to `predicate`.\n     *\n     * @param predicate A function mapping a stream element to a boolean or a\n     * `Promise` for one.\n     *\n     * @returns A `LazyIterator` of elements for which the predicate was true.\n     */\n  }, {\n    key: \"filter\",\n    value: function filter(predicate) {\n      return new FilterIterator(this, predicate);\n    }\n    /**\n     * Maps this stream through a 1-to-1 transform.\n     *\n     * @param transform A function mapping a stream element to a transformed\n     *   element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n  }, {\n    key: \"map\",\n    value: function map(transform) {\n      return new MapIterator(this, transform);\n    }\n    /**\n     * Maps this stream through an async 1-to-1 transform.\n     *\n     * @param transform A function mapping a stream element to a `Promise` for a\n     *   transformed stream element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n  }, {\n    key: \"mapAsync\",\n    value: function mapAsync(transform) {\n      return new AsyncMapIterator(this, transform);\n    }\n    /**\n     * Maps this stream through a 1-to-1 transform, forcing serial execution.\n     *\n     * @param transform A function mapping a stream element to a transformed\n     *   element.\n     *\n     * @returns A `LazyIterator` of transformed elements.\n     */\n  }, {\n    key: \"serialMapAsync\",\n    value: function serialMapAsync(transform) {\n      return new AsyncMapIterator(this, transform).serial();\n    }\n    /**\n     * Maps this stream through a 1-to-many transform.\n     *\n     * @param transform A function mapping a stream element to an array of\n     *   transformed elements.\n     *\n     * @returns A `DataStream` of transformed elements.\n     */\n  }, {\n    key: \"flatmap\",\n    value: function flatmap(transform) {\n      return new FlatmapIterator(this, transform);\n    }\n    /**\n     * Apply a function to every element of the stream.\n     *\n     * @param f A function to apply to each stream element.\n     */\n  }, {\n    key: \"forEachAsync\",\n    value: function () {\n      var _forEachAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(f) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt(\"return\", this.map(f).resolveFully());\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function forEachAsync(_x2) {\n        return _forEachAsync.apply(this, arguments);\n      }\n      return forEachAsync;\n    }()\n    /**\n     * Apply a function to every element of the stream, forcing serial execution.\n     *\n     * @param f A function to apply to each stream element.  Should return 'true'\n     *   to indicate that the stream should continue, or 'false' to cause it to\n     *   terminate.\n     */\n  }, {\n    key: \"serialForEach\",\n    value: function () {\n      var _serialForEach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(f) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", this.serialMapAsync(f).resolveWhile(function (x) {\n                return x === true;\n              }));\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function serialForEach(_x3) {\n        return _serialForEach.apply(this, arguments);\n      }\n      return serialForEach;\n    }()\n    /**\n     * Groups elements into batches, represented as arrays of elements.\n     *\n     * We can think of the elements of this iterator as 'rows' (even if they are\n     * nested structures).  By the same token, consecutive values for a given\n     * key within the elements form a 'column'.  This matches the usual sense of\n     * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n     *\n     * Thus, \"Row-major\" means that the resulting batch is simply a collection of\n     * rows: `[row1, row2, row3, ...]`.  This is contrast to the column-major\n     * form, which is needed for vectorized computation.\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @returns A `LazyIterator` of batches of elements, represented as arrays\n     *   of the original element type.\n     */\n  }, {\n    key: \"rowMajorBatch\",\n    value: function rowMajorBatch(batchSize) {\n      var smallLastBatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return new RowMajorBatchIterator(this, batchSize, smallLastBatch);\n    }\n    /**\n     * Groups elements into batches, represented in column-major form.\n     *\n     * We can think of the elements of this iterator as 'rows' (even if they are\n     * nested structures).  By the same token, consecutive values for a given\n     * key within the elements form a 'column'.  This matches the usual sense of\n     * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n     *\n     * Thus, \"column-major\" means that the resulting batch is a (potentially\n     * nested) structure representing the columns.  Each column entry, then,\n     * contains a collection of the values found in that column for a range of\n     * input elements.  This representation allows for vectorized computation, in\n     * contrast to the row-major form.\n     *\n     * The inputs should all have the same nested structure (i.e., of arrays and\n     * dicts).  The result is a single object with the same nested structure,\n     * where the leaves are arrays collecting the values of the inputs at that\n     * location (or, optionally, the result of a custom function applied to those\n     * arrays).\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @param zipFn: (optional) A function that expects an array of elements at a\n     *   single node of the object tree, and returns a `DeepMapResult`.  The\n     *   `DeepMapResult` either provides a result value for that node (i.e.,\n     *   representing the subtree), or indicates that the node should be processed\n     *   recursively.  The default zipFn recurses as far as possible and places\n     *   arrays at the leaves.\n     * @returns A `LazyIterator` of batches of elements, represented as an object\n     *   with collections at the leaves.\n     */\n  }, {\n    key: \"columnMajorBatch\",\n    value: function columnMajorBatch(batchSize) {\n      var smallLastBatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var zipFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : zipToList;\n      // First collect the desired number of input elements as a row-major batch.\n      var rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);\n      // Now 'rotate' or 'pivot' the data, collecting all values from each column\n      // in the batch (i.e., for each key within the elements) into an array.\n      return rowBatches.map(function (x) {\n        return deepZip(x, zipFn);\n      });\n    }\n    /**\n     * Concatenate this `LazyIterator` with another.\n     *\n     * @param iterator A `LazyIterator` to be concatenated onto this one.\n     * @param baseErrorHandler An optional function that can intercept `Error`s\n     *   raised during a `next()` call on the base stream.  This function can\n     *   decide whether the error should be propagated, whether the error should\n     *   be ignored, or whether the base stream should be terminated.\n     * @returns A `LazyIterator`.\n     */\n  }, {\n    key: \"concatenate\",\n    value: function concatenate(iterator, baseErrorHandler) {\n      return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);\n    }\n    /**\n     * Limits this stream to return at most `count` items.\n     *\n     * @param count The maximum number of items to provide from the stream. If\n     * a negative or undefined value is given, the entire stream is returned\n     *   unaltered.\n     */\n  }, {\n    key: \"take\",\n    value: function take(count) {\n      if (count < 0 || count == null) {\n        return this;\n      }\n      return new TakeIterator(this, count);\n    }\n    /**\n     * Skips the first `count` items in this stream.\n     *\n     * @param count The number of items to skip.  If a negative or undefined\n     * value is given, the entire stream is returned unaltered.\n     */\n  }, {\n    key: \"skip\",\n    value: function skip(count) {\n      if (count < 0 || count == null) {\n        return this;\n      }\n      return new SkipIterator(this, count);\n    }\n    /**\n     * Prefetch the first `bufferSize` items in this stream.\n     *\n     * Note this prefetches Promises, but makes no guarantees about when those\n     * Promises resolve.\n     *\n     * @param bufferSize: An integer specifying the number of elements to be\n     *   prefetched.\n     */\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(bufferSize) {\n      return new PrefetchIterator(this, bufferSize);\n    }\n    // TODO(soergel): deep sharded shuffle, where supported\n    /**\n     * Randomly shuffles the elements of this stream.\n     *\n     * @param bufferSize: An integer specifying the number of elements from\n     * this stream from which the new stream will sample.\n     * @param seed: (Optional.) An integer specifying the random seed that\n     * will be used to create the distribution.\n     */\n  }, {\n    key: \"shuffle\",\n    value: function shuffle(windowSize, seed) {\n      return new ShuffleIterator(this, windowSize, seed);\n    }\n    /**\n     * Force an iterator to execute serially: each next() call will await the\n     * prior one, so that they cannot execute concurrently.\n     */\n  }, {\n    key: \"serial\",\n    value: function serial() {\n      return new SerialIterator(this);\n    }\n  }]);\n  return LazyIterator;\n}();\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on LazyIterator.  Unfortunately they can't be placed in separate files,\n// due to resulting trouble with circular imports.\n// ============================================================================\n// Iterators that just extend LazyIterator directly\n// ============================================================================\nvar ArrayIterator = /*#__PURE__*/function (_LazyIterator) {\n  _inherits(ArrayIterator, _LazyIterator);\n  var _super = _createSuper(ArrayIterator);\n  function ArrayIterator(items) {\n    var _this;\n    _classCallCheck(this, ArrayIterator);\n    _this = _super.call(this);\n    _this.items = items;\n    _this.trav = 0;\n    return _this;\n  }\n  _createClass(ArrayIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"Array of \".concat(this.items.length, \" items\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var item;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!(this.trav >= this.items.length)) {\n                _context7.next = 2;\n                break;\n              }\n              return _context7.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 2:\n              item = this.items[this.trav];\n              this.trav++;\n              return _context7.abrupt(\"return\", {\n                value: deepClone(item),\n                done: false\n              });\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function next() {\n        return _next.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return ArrayIterator;\n}(LazyIterator);\nvar FunctionCallIterator = /*#__PURE__*/function (_LazyIterator2) {\n  _inherits(FunctionCallIterator, _LazyIterator2);\n  var _super2 = _createSuper(FunctionCallIterator);\n  function FunctionCallIterator(nextFn) {\n    var _this2;\n    _classCallCheck(this, FunctionCallIterator);\n    _this2 = _super2.call(this);\n    _this2.nextFn = nextFn;\n    return _this2;\n  }\n  _createClass(FunctionCallIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"Function call\";\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.prev = 0;\n              return _context8.abrupt(\"return\", this.nextFn());\n            case 4:\n              _context8.prev = 4;\n              _context8.t0 = _context8[\"catch\"](0);\n              // Modify the error message but leave the stack trace intact\n              _context8.t0.message = \"Error thrown while iterating through a dataset: \".concat(_context8.t0.message);\n              throw _context8.t0;\n            case 8:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[0, 4]]);\n      }));\n      function next() {\n        return _next2.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return FunctionCallIterator;\n}(LazyIterator);\nvar SerialIterator = /*#__PURE__*/function (_LazyIterator3) {\n  _inherits(SerialIterator, _LazyIterator3);\n  var _super3 = _createSuper(SerialIterator);\n  function SerialIterator(upstream) {\n    var _this3;\n    _classCallCheck(this, SerialIterator);\n    _this3 = _super3.call(this);\n    _this3.upstream = upstream;\n    _this3.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this3;\n  }\n  _createClass(SerialIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Serial\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var _this4 = this;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this4.serialNext();\n              });\n              return _context9.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function next() {\n        return _next3.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              return _context10.abrupt(\"return\", this.upstream.next());\n            case 1:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function serialNext() {\n        return _serialNext.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return SerialIterator;\n}(LazyIterator);\nvar SkipIterator = /*#__PURE__*/function (_LazyIterator4) {\n  _inherits(SkipIterator, _LazyIterator4);\n  var _super4 = _createSuper(SkipIterator);\n  function SkipIterator(upstream, maxCount) {\n    var _this5;\n    _classCallCheck(this, SkipIterator);\n    _this5 = _super4.call(this);\n    _this5.upstream = upstream;\n    _this5.maxCount = maxCount;\n    // Local state that should not be clobbered by out-of-order execution.\n    _this5.count = 0;\n    _this5.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this5;\n  }\n  _createClass(SkipIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Skip\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var _this6 = this;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this6.serialNext();\n              });\n              return _context11.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function next() {\n        return _next4.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var skipped;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              if (!(this.count++ < this.maxCount)) {\n                _context12.next = 9;\n                break;\n              }\n              _context12.next = 3;\n              return this.upstream.next();\n            case 3:\n              skipped = _context12.sent;\n              if (!skipped.done) {\n                _context12.next = 6;\n                break;\n              }\n              return _context12.abrupt(\"return\", skipped);\n            case 6:\n              tf.dispose(skipped.value);\n              _context12.next = 0;\n              break;\n            case 9:\n              return _context12.abrupt(\"return\", this.upstream.next());\n            case 10:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function serialNext() {\n        return _serialNext2.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return SkipIterator;\n}(LazyIterator);\nvar TakeIterator = /*#__PURE__*/function (_LazyIterator5) {\n  _inherits(TakeIterator, _LazyIterator5);\n  var _super5 = _createSuper(TakeIterator);\n  function TakeIterator(upstream, maxCount) {\n    var _this7;\n    _classCallCheck(this, TakeIterator);\n    _this7 = _super5.call(this);\n    _this7.upstream = upstream;\n    _this7.maxCount = maxCount;\n    _this7.count = 0;\n    return _this7;\n  }\n  _createClass(TakeIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Take\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              if (!(this.count++ >= this.maxCount)) {\n                _context13.next = 2;\n                break;\n              }\n              return _context13.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 2:\n              return _context13.abrupt(\"return\", this.upstream.next());\n            case 3:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function next() {\n        return _next5.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return TakeIterator;\n}(LazyIterator); // Note this batch just groups items into row-wise element arrays.\n// Rotating these to a column-wise representation happens only at the dataset\n// level.\nvar RowMajorBatchIterator = /*#__PURE__*/function (_LazyIterator6) {\n  _inherits(RowMajorBatchIterator, _LazyIterator6);\n  var _super6 = _createSuper(RowMajorBatchIterator);\n  function RowMajorBatchIterator(upstream, batchSize) {\n    var _this8;\n    var enableSmallLastBatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    _classCallCheck(this, RowMajorBatchIterator);\n    _this8 = _super6.call(this);\n    _this8.upstream = upstream;\n    _this8.batchSize = batchSize;\n    _this8.enableSmallLastBatch = enableSmallLastBatch;\n    _this8.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this8;\n  }\n  _createClass(RowMajorBatchIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> RowMajorBatch\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var _this9 = this;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this9.serialNext();\n              });\n              return _context14.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function next() {\n        return _next6.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var batch, item;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              batch = [];\n            case 1:\n              if (!(batch.length < this.batchSize)) {\n                _context15.next = 12;\n                break;\n              }\n              _context15.next = 4;\n              return this.upstream.next();\n            case 4:\n              item = _context15.sent;\n              if (!item.done) {\n                _context15.next = 9;\n                break;\n              }\n              if (!(this.enableSmallLastBatch && batch.length > 0)) {\n                _context15.next = 8;\n                break;\n              }\n              return _context15.abrupt(\"return\", {\n                value: batch,\n                done: false\n              });\n            case 8:\n              return _context15.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 9:\n              batch.push(item.value);\n              _context15.next = 1;\n              break;\n            case 12:\n              return _context15.abrupt(\"return\", {\n                value: batch,\n                done: false\n              });\n            case 13:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function serialNext() {\n        return _serialNext3.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return RowMajorBatchIterator;\n}(LazyIterator);\nvar FilterIterator = /*#__PURE__*/function (_LazyIterator7) {\n  _inherits(FilterIterator, _LazyIterator7);\n  var _super7 = _createSuper(FilterIterator);\n  function FilterIterator(upstream, predicate) {\n    var _this10;\n    _classCallCheck(this, FilterIterator);\n    _this10 = _super7.call(this);\n    _this10.upstream = upstream;\n    _this10.predicate = predicate;\n    _this10.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this10;\n  }\n  _createClass(FilterIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Filter\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var _this11 = this;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this11.serialNext();\n              });\n              return _context16.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function next() {\n        return _next7.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var item;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              if (!true) {\n                _context17.next = 9;\n                break;\n              }\n              _context17.next = 3;\n              return this.upstream.next();\n            case 3:\n              item = _context17.sent;\n              if (!(item.done || this.predicate(item.value))) {\n                _context17.next = 6;\n                break;\n              }\n              return _context17.abrupt(\"return\", item);\n            case 6:\n              tf.dispose(item.value);\n              _context17.next = 0;\n              break;\n            case 9:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n      function serialNext() {\n        return _serialNext4.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return FilterIterator;\n}(LazyIterator);\nvar MapIterator = /*#__PURE__*/function (_LazyIterator8) {\n  _inherits(MapIterator, _LazyIterator8);\n  var _super8 = _createSuper(MapIterator);\n  function MapIterator(upstream, transform) {\n    var _this12;\n    _classCallCheck(this, MapIterator);\n    _this12 = _super8.call(this);\n    _this12.upstream = upstream;\n    _this12.transform = transform;\n    return _this12;\n  }\n  _createClass(MapIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Map\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var item, inputTensors, mapped, outputTensors, _iterator, _step, t;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.next = 2;\n              return this.upstream.next();\n            case 2:\n              item = _context18.sent;\n              if (!item.done) {\n                _context18.next = 5;\n                break;\n              }\n              return _context18.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 5:\n              inputTensors = tf.tensor_util.getTensorsInContainer(item.value); // Careful: the transform may mutate the item in place.\n              // That's why we have to remember the input Tensors above, and then\n              // below dispose only those that were not passed through to the output.\n              // Note too that the transform function is responsible for tidying\n              // any intermediate Tensors.  Here we are concerned only about the\n              // inputs.\n              mapped = this.transform(item.value);\n              outputTensors = tf.tensor_util.getTensorsInContainer(mapped); // TODO(soergel) faster intersection\n              // TODO(soergel) move to tf.disposeExcept(in, out)?\n              _iterator = _createForOfIteratorHelper(inputTensors);\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  t = _step.value;\n                  if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                    t.dispose();\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              return _context18.abrupt(\"return\", {\n                value: mapped,\n                done: false\n              });\n            case 11:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function next() {\n        return _next8.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return MapIterator;\n}(LazyIterator);\nvar ErrorHandlingLazyIterator = /*#__PURE__*/function (_LazyIterator9) {\n  _inherits(ErrorHandlingLazyIterator, _LazyIterator9);\n  var _super9 = _createSuper(ErrorHandlingLazyIterator);\n  function ErrorHandlingLazyIterator(upstream, handler) {\n    var _this13;\n    _classCallCheck(this, ErrorHandlingLazyIterator);\n    _this13 = _super9.call(this);\n    _this13.upstream = upstream;\n    _this13.handler = handler;\n    _this13.count = 0;\n    _this13.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this13;\n  }\n  _createClass(ErrorHandlingLazyIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> handleErrors\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        var _this14 = this;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this14.serialNext();\n              });\n              return _context19.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n      function next() {\n        return _next9.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              if (!true) {\n                _context20.next = 13;\n                break;\n              }\n              _context20.prev = 1;\n              _context20.next = 4;\n              return this.upstream.next();\n            case 4:\n              return _context20.abrupt(\"return\", _context20.sent);\n            case 7:\n              _context20.prev = 7;\n              _context20.t0 = _context20[\"catch\"](1);\n              if (this.handler(_context20.t0)) {\n                _context20.next = 11;\n                break;\n              }\n              return _context20.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 11:\n              _context20.next = 0;\n              break;\n            case 13:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this, [[1, 7]]);\n      }));\n      function serialNext() {\n        return _serialNext5.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return ErrorHandlingLazyIterator;\n}(LazyIterator);\nvar AsyncMapIterator = /*#__PURE__*/function (_LazyIterator10) {\n  _inherits(AsyncMapIterator, _LazyIterator10);\n  var _super10 = _createSuper(AsyncMapIterator);\n  function AsyncMapIterator(upstream, transform) {\n    var _this15;\n    _classCallCheck(this, AsyncMapIterator);\n    _this15 = _super10.call(this);\n    _this15.upstream = upstream;\n    _this15.transform = transform;\n    return _this15;\n  }\n  _createClass(AsyncMapIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> AsyncMap\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var item, inputTensors, mapped, outputTensors, _iterator2, _step2, t;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.next = 2;\n              return this.upstream.next();\n            case 2:\n              item = _context21.sent;\n              if (!item.done) {\n                _context21.next = 5;\n                break;\n              }\n              return _context21.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 5:\n              inputTensors = tf.tensor_util.getTensorsInContainer(item.value); // Careful: the transform may mutate the item in place.\n              // That's why we have to remember the input Tensors above, and then\n              // below dispose only those that were not passed through to the output.\n              // Note too that the transform function is responsible for tidying\n              // any intermediate Tensors.  Here we are concerned only about the\n              // inputs.\n              _context21.next = 8;\n              return this.transform(item.value);\n            case 8:\n              mapped = _context21.sent;\n              outputTensors = tf.tensor_util.getTensorsInContainer(mapped); // TODO(soergel) faster intersection\n              // TODO(soergel) move to tf.disposeExcept(in, out)?\n              _iterator2 = _createForOfIteratorHelper(inputTensors);\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  t = _step2.value;\n                  if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                    t.dispose();\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              return _context21.abrupt(\"return\", {\n                value: mapped,\n                done: false\n              });\n            case 13:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function next() {\n        return _next10.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return AsyncMapIterator;\n}(LazyIterator); // Iterators that maintain a queue of pending items\n// ============================================================================\n/**\n * A base class for transforming streams that operate by maintaining an\n * output queue of elements that are ready to return via next().  This is\n * commonly required when the transformation is 1-to-many:  A call to next()\n * may trigger a call to the underlying stream, which will produce many\n * mapped elements of this stream-- of which we need to return only one, so\n * we have to queue the rest.\n */\nexport var OneToManyIterator = /*#__PURE__*/function (_LazyIterator11) {\n  _inherits(OneToManyIterator, _LazyIterator11);\n  var _super11 = _createSuper(OneToManyIterator);\n  function OneToManyIterator() {\n    var _this16;\n    _classCallCheck(this, OneToManyIterator);\n    _this16 = _super11.call(this);\n    _this16.outputQueue = new GrowingRingBuffer();\n    _this16.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this16;\n  }\n  _createClass(OneToManyIterator, [{\n    key: \"next\",\n    value: function () {\n      var _next11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n        var _this17 = this;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this17.serialNext();\n              });\n              return _context22.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function next() {\n        return _next11.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              if (!(this.outputQueue.length() === 0)) {\n                _context23.next = 7;\n                break;\n              }\n              _context23.next = 3;\n              return this.pump();\n            case 3:\n              if (_context23.sent) {\n                _context23.next = 5;\n                break;\n              }\n              return _context23.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 5:\n              _context23.next = 0;\n              break;\n            case 7:\n              return _context23.abrupt(\"return\", {\n                value: this.outputQueue.shift(),\n                done: false\n              });\n            case 8:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n      function serialNext() {\n        return _serialNext6.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return OneToManyIterator;\n}(LazyIterator);\nvar FlatmapIterator = /*#__PURE__*/function (_OneToManyIterator) {\n  _inherits(FlatmapIterator, _OneToManyIterator);\n  var _super12 = _createSuper(FlatmapIterator);\n  function FlatmapIterator(upstream, transform) {\n    var _this18;\n    _classCallCheck(this, FlatmapIterator);\n    _this18 = _super12.call(this);\n    _this18.upstream = upstream;\n    _this18.transform = transform;\n    return _this18;\n  }\n  _createClass(FlatmapIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Flatmap\");\n    }\n  }, {\n    key: \"pump\",\n    value: function () {\n      var _pump = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {\n        var item, inputTensors, mappedArray, outputTensors, _iterator3, _step3, t;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              _context24.next = 2;\n              return this.upstream.next();\n            case 2:\n              item = _context24.sent;\n              if (!item.done) {\n                _context24.next = 5;\n                break;\n              }\n              return _context24.abrupt(\"return\", false);\n            case 5:\n              inputTensors = tf.tensor_util.getTensorsInContainer(item.value); // Careful: the transform may mutate the item in place.\n              // that's why we have to remember the input Tensors above, and then\n              // below dispose only those that were not passed through to the output.\n              // Note too that the transform function is responsible for tidying any\n              // intermediate Tensors.  Here we are concerned only about the inputs.\n              mappedArray = this.transform(item.value);\n              outputTensors = tf.tensor_util.getTensorsInContainer(mappedArray);\n              this.outputQueue.pushAll(mappedArray);\n              // TODO(soergel) faster intersection, and deduplicate outputTensors\n              // TODO(soergel) move to tf.disposeExcept(in, out)?\n              _iterator3 = _createForOfIteratorHelper(inputTensors);\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  t = _step3.value;\n                  if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n                    t.dispose();\n                  }\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n              return _context24.abrupt(\"return\", true);\n            case 12:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n      function pump() {\n        return _pump.apply(this, arguments);\n      }\n      return pump;\n    }()\n  }]);\n  return FlatmapIterator;\n}(OneToManyIterator);\n/**\n * Provides a `LazyIterator` that concatenates a stream of underlying\n * streams.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n */\nexport var ChainedIterator = /*#__PURE__*/function (_LazyIterator12) {\n  _inherits(ChainedIterator, _LazyIterator12);\n  var _super13 = _createSuper(ChainedIterator);\n  function ChainedIterator(iterators, baseErrorHandler) {\n    var _this19;\n    _classCallCheck(this, ChainedIterator);\n    _this19 = _super13.call(this);\n    _this19.baseErrorHandler = baseErrorHandler;\n    // Strict Promise execution order:\n    // a next() call may not even begin until the previous one completes.\n    _this19.lastRead = null;\n    // Local state that should not be clobbered by out-of-order execution.\n    _this19.iterator = null;\n    _this19.moreIterators = iterators;\n    return _this19;\n  }\n  _createClass(ChainedIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      var upstreamSummaries = 'TODO: fill in upstream of chained summaries';\n      return \"\".concat(upstreamSummaries, \" -> Chained\");\n    }\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              this.lastRead = this.readFromChain(this.lastRead);\n              return _context25.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n      function next() {\n        return _next12.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"readFromChain\",\n    value: function () {\n      var _readFromChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(lastRead) {\n        var iteratorResult, itemResult;\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              _context26.next = 2;\n              return lastRead;\n            case 2:\n              if (!(this.iterator == null)) {\n                _context26.next = 10;\n                break;\n              }\n              _context26.next = 5;\n              return this.moreIterators.next();\n            case 5:\n              iteratorResult = _context26.sent;\n              if (!iteratorResult.done) {\n                _context26.next = 8;\n                break;\n              }\n              return _context26.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 8:\n              this.iterator = iteratorResult.value;\n              if (this.baseErrorHandler != null) {\n                this.iterator = this.iterator.handleErrors(this.baseErrorHandler);\n              }\n            case 10:\n              _context26.next = 12;\n              return this.iterator.next();\n            case 12:\n              itemResult = _context26.sent;\n              if (!itemResult.done) {\n                _context26.next = 16;\n                break;\n              }\n              this.iterator = null;\n              return _context26.abrupt(\"return\", this.readFromChain(lastRead));\n            case 16:\n              return _context26.abrupt(\"return\", itemResult);\n            case 17:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this);\n      }));\n      function readFromChain(_x4) {\n        return _readFromChain.apply(this, arguments);\n      }\n      return readFromChain;\n    }()\n  }]);\n  return ChainedIterator;\n}(LazyIterator);\nexport var ZipMismatchMode;\n(function (ZipMismatchMode) {\n  ZipMismatchMode[ZipMismatchMode[\"FAIL\"] = 0] = \"FAIL\";\n  ZipMismatchMode[ZipMismatchMode[\"SHORTEST\"] = 1] = \"SHORTEST\";\n  ZipMismatchMode[ZipMismatchMode[\"LONGEST\"] = 2] = \"LONGEST\"; // use nulls for exhausted streams; use up the longest stream.\n})(ZipMismatchMode || (ZipMismatchMode = {}));\n/**\n * Provides a `LazyIterator` that zips together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nvar ZipIterator = /*#__PURE__*/function (_LazyIterator13) {\n  _inherits(ZipIterator, _LazyIterator13);\n  var _super14 = _createSuper(ZipIterator);\n  function ZipIterator(iterators) {\n    var _this20;\n    var mismatchMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZipMismatchMode.FAIL;\n    _classCallCheck(this, ZipIterator);\n    _this20 = _super14.call(this);\n    _this20.iterators = iterators;\n    _this20.mismatchMode = mismatchMode;\n    _this20.count = 0;\n    _this20.currentPromise = null;\n    return _this20;\n  }\n  _createClass(ZipIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      var upstreamSummaries = 'TODO: fill in upstream of zip summaries';\n      return \"{\".concat(upstreamSummaries, \"} -> Zip\");\n    }\n  }, {\n    key: \"nextState\",\n    value: function () {\n      var _nextState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(afterState) {\n        var numIterators, iteratorsDone, getNext, mapped;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              getNext = function _getNext(container) {\n                if (container instanceof LazyIterator) {\n                  var result = container.next();\n                  return {\n                    value: result.then(function (x) {\n                      numIterators++;\n                      if (x.done) {\n                        iteratorsDone++;\n                      }\n                      return x.value;\n                    }),\n                    recurse: false\n                  };\n                } else {\n                  return {\n                    value: null,\n                    recurse: true\n                  };\n                }\n              };\n              _context27.next = 3;\n              return afterState;\n            case 3:\n              // Collect underlying iterator \"done\" signals as a side effect in\n              // getNext()\n              numIterators = 0;\n              iteratorsDone = 0;\n              _context27.next = 7;\n              return deepMapAndAwaitAll(this.iterators, getNext);\n            case 7:\n              mapped = _context27.sent;\n              if (!(numIterators === iteratorsDone)) {\n                _context27.next = 10;\n                break;\n              }\n              return _context27.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 10:\n              if (!(iteratorsDone > 0)) {\n                _context27.next = 16;\n                break;\n              }\n              _context27.t0 = this.mismatchMode;\n              _context27.next = _context27.t0 === ZipMismatchMode.FAIL ? 14 : _context27.t0 === ZipMismatchMode.SHORTEST ? 15 : _context27.t0 === ZipMismatchMode.LONGEST ? 16 : 16;\n              break;\n            case 14:\n              throw new Error('Zipped streams should have the same length. ' + \"Mismatched at element \".concat(this.count, \".\"));\n            case 15:\n              return _context27.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 16:\n              this.count++;\n              return _context27.abrupt(\"return\", {\n                value: mapped,\n                done: false\n              });\n            case 18:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee27, this);\n      }));\n      function nextState(_x5) {\n        return _nextState.apply(this, arguments);\n      }\n      return nextState;\n    }()\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) switch (_context28.prev = _context28.next) {\n            case 0:\n              this.currentPromise = this.nextState(this.currentPromise);\n              return _context28.abrupt(\"return\", this.currentPromise);\n            case 2:\n            case \"end\":\n              return _context28.stop();\n          }\n        }, _callee28, this);\n      }));\n      function next() {\n        return _next13.apply(this, arguments);\n      }\n      return next;\n    }()\n  }]);\n  return ZipIterator;\n}(LazyIterator); // Iterators that maintain a ring buffer of pending promises\n// ============================================================================\n/**\n * A stream that prefetches a given number of items from an upstream source,\n * returning them in FIFO order.\n *\n * Note this prefetches Promises, but makes no guarantees about when those\n * Promises resolve.\n */\nexport var PrefetchIterator = /*#__PURE__*/function (_LazyIterator14) {\n  _inherits(PrefetchIterator, _LazyIterator14);\n  var _super15 = _createSuper(PrefetchIterator);\n  function PrefetchIterator(upstream, bufferSize) {\n    var _this21;\n    _classCallCheck(this, PrefetchIterator);\n    _this21 = _super15.call(this);\n    _this21.upstream = upstream;\n    _this21.bufferSize = bufferSize;\n    _this21.buffer = new RingBuffer(bufferSize);\n    return _this21;\n  }\n  _createClass(PrefetchIterator, [{\n    key: \"summary\",\n    value: function summary() {\n      return \"\".concat(this.upstream.summary(), \" -> Prefetch\");\n    }\n    /**\n     * Refill the prefetch buffer.  Returns only after the buffer is full, or\n     * the upstream source is exhausted.\n     */\n  }, {\n    key: \"refill\",\n    value: function refill() {\n      while (!this.buffer.isFull()) {\n        var v = this.upstream.next();\n        this.buffer.push(v);\n      }\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      this.refill();\n      // This shift will never throw an error because the buffer is always\n      // full after a refill. If the stream is exhausted, the buffer will be\n      // full of Promises that will resolve to the end-of-stream signal.\n      return this.buffer.shift();\n    }\n  }]);\n  return PrefetchIterator;\n}(LazyIterator);\n/**\n * A stream that performs a sliding-window random shuffle on an upstream\n * source. This is like a `PrefetchIterator` except that the items are\n * returned in randomized order.  Mixing naturally improves as the buffer\n * size increases.\n */\nexport var ShuffleIterator = /*#__PURE__*/function (_PrefetchIterator) {\n  _inherits(ShuffleIterator, _PrefetchIterator);\n  var _super16 = _createSuper(ShuffleIterator);\n  function ShuffleIterator(upstream, windowSize, seed) {\n    var _this22;\n    _classCallCheck(this, ShuffleIterator);\n    _this22 = _super16.call(this, upstream, windowSize);\n    _this22.upstream = upstream;\n    _this22.windowSize = windowSize;\n    // Local state that should not be clobbered by out-of-order execution.\n    _this22.upstreamExhausted = false;\n    _this22.random = seedrandom.alea(seed || tf.util.now().toString());\n    _this22.lastRead = Promise.resolve({\n      value: null,\n      done: false\n    });\n    return _this22;\n  }\n  _createClass(ShuffleIterator, [{\n    key: \"next\",\n    value: function () {\n      var _next14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n        var _this23 = this;\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) switch (_context29.prev = _context29.next) {\n            case 0:\n              // This sets this.lastRead to a new Promise right away, as opposed to\n              // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n              // would not work because this.nextRead would be updated only after the\n              // promise resolves.\n              this.lastRead = this.lastRead.then(function () {\n                return _this23.serialNext();\n              });\n              return _context29.abrupt(\"return\", this.lastRead);\n            case 2:\n            case \"end\":\n              return _context29.stop();\n          }\n        }, _callee29, this);\n      }));\n      function next() {\n        return _next14.apply(this, arguments);\n      }\n      return next;\n    }()\n  }, {\n    key: \"randomInt\",\n    value: function randomInt(max) {\n      return Math.floor(this.random() * max);\n    }\n  }, {\n    key: \"chooseIndex\",\n    value: function chooseIndex() {\n      return this.randomInt(this.buffer.length());\n    }\n  }, {\n    key: \"serialNext\",\n    value: function () {\n      var _serialNext7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {\n        var chosenIndex, result;\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              // TODO(soergel): consider performance\n              if (!this.upstreamExhausted) {\n                this.refill();\n              }\n            case 1:\n              if (this.buffer.isEmpty()) {\n                _context30.next = 14;\n                break;\n              }\n              chosenIndex = this.chooseIndex();\n              _context30.next = 5;\n              return this.buffer.shuffleExcise(chosenIndex);\n            case 5:\n              result = _context30.sent;\n              if (!result.done) {\n                _context30.next = 10;\n                break;\n              }\n              this.upstreamExhausted = true;\n              _context30.next = 12;\n              break;\n            case 10:\n              this.refill();\n              return _context30.abrupt(\"return\", result);\n            case 12:\n              _context30.next = 1;\n              break;\n            case 14:\n              return _context30.abrupt(\"return\", {\n                value: null,\n                done: true\n              });\n            case 15:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee30, this);\n      }));\n      function serialNext() {\n        return _serialNext7.apply(this, arguments);\n      }\n      return serialNext;\n    }()\n  }]);\n  return ShuffleIterator;\n}(PrefetchIterator);","map":{"version":3,"mappings":"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","names":["tf","seedrandom","deepClone","deepMapAndAwaitAll","deepZip","zipToList","GrowingRingBuffer","RingBuffer","iteratorFromItems","items","ArrayIterator","iteratorFromIncrementing","start","i","iteratorFromFunction","value","done","func","FunctionCallIterator","iteratorFromConcatenated","baseIterators","baseErrorHandler","ChainedIterator","iteratorFromConcatenatedFunction","iteratorFunc","count","take","iteratorFromZipped","iterators","mismatchMode","ZipMismatchMode","FAIL","ZipIterator","LazyIterator","result","next","x","push","stream","prefetch","predicate","shouldContinue","handler","ErrorHandlingLazyIterator","FilterIterator","transform","MapIterator","AsyncMapIterator","serial","FlatmapIterator","f","map","resolveFully","serialMapAsync","resolveWhile","batchSize","smallLastBatch","RowMajorBatchIterator","zipFn","rowBatches","rowMajorBatch","iterator","TakeIterator","SkipIterator","bufferSize","PrefetchIterator","windowSize","seed","ShuffleIterator","SerialIterator","length","trav","item","nextFn","message","upstream","lastRead","Promise","resolve","summary","then","serialNext","maxCount","skipped","dispose","enableSmallLastBatch","batch","inputTensors","tensor_util","getTensorsInContainer","mapped","outputTensors","t","isTensorInList","OneToManyIterator","outputQueue","pump","shift","mappedArray","pushAll","moreIterators","upstreamSummaries","readFromChain","iteratorResult","handleErrors","itemResult","afterState","getNext","container","numIterators","iteratorsDone","recurse","SHORTEST","LONGEST","Error","currentPromise","nextState","buffer","isFull","v","refill","random","alea","util","now","toString","max","Math","floor","randomInt","upstreamExhausted","isEmpty","chosenIndex","chooseIndex","shuffleExcise"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-data\\src\\iterators\\lazy_iterator.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\n\nimport {Container} from '../types';\nimport {deepClone} from '../util/deep_clone';\nimport {deepMapAndAwaitAll, DeepMapAsyncResult, DeepMapResult, deepZip, zipToList} from '../util/deep_map';\nimport {GrowingRingBuffer} from '../util/growing_ring_buffer';\nimport {RingBuffer} from '../util/ring_buffer';\n\n/**\n * A nested structure of LazyIterators, used as the input to zip().\n */\nexport type IteratorContainer = Container<LazyIterator<tf.TensorContainer>>;\n\n// Here we implement a simple asynchronous iterator.\n// This lets us avoid using either third-party stream libraries or\n// recent TypeScript language support requiring polyfills.\n\n/**\n * Create a `LazyIterator` from an array of items.\n */\nexport function iteratorFromItems<T>(items: T[]): LazyIterator<T> {\n  return new ArrayIterator(items);\n}\n\n/**\n * Create a `LazyIterator` of incrementing integers.\n */\nexport function iteratorFromIncrementing(start: number): LazyIterator<number> {\n  let i = start;\n  return iteratorFromFunction(() => ({value: i++, done: false}));\n}\n\n/**\n * Create a `LazyIterator` from a function.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const iter = tf.data.iteratorFromFunction(func);\n * await iter.forEachAsync(e => console.log(e));\n * ```\n *\n * @param func A function that produces data on each call.\n */\nexport function iteratorFromFunction<T>(\n    func: () =>\n        IteratorResult<T>| Promise<IteratorResult<T>>): LazyIterator<T> {\n  return new FunctionCallIterator(func);\n}\n\n/**\n * Create a `LazyIterator` by concatenating underlying streams, which are\n * themselves provided as a stream.\n *\n * This can also be thought of as a \"stream flatten\" operation.\n *\n * @param baseIterators A stream of streams to be concatenated.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenated<T>(\n    baseIterators: LazyIterator<LazyIterator<T>>,\n    baseErrorHandler?: (e: Error) => boolean): LazyIterator<T> {\n  return new ChainedIterator(baseIterators, baseErrorHandler);\n}\n\n/**\n * Create a `LazyIterator` by concatenating streams produced by calling a\n * stream-generating function a given number of times.\n *\n * Since a `LazyIterator` is read-once, it cannot be repeated, but this\n * function can be used to achieve a similar effect:\n *\n *   LazyIterator.ofConcatenatedFunction(() => new MyIterator(), 6);\n *\n * @param iteratorFunc: A function that produces a new stream on each call.\n * @param count: The number of times to call the function.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenatedFunction<T>(\n    iteratorFunc: () => IteratorResult<LazyIterator<T>>, count: number,\n    baseErrorHandler?: (e: Error) => boolean): LazyIterator<T> {\n  return iteratorFromConcatenated(\n      iteratorFromFunction(iteratorFunc).take(count), baseErrorHandler);\n}\n\n/**\n * Create a `LazyIterator` by zipping together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nexport function iteratorFromZipped<O extends tf.TensorContainer>(\n    iterators: IteratorContainer,\n    mismatchMode: ZipMismatchMode = ZipMismatchMode.FAIL): LazyIterator<O> {\n  return new ZipIterator<O>(iterators, mismatchMode);\n}\n\n/**\n * An asynchronous iterator, providing lazy access to a potentially\n * unbounded stream of elements.\n *\n * Iterator can be obtained from a dataset:\n * `const iter = await dataset.iterator();`\n */\nexport abstract class LazyIterator<T> {\n  // This class implements AsyncIterator<T>, but we have not yet set the\n  // TypeScript --downlevelIteration flag to enable that.\n\n  abstract summary(): string;\n\n  /**\n   * Returns a `Promise` for the next element in the stream.\n   *\n   * When an item can be provided successfully, the return value is\n   * `{value:T, done:false}`.\n   *\n   * Calling next() on a closed stream returns `{value:null, done:true}`.\n   */\n  abstract next(): Promise<IteratorResult<T>>;\n\n  /**\n   * Collect all remaining elements of a bounded stream into an array.\n   * Obviously this will succeed only for small streams that fit in memory.\n   * Useful for testing.\n   *\n   * @returns A Promise for an array of stream elements, which will resolve\n   *   when the stream is exhausted.\n   */\n  async toArray(): Promise<T[]> {\n    const result: T[] = [];\n    let x = await this.next();\n    while (!x.done) {\n      result.push(x.value);\n      x = await this.next();\n    }\n    return result;\n  }\n\n  /**\n   * Collect all elements of this dataset into an array with prefetching 100\n   * elements. This is useful for testing, because the prefetch changes the\n   * order in which the Promises are resolved along the processing pipeline.\n   * This may help expose bugs where results are dependent on the order of\n   * Promise resolution rather than on the logical order of the stream (i.e.,\n   * due to hidden mutable state).\n   *\n   * @returns A Promise for an array of stream elements, which will resolve\n   *   when the stream is exhausted.\n   */\n  async toArrayForTest(): Promise<T[]> {\n    const stream = this.prefetch(100);\n    const result: T[] = [];\n    let x = await stream.next();\n    while (!x.done) {\n      result.push(x.value);\n      x = await stream.next();\n    }\n    return result;\n  }\n\n  /**\n   * Draw items from the stream until it is exhausted.\n   *\n   * This can be useful when the stream has side effects but no output.  In\n   * that case, calling this function guarantees that the stream will be\n   * fully processed.\n   */\n  async resolveFully(): Promise<void> {\n    let x = await this.next();\n    while (!x.done) {\n      x = await this.next();\n    }\n  }\n\n  /**\n   * Draw items from the stream until it is exhausted, or a predicate fails.\n   *\n   * This can be useful when the stream has side effects but no output.  In\n   * that case, calling this function guarantees that the stream will be\n   * fully processed.\n   */\n  async resolveWhile(predicate: (r: T) => boolean): Promise<void> {\n    let x = await this.next();\n    let shouldContinue = predicate(x.value);\n    while ((!x.done) && shouldContinue) {\n      x = await this.next();\n      shouldContinue = predicate(x.value);\n    }\n  }\n\n  /**\n   * Handles errors thrown on this stream using a provided handler function.\n   *\n   * @param handler A function that handles any `Error` thrown during a `next()`\n   *   call and returns true if the stream should continue (dropping the failed\n   *   call) or false if the stream should quietly terminate.  If the handler\n   *   itself throws (or rethrows) an `Error`, that will be propagated.\n   *\n   * @returns A `LazyIterator` of elements passed through from upstream,\n   *   possibly filtering or terminating on upstream `next()` calls that\n   *   throw an `Error`.\n   */\n  handleErrors(handler: (error: Error) => boolean): LazyIterator<T> {\n    return new ErrorHandlingLazyIterator(this, handler);\n  }\n\n  // TODO(soergel): Implement reduce() etc.\n\n  /**\n   * Filters this stream according to `predicate`.\n   *\n   * @param predicate A function mapping a stream element to a boolean or a\n   * `Promise` for one.\n   *\n   * @returns A `LazyIterator` of elements for which the predicate was true.\n   */\n  filter(predicate: (value: T) => boolean): LazyIterator<T> {\n    return new FilterIterator(this, predicate);\n  }\n\n  /**\n   * Maps this stream through a 1-to-1 transform.\n   *\n   * @param transform A function mapping a stream element to a transformed\n   *   element.\n   *\n   * @returns A `LazyIterator` of transformed elements.\n   */\n  map<O>(transform: (value: T) => O): LazyIterator<O> {\n    return new MapIterator(this, transform);\n  }\n\n  /**\n   * Maps this stream through an async 1-to-1 transform.\n   *\n   * @param transform A function mapping a stream element to a `Promise` for a\n   *   transformed stream element.\n   *\n   * @returns A `LazyIterator` of transformed elements.\n   */\n  mapAsync<O>(transform: (value: T) => Promise<O>): LazyIterator<O> {\n    return new AsyncMapIterator(this, transform);\n  }\n\n  /**\n   * Maps this stream through a 1-to-1 transform, forcing serial execution.\n   *\n   * @param transform A function mapping a stream element to a transformed\n   *   element.\n   *\n   * @returns A `LazyIterator` of transformed elements.\n   */\n  serialMapAsync<O>(transform: (value: T) => Promise<O>): LazyIterator<O> {\n    return new AsyncMapIterator(this, transform).serial();\n  }\n\n  /**\n   * Maps this stream through a 1-to-many transform.\n   *\n   * @param transform A function mapping a stream element to an array of\n   *   transformed elements.\n   *\n   * @returns A `DataStream` of transformed elements.\n   */\n  flatmap<O>(transform: (value: T) => O[]): LazyIterator<O> {\n    return new FlatmapIterator(this, transform);\n  }\n\n  /**\n   * Apply a function to every element of the stream.\n   *\n   * @param f A function to apply to each stream element.\n   */\n  async forEachAsync(f: (value: T) => void): Promise<void> {\n    return this.map(f).resolveFully();\n  }\n\n  /**\n   * Apply a function to every element of the stream, forcing serial execution.\n   *\n   * @param f A function to apply to each stream element.  Should return 'true'\n   *   to indicate that the stream should continue, or 'false' to cause it to\n   *   terminate.\n   */\n  async serialForEach(f: (value: T) => Promise<boolean>): Promise<void> {\n    return this.serialMapAsync(f).resolveWhile(x => (x === true));\n  }\n\n  /**\n   * Groups elements into batches, represented as arrays of elements.\n   *\n   * We can think of the elements of this iterator as 'rows' (even if they are\n   * nested structures).  By the same token, consecutive values for a given\n   * key within the elements form a 'column'.  This matches the usual sense of\n   * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n   *\n   * Thus, \"Row-major\" means that the resulting batch is simply a collection of\n   * rows: `[row1, row2, row3, ...]`.  This is contrast to the column-major\n   * form, which is needed for vectorized computation.\n   *\n   * @param batchSize The number of elements desired per batch.\n   * @param smallLastBatch Whether to emit the final batch when it has fewer\n   *   than batchSize elements. Default true.\n   * @returns A `LazyIterator` of batches of elements, represented as arrays\n   *   of the original element type.\n   */\n  rowMajorBatch(batchSize: number, smallLastBatch = true): LazyIterator<T[]> {\n    return new RowMajorBatchIterator(this, batchSize, smallLastBatch);\n  }\n\n  /**\n   * Groups elements into batches, represented in column-major form.\n   *\n   * We can think of the elements of this iterator as 'rows' (even if they are\n   * nested structures).  By the same token, consecutive values for a given\n   * key within the elements form a 'column'.  This matches the usual sense of\n   * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n   *\n   * Thus, \"column-major\" means that the resulting batch is a (potentially\n   * nested) structure representing the columns.  Each column entry, then,\n   * contains a collection of the values found in that column for a range of\n   * input elements.  This representation allows for vectorized computation, in\n   * contrast to the row-major form.\n   *\n   * The inputs should all have the same nested structure (i.e., of arrays and\n   * dicts).  The result is a single object with the same nested structure,\n   * where the leaves are arrays collecting the values of the inputs at that\n   * location (or, optionally, the result of a custom function applied to those\n   * arrays).\n   *\n   * @param batchSize The number of elements desired per batch.\n   * @param smallLastBatch Whether to emit the final batch when it has fewer\n   *   than batchSize elements. Default true.\n   * @param zipFn: (optional) A function that expects an array of elements at a\n   *   single node of the object tree, and returns a `DeepMapResult`.  The\n   *   `DeepMapResult` either provides a result value for that node (i.e.,\n   *   representing the subtree), or indicates that the node should be processed\n   *   recursively.  The default zipFn recurses as far as possible and places\n   *   arrays at the leaves.\n   * @returns A `LazyIterator` of batches of elements, represented as an object\n   *   with collections at the leaves.\n   */\n  columnMajorBatch(\n      batchSize: number, smallLastBatch = true,\n      // tslint:disable-next-line:no-any\n      zipFn: (xs: any[]) => DeepMapResult = zipToList):\n      LazyIterator<tf.TensorContainer> {\n    // First collect the desired number of input elements as a row-major batch.\n    const rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);\n    // Now 'rotate' or 'pivot' the data, collecting all values from each column\n    // in the batch (i.e., for each key within the elements) into an array.\n    return rowBatches.map(x => deepZip(x, zipFn));\n  }\n\n  /**\n   * Concatenate this `LazyIterator` with another.\n   *\n   * @param iterator A `LazyIterator` to be concatenated onto this one.\n   * @param baseErrorHandler An optional function that can intercept `Error`s\n   *   raised during a `next()` call on the base stream.  This function can\n   *   decide whether the error should be propagated, whether the error should\n   *   be ignored, or whether the base stream should be terminated.\n   * @returns A `LazyIterator`.\n   */\n  concatenate(\n      iterator: LazyIterator<T>,\n      baseErrorHandler?: (e: Error) => boolean): LazyIterator<T> {\n    return new ChainedIterator(\n        iteratorFromItems([this, iterator]), baseErrorHandler);\n  }\n\n  /**\n   * Limits this stream to return at most `count` items.\n   *\n   * @param count The maximum number of items to provide from the stream. If\n   * a negative or undefined value is given, the entire stream is returned\n   *   unaltered.\n   */\n  take(count: number): LazyIterator<T> {\n    if (count < 0 || count == null) {\n      return this;\n    }\n    return new TakeIterator(this, count);\n  }\n\n  /**\n   * Skips the first `count` items in this stream.\n   *\n   * @param count The number of items to skip.  If a negative or undefined\n   * value is given, the entire stream is returned unaltered.\n   */\n  skip(count: number): LazyIterator<T> {\n    if (count < 0 || count == null) {\n      return this;\n    }\n    return new SkipIterator(this, count);\n  }\n\n  /**\n   * Prefetch the first `bufferSize` items in this stream.\n   *\n   * Note this prefetches Promises, but makes no guarantees about when those\n   * Promises resolve.\n   *\n   * @param bufferSize: An integer specifying the number of elements to be\n   *   prefetched.\n   */\n  prefetch(bufferSize: number): LazyIterator<T> {\n    return new PrefetchIterator(this, bufferSize);\n  }\n\n  // TODO(soergel): deep sharded shuffle, where supported\n\n  /**\n   * Randomly shuffles the elements of this stream.\n   *\n   * @param bufferSize: An integer specifying the number of elements from\n   * this stream from which the new stream will sample.\n   * @param seed: (Optional.) An integer specifying the random seed that\n   * will be used to create the distribution.\n   */\n  shuffle(windowSize: number, seed?: string): LazyIterator<T> {\n    return new ShuffleIterator(this, windowSize, seed);\n  }\n\n  /**\n   * Force an iterator to execute serially: each next() call will await the\n   * prior one, so that they cannot execute concurrently.\n   */\n  serial(): LazyIterator<T> {\n    return new SerialIterator(this);\n  }\n}\n\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on LazyIterator.  Unfortunately they can't be placed in separate files,\n// due to resulting trouble with circular imports.\n// ============================================================================\n\n// Iterators that just extend LazyIterator directly\n// ============================================================================\n\nclass ArrayIterator<T> extends LazyIterator<T> {\n  private trav = 0;\n  constructor(protected items: T[]) {\n    super();\n  }\n\n  summary() {\n    return `Array of ${this.items.length} items`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    if (this.trav >= this.items.length) {\n      return {value: null, done: true};\n    }\n    const item = this.items[this.trav];\n    this.trav++;\n    return {value: deepClone(item), done: false};\n  }\n}\n\nclass FunctionCallIterator<T> extends LazyIterator<T> {\n  constructor(\n      protected nextFn: () => IteratorResult<T>| Promise<IteratorResult<T>>) {\n    super();\n  }\n\n  summary() {\n    return `Function call`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    try {\n      return this.nextFn();\n    } catch (e) {\n      // Modify the error message but leave the stack trace intact\n      e.message =\n          `Error thrown while iterating through a dataset: ${e.message}`;\n      throw e;\n    }\n  }\n}\n\nclass SerialIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  constructor(protected upstream: LazyIterator<T>) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Serial`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private async serialNext(): Promise<IteratorResult<T>> {\n    return this.upstream.next();\n  }\n}\n\nclass SkipIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  // Local state that should not be clobbered by out-of-order execution.\n  count = 0;\n\n  constructor(protected upstream: LazyIterator<T>, protected maxCount: number) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Skip`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private async serialNext(): Promise<IteratorResult<T>> {\n    // TODO(soergel): consider tradeoffs of reading in parallel, eg.\n    // collecting next() promises in an Array and then waiting for\n    // Promise.all() of those. Benefit: pseudo-parallel execution.  Drawback:\n    // maybe delayed GC.\n    while (this.count++ < this.maxCount) {\n      const skipped = await this.upstream.next();\n      // short-circuit if upstream is already empty\n      if (skipped.done) {\n        return skipped;\n      }\n      tf.dispose(skipped.value as {});\n    }\n    return this.upstream.next();\n  }\n}\n\nclass TakeIterator<T> extends LazyIterator<T> {\n  count = 0;\n  constructor(protected upstream: LazyIterator<T>, protected maxCount: number) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Take`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    if (this.count++ >= this.maxCount) {\n      return {value: null, done: true};\n    }\n    return this.upstream.next();\n  }\n}\n\n// Note this batch just groups items into row-wise element arrays.\n// Rotating these to a column-wise representation happens only at the dataset\n// level.\nclass RowMajorBatchIterator<T> extends LazyIterator<T[]> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T[]>>;\n\n  constructor(\n      protected upstream: LazyIterator<T>, protected batchSize: number,\n      protected enableSmallLastBatch = true) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> RowMajorBatch`;\n  }\n\n  async next(): Promise<IteratorResult<T[]>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private async serialNext(): Promise<IteratorResult<T[]>> {\n    const batch: T[] = [];\n    while (batch.length < this.batchSize) {\n      const item = await this.upstream.next();\n      if (item.done) {\n        if (this.enableSmallLastBatch && batch.length > 0) {\n          return {value: batch, done: false};\n        }\n        return {value: null, done: true};\n      }\n      batch.push(item.value);\n    }\n    return {value: batch, done: false};\n  }\n}\n\nclass FilterIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  constructor(\n      protected upstream: LazyIterator<T>,\n      protected predicate: (value: T) => boolean) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Filter`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private async serialNext(): Promise<IteratorResult<T>> {\n    while (true) {\n      const item = await this.upstream.next();\n      if (item.done || this.predicate(item.value)) {\n        return item;\n      }\n      tf.dispose(item.value as {});\n    }\n  }\n}\n\nclass MapIterator<I, O> extends LazyIterator<O> {\n  constructor(\n      protected upstream: LazyIterator<I>,\n      protected transform: (value: I) => O) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Map`;\n  }\n\n  async next(): Promise<IteratorResult<O>> {\n    const item = await this.upstream.next();\n    if (item.done) {\n      return {value: null, done: true};\n    }\n    const inputTensors = tf.tensor_util.getTensorsInContainer(item.value as {});\n    // Careful: the transform may mutate the item in place.\n    // That's why we have to remember the input Tensors above, and then\n    // below dispose only those that were not passed through to the output.\n    // Note too that the transform function is responsible for tidying\n    // any intermediate Tensors.  Here we are concerned only about the\n    // inputs.\n    const mapped = this.transform(item.value);\n    const outputTensors = tf.tensor_util.getTensorsInContainer(mapped as {});\n\n    // TODO(soergel) faster intersection\n    // TODO(soergel) move to tf.disposeExcept(in, out)?\n    for (const t of inputTensors) {\n      if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n        t.dispose();\n      }\n    }\n    return {value: mapped, done: false};\n  }\n}\n\nclass ErrorHandlingLazyIterator<T> extends LazyIterator<T> {\n  count = 0;\n  constructor(\n      protected upstream: LazyIterator<T>,\n      protected handler: (error: Error) => boolean) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> handleErrors`;\n  }\n\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  async serialNext(): Promise<IteratorResult<T>> {\n    while (true) {\n      try {\n        return await this.upstream.next();\n      } catch (e) {\n        if (!this.handler(e)) {\n          return {value: null, done: true};\n        }\n        // If the handler returns true, loop and fetch the next upstream item.\n\n        // If the upstream iterator throws an endless stream of errors, and if\n        // the handler says to ignore them, then we loop forever here.  That is\n        // the correct behavior-- it's up to the handler to decide when to stop.\n      }\n    }\n  }\n}\n\nclass AsyncMapIterator<I, O> extends LazyIterator<O> {\n  constructor(\n      protected upstream: LazyIterator<I>,\n      protected transform: (value: I) => Promise<O>) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> AsyncMap`;\n  }\n\n  async next(): Promise<IteratorResult<O>> {\n    const item = await this.upstream.next();\n    if (item.done) {\n      return {value: null, done: true};\n    }\n    const inputTensors = tf.tensor_util.getTensorsInContainer(item.value as {});\n    // Careful: the transform may mutate the item in place.\n    // That's why we have to remember the input Tensors above, and then\n    // below dispose only those that were not passed through to the output.\n    // Note too that the transform function is responsible for tidying\n    // any intermediate Tensors.  Here we are concerned only about the\n    // inputs.\n    const mapped = await this.transform(item.value);\n    const outputTensors = tf.tensor_util.getTensorsInContainer(mapped as {});\n\n    // TODO(soergel) faster intersection\n    // TODO(soergel) move to tf.disposeExcept(in, out)?\n    for (const t of inputTensors) {\n      if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n        t.dispose();\n      }\n    }\n    return {value: mapped, done: false};\n  }\n}\n\n// Iterators that maintain a queue of pending items\n// ============================================================================\n\n/**\n * A base class for transforming streams that operate by maintaining an\n * output queue of elements that are ready to return via next().  This is\n * commonly required when the transformation is 1-to-many:  A call to next()\n * may trigger a call to the underlying stream, which will produce many\n * mapped elements of this stream-- of which we need to return only one, so\n * we have to queue the rest.\n */\nexport abstract class OneToManyIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  // Local state that should not be clobbered by out-of-order execution.\n  protected outputQueue: RingBuffer<T>;\n\n  constructor() {\n    super();\n    this.outputQueue = new GrowingRingBuffer<T>();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  /**\n   * Read one or more chunks from upstream and process them, possibly\n   * reading or writing a carryover, and adding processed items to the\n   * output queue.  Note it's possible that no items are added to the queue\n   * on a given pump() call, even if the upstream stream is not closed\n   * (e.g., because items are filtered).\n   *\n   * @return `true` if any action was taken, i.e. fetching items from the\n   *   upstream source OR adding items to the output queue.  `false` if the\n   *   upstream source is exhausted AND nothing was added to the queue\n   * (i.e., any remaining carryover).\n   */\n  protected abstract pump(): Promise<boolean>;\n\n  async serialNext(): Promise<IteratorResult<T>> {\n    // Fetch so that the queue contains at least one item if possible.\n    // If the upstream source is exhausted, AND there are no items left in\n    // the output queue, then this stream is also exhausted.\n    while (this.outputQueue.length() === 0) {\n      // TODO(soergel): consider parallel reads.\n      if (!await this.pump()) {\n        return {value: null, done: true};\n      }\n    }\n    return {value: this.outputQueue.shift(), done: false};\n  }\n}\nclass FlatmapIterator<I, O> extends OneToManyIterator<O> {\n  constructor(\n      protected upstream: LazyIterator<I>,\n      protected transform: (value: I) => O[]) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Flatmap`;\n  }\n\n  async pump(): Promise<boolean> {\n    const item = await this.upstream.next();\n    if (item.done) {\n      return false;\n    }\n    const inputTensors = tf.tensor_util.getTensorsInContainer(item.value as {});\n    // Careful: the transform may mutate the item in place.\n    // that's why we have to remember the input Tensors above, and then\n    // below dispose only those that were not passed through to the output.\n    // Note too that the transform function is responsible for tidying any\n    // intermediate Tensors.  Here we are concerned only about the inputs.\n    const mappedArray = this.transform(item.value);\n    const outputTensors =\n        tf.tensor_util.getTensorsInContainer(mappedArray as {});\n    this.outputQueue.pushAll(mappedArray);\n\n    // TODO(soergel) faster intersection, and deduplicate outputTensors\n    // TODO(soergel) move to tf.disposeExcept(in, out)?\n    for (const t of inputTensors) {\n      if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n        t.dispose();\n      }\n    }\n\n    return true;\n  }\n}\n\n/**\n * Provides a `LazyIterator` that concatenates a stream of underlying\n * streams.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n */\nexport class ChainedIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>> = null;\n\n  // Local state that should not be clobbered by out-of-order execution.\n  private iterator: LazyIterator<T> = null;\n  private moreIterators: LazyIterator<LazyIterator<T>>;\n\n  constructor(\n      iterators: LazyIterator<LazyIterator<T>>,\n      private readonly baseErrorHandler?: (e: Error) => boolean) {\n    super();\n    this.moreIterators = iterators;\n  }\n\n  summary() {\n    const upstreamSummaries = 'TODO: fill in upstream of chained summaries';\n    return `${upstreamSummaries} -> Chained`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    this.lastRead = this.readFromChain(this.lastRead);\n    return this.lastRead;\n  }\n\n  private async readFromChain(lastRead: Promise<IteratorResult<T>>):\n      Promise<IteratorResult<T>> {\n    // Must await on the previous read since the previous read may have advanced\n    // the stream of streams, from which we need to read.\n    // This is unfortunate since we can't parallelize reads. Which means\n    // prefetching of chained streams is a no-op.\n    // One solution is to prefetch immediately upstream of this.\n    await lastRead;\n    if (this.iterator == null) {\n      const iteratorResult = await this.moreIterators.next();\n      if (iteratorResult.done) {\n        // No more streams to stream from.\n        return {value: null, done: true};\n      }\n      this.iterator = iteratorResult.value;\n      if (this.baseErrorHandler != null) {\n        this.iterator = this.iterator.handleErrors(this.baseErrorHandler);\n      }\n    }\n    const itemResult = await this.iterator.next();\n    if (itemResult.done) {\n      this.iterator = null;\n      return this.readFromChain(lastRead);\n    }\n    return itemResult;\n  }\n}\n\nexport enum ZipMismatchMode {\n  FAIL,      // require zipped streams to have the same length\n  SHORTEST,  // terminate zip when the first stream is exhausted\n  LONGEST    // use nulls for exhausted streams; use up the longest stream.\n}\n\n/**\n * Provides a `LazyIterator` that zips together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nclass ZipIterator<O extends tf.TensorContainer> extends LazyIterator<O> {\n  private count = 0;\n  private currentPromise: Promise<IteratorResult<O>> = null;\n\n  constructor(\n      protected readonly iterators: IteratorContainer,\n      protected readonly mismatchMode: ZipMismatchMode = ZipMismatchMode.FAIL) {\n    super();\n  }\n\n  summary() {\n    const upstreamSummaries = 'TODO: fill in upstream of zip summaries';\n    return `{${upstreamSummaries}} -> Zip`;\n  }\n\n  private async nextState(afterState: Promise<IteratorResult<O>>):\n      Promise<IteratorResult<O>> {\n    // This chaining ensures that the underlying next() are not even called\n    // before the previous ones have resolved.\n    await afterState;\n\n    // Collect underlying iterator \"done\" signals as a side effect in\n    // getNext()\n    let numIterators = 0;\n    let iteratorsDone = 0;\n\n    function getNext(container: IteratorContainer): DeepMapAsyncResult {\n      if (container instanceof LazyIterator) {\n        const result = container.next();\n        return {\n          value: result.then(x => {\n            numIterators++;\n            if (x.done) {\n              iteratorsDone++;\n            }\n            return x.value;\n          }),\n          recurse: false\n        };\n      } else {\n        return {value: null, recurse: true};\n      }\n    }\n\n    const mapped: O = await deepMapAndAwaitAll(this.iterators, getNext);\n\n    if (numIterators === iteratorsDone) {\n      // The streams have all ended.\n      return {value: null, done: true};\n    }\n    if (iteratorsDone > 0) {\n      switch (this.mismatchMode) {\n        case ZipMismatchMode.FAIL:\n          throw new Error(\n              'Zipped streams should have the same length. ' +\n              `Mismatched at element ${this.count}.`);\n        case ZipMismatchMode.SHORTEST:\n          return {value: null, done: true};\n        case ZipMismatchMode.LONGEST:\n        default:\n          // Continue.  The exhausted streams already produced value: null.\n      }\n    }\n\n    this.count++;\n    return {value: mapped, done: false};\n  }\n\n  async next(): Promise<IteratorResult<O>> {\n    this.currentPromise = this.nextState(this.currentPromise);\n    return this.currentPromise;\n  }\n}\n\n// Iterators that maintain a ring buffer of pending promises\n// ============================================================================\n\n/**\n * A stream that prefetches a given number of items from an upstream source,\n * returning them in FIFO order.\n *\n * Note this prefetches Promises, but makes no guarantees about when those\n * Promises resolve.\n */\nexport class PrefetchIterator<T> extends LazyIterator<T> {\n  protected buffer: RingBuffer<Promise<IteratorResult<T>>>;\n\n  constructor(\n      protected upstream: LazyIterator<T>, protected bufferSize: number) {\n    super();\n    this.buffer = new RingBuffer<Promise<IteratorResult<T>>>(bufferSize);\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Prefetch`;\n  }\n\n  /**\n   * Refill the prefetch buffer.  Returns only after the buffer is full, or\n   * the upstream source is exhausted.\n   */\n  protected refill() {\n    while (!this.buffer.isFull()) {\n      const v = this.upstream.next();\n      this.buffer.push(v);\n    }\n  }\n\n  next(): Promise<IteratorResult<T>> {\n    this.refill();\n    // This shift will never throw an error because the buffer is always\n    // full after a refill. If the stream is exhausted, the buffer will be\n    // full of Promises that will resolve to the end-of-stream signal.\n    return this.buffer.shift();\n  }\n}\n\n/**\n * A stream that performs a sliding-window random shuffle on an upstream\n * source. This is like a `PrefetchIterator` except that the items are\n * returned in randomized order.  Mixing naturally improves as the buffer\n * size increases.\n */\nexport class ShuffleIterator<T> extends PrefetchIterator<T> {\n  private readonly random: seedrandom.prng;\n\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  // Local state that should not be clobbered by out-of-order execution.\n  private upstreamExhausted = false;\n\n  constructor(\n    protected override upstream: LazyIterator<T>, protected windowSize: number,\n      seed?: string) {\n    super(upstream, windowSize);\n    this.random = seedrandom.alea(seed || tf.util.now().toString());\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  override async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private randomInt(max: number) {\n    return Math.floor(this.random() * max);\n  }\n\n  protected chooseIndex(): number {\n    return this.randomInt(this.buffer.length());\n  }\n\n  async serialNext(): Promise<IteratorResult<T>> {\n    // TODO(soergel): consider performance\n    if (!this.upstreamExhausted) {\n      this.refill();\n    }\n    while (!this.buffer.isEmpty()) {\n      const chosenIndex = this.chooseIndex();\n      const result = await this.buffer.shuffleExcise(chosenIndex);\n      if (result.done) {\n        this.upstreamExhausted = true;\n      } else {\n        this.refill();\n        return result;\n      }\n    }\n    return {value: null, done: true};\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}