{"ast":null,"code":"import _regeneratorRuntime from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { scalar } from '@tensorflow/tfjs-core';\nimport { TensorArray } from '../../executor/tensor_array';\nimport { fromTensor, reserve, scatter, split } from '../../executor/tensor_list';\nimport { cloneTensor, getParamValue, getTensor } from './utils';\nexport var executeOp = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(node, tensorMap, context) {\n    var thenFunc, elseFunc, cond, args, condValue, bodyFunc, condFunc, _args, condResult, argIds, _condValue, result, _loop, pred, _pred, data, inputName, _data, frameId, _data2, _data3, _data4, size, dtype, elementShape, dynamicSize, clearAfterRead, identicalElementShapes, name, tensorArray, id, index, writeTensor, writeTensorArray, readId, readIndex, readTensorArray, gatherId, gatherIndices, gatherDtype, gatherTensorArray, scatterId, scatterIndices, scatterTensor, scatterTensorArray, concatId, concatTensorArray, concatDtype, splitId, splitTensor, lengths, splitTensorArray, sizeId, sizeTensorArray, closeId, closeTensorArray, idTensor, _index, _writeTensor, tensorList, _idTensor, _readIndex, _elementShape, elementDType, _tensorList, _scatterIndices, _scatterTensor, _elementShape2, numElements, _tensorList2, _elementShape3, elementDtype, numElementsParam, _numElements, maxNumElements, _tensorList3, _gatherId, _gatherIndices, _elementShape4, _elementDtype, _tensorList4, _idTensor2, _elementShape5, _elementDtype2, _numElements2, _tensorList5, tensor, _elementShape6, _elementDtype3, _tensorList6, _concatId, _tensorList7, _concatDtype, _elementShape7, _idTensor3, _writeTensor2, _tensorList8, _idTensor4, _elementShape8, _elementDType, _tensorList9, _splitTensor, _elementShape9, _lengths, _tensorList10, _idTensor5, _tensorList11, _idTensor6, _size, srcTensorList, destTensorList;\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.t0 = node.op;\n          _context2.next = _context2.t0 === 'If' ? 3 : _context2.t0 === 'StatelessIf' ? 3 : _context2.t0 === 'While' ? 15 : _context2.t0 === 'StatelessWhile' ? 15 : _context2.t0 === 'LoopCond' ? 33 : _context2.t0 === 'Switch' ? 35 : _context2.t0 === 'Merge' ? 46 : _context2.t0 === 'Enter' ? 51 : _context2.t0 === 'Exit' ? 55 : _context2.t0 === 'NextIteration' ? 58 : _context2.t0 === 'TensorArrayV3' ? 61 : _context2.t0 === 'TensorArrayWriteV3' ? 71 : _context2.t0 === 'TensorArrayReadV3' ? 77 : _context2.t0 === 'TensorArrayGatherV3' ? 81 : _context2.t0 === 'TensorArrayScatterV3' ? 86 : _context2.t0 === 'TensorArrayConcatV3' ? 92 : _context2.t0 === 'TensorArraySplitV3' ? 96 : _context2.t0 === 'TensorArraySizeV3' ? 102 : _context2.t0 === 'TensorArrayCloseV3' ? 105 : _context2.t0 === 'TensorListSetItem' ? 109 : _context2.t0 === 'TensorListGetItem' ? 115 : _context2.t0 === 'TensorListScatterV2' ? 121 : _context2.t0 === 'TensorListScatter' ? 121 : _context2.t0 === 'TensorListReserve' ? 128 : _context2.t0 === 'EmptyTensorList' ? 128 : _context2.t0 === 'TensorListGather' ? 136 : _context2.t0 === 'TensorListStack' ? 142 : _context2.t0 === 'TensorListFromTensor' ? 148 : _context2.t0 === 'TensorListConcat' ? 154 : _context2.t0 === 'TensorListConcatV2' ? 154 : _context2.t0 === 'TensorListPushBack' ? 159 : _context2.t0 === 'TensorListPopBack' ? 164 : _context2.t0 === 'TensorListSplit' ? 169 : _context2.t0 === 'TensorListLength' ? 175 : _context2.t0 === 'TensorListResize' ? 178 : 184;\n          break;\n        case 3:\n          thenFunc = getParamValue('thenBranch', node, tensorMap, context);\n          elseFunc = getParamValue('elseBranch', node, tensorMap, context);\n          cond = getParamValue('cond', node, tensorMap, context);\n          args = getParamValue('args', node, tensorMap, context);\n          _context2.next = 9;\n          return cond.data();\n        case 9:\n          condValue = _context2.sent;\n          if (!condValue[0]) {\n            _context2.next = 14;\n            break;\n          }\n          return _context2.abrupt(\"return\", context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap));\n        case 14:\n          return _context2.abrupt(\"return\", context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap));\n        case 15:\n          bodyFunc = getParamValue('body', node, tensorMap, context);\n          condFunc = getParamValue('cond', node, tensorMap, context);\n          _args = getParamValue('args', node, tensorMap, context); // Calculate the condition of the loop\n          _context2.next = 20;\n          return context.functionMap[condFunc].executeFunctionAsync(_args, context.tensorArrayMap, context.tensorListMap);\n        case 20:\n          condResult = _context2.sent;\n          argIds = _args.map(function (tensor) {\n            return tensor.id;\n          });\n          _context2.next = 24;\n          return condResult[0].data();\n        case 24:\n          _condValue = _context2.sent;\n          // Dispose the intermediate tensors for condition function\n          condResult.forEach(function (tensor) {\n            if (!tensor.kept && argIds.indexOf(tensor.id) === -1) {\n              tensor.dispose();\n            }\n          });\n          result = _args;\n          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n            var origResult, resultIds, condResult;\n            return _regeneratorRuntime().wrap(function _loop$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  // Record the previous result for intermediate tensor tracking\n                  origResult = result; // Execution the body of the loop\n                  _context.next = 3;\n                  return context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\n                case 3:\n                  result = _context.sent;\n                  resultIds = result.map(function (tensor) {\n                    return tensor.id;\n                  }); // Dispose the intermediate tensor for body function that is not global\n                  // kept, not input/output of the body function\n                  origResult.forEach(function (tensor) {\n                    if (!tensor.kept && argIds.indexOf(tensor.id) === -1 && resultIds.indexOf(tensor.id) === -1) {\n                      tensor.dispose();\n                    }\n                  });\n                  // Recalcuate the condition of the loop using the latest results.\n                  _context.next = 8;\n                  return context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\n                case 8:\n                  condResult = _context.sent;\n                  _context.next = 11;\n                  return condResult[0].data();\n                case 11:\n                  _condValue = _context.sent;\n                  // Dispose the intermediate tensors for condition function\n                  condResult.forEach(function (tensor) {\n                    if (!tensor.kept && argIds.indexOf(tensor.id) === -1 && resultIds.indexOf(tensor.id) === -1) {\n                      tensor.dispose();\n                    }\n                  });\n                case 13:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _loop);\n          });\n        case 28:\n          if (!_condValue[0]) {\n            _context2.next = 32;\n            break;\n          }\n          return _context2.delegateYield(_loop(), \"t1\", 30);\n        case 30:\n          _context2.next = 28;\n          break;\n        case 32:\n          return _context2.abrupt(\"return\", result);\n        case 33:\n          pred = getParamValue('pred', node, tensorMap, context);\n          return _context2.abrupt(\"return\", [cloneTensor(pred)]);\n        case 35:\n          _pred = getParamValue('pred', node, tensorMap, context);\n          data = getParamValue('data', node, tensorMap, context);\n          if (!data.kept) {\n            data = cloneTensor(data);\n          }\n          // Outputs nodes :0 => false, :1 => true\n          _context2.next = 40;\n          return _pred.data();\n        case 40:\n          if (!_context2.sent[0]) {\n            _context2.next = 44;\n            break;\n          }\n          _context2.t2 = [undefined, data];\n          _context2.next = 45;\n          break;\n        case 44:\n          _context2.t2 = [data, undefined];\n        case 45:\n          return _context2.abrupt(\"return\", _context2.t2);\n        case 46:\n          inputName = node.inputNames.find(function (name) {\n            return getTensor(name, tensorMap, context) !== undefined;\n          });\n          if (!inputName) {\n            _context2.next = 50;\n            break;\n          }\n          _data = getTensor(inputName, tensorMap, context);\n          return _context2.abrupt(\"return\", [cloneTensor(_data)]);\n        case 50:\n          return _context2.abrupt(\"return\", undefined);\n        case 51:\n          frameId = getParamValue('frameName', node, tensorMap, context);\n          _data2 = getParamValue('tensor', node, tensorMap, context);\n          context.enterFrame(frameId);\n          return _context2.abrupt(\"return\", [cloneTensor(_data2)]);\n        case 55:\n          _data3 = getParamValue('tensor', node, tensorMap, context);\n          context.exitFrame();\n          return _context2.abrupt(\"return\", [cloneTensor(_data3)]);\n        case 58:\n          _data4 = getParamValue('tensor', node, tensorMap, context);\n          context.nextIteration();\n          return _context2.abrupt(\"return\", [cloneTensor(_data4)]);\n        case 61:\n          size = getParamValue('size', node, tensorMap, context);\n          dtype = getParamValue('dtype', node, tensorMap, context);\n          elementShape = getParamValue('elementShape', node, tensorMap, context);\n          dynamicSize = getParamValue('dynamicSize', node, tensorMap, context);\n          clearAfterRead = getParamValue('clearAfterRead', node, tensorMap, context);\n          identicalElementShapes = getParamValue('identicalElementShapes', node, tensorMap, context);\n          name = getParamValue('name', node, tensorMap, context);\n          tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);\n          context.addTensorArray(tensorArray);\n          return _context2.abrupt(\"return\", [tensorArray.idTensor, scalar(1.0)]);\n        case 71:\n          id = getParamValue('tensorArrayId', node, tensorMap, context);\n          index = getParamValue('index', node, tensorMap, context);\n          writeTensor = getParamValue('tensor', node, tensorMap, context);\n          writeTensorArray = context.getTensorArray(id.id);\n          writeTensorArray.write(index, writeTensor);\n          return _context2.abrupt(\"return\", [writeTensorArray.idTensor]);\n        case 77:\n          readId = getParamValue('tensorArrayId', node, tensorMap, context);\n          readIndex = getParamValue('index', node, tensorMap, context);\n          readTensorArray = context.getTensorArray(readId.id);\n          return _context2.abrupt(\"return\", [readTensorArray.read(readIndex)]);\n        case 81:\n          gatherId = getParamValue('tensorArrayId', node, tensorMap, context);\n          gatherIndices = getParamValue('indices', node, tensorMap, context);\n          gatherDtype = getParamValue('dtype', node, tensorMap, context);\n          gatherTensorArray = context.getTensorArray(gatherId.id);\n          return _context2.abrupt(\"return\", [gatherTensorArray.gather(gatherIndices, gatherDtype)]);\n        case 86:\n          scatterId = getParamValue('tensorArrayId', node, tensorMap, context);\n          scatterIndices = getParamValue('indices', node, tensorMap, context);\n          scatterTensor = getParamValue('tensor', node, tensorMap, context);\n          scatterTensorArray = context.getTensorArray(scatterId.id);\n          scatterTensorArray.scatter(scatterIndices, scatterTensor);\n          return _context2.abrupt(\"return\", [scatterTensorArray.idTensor]);\n        case 92:\n          concatId = getParamValue('tensorArrayId', node, tensorMap, context);\n          concatTensorArray = context.getTensorArray(concatId.id);\n          concatDtype = getParamValue('dtype', node, tensorMap, context);\n          return _context2.abrupt(\"return\", [concatTensorArray.concat(concatDtype)]);\n        case 96:\n          splitId = getParamValue('tensorArrayId', node, tensorMap, context);\n          splitTensor = getParamValue('tensor', node, tensorMap, context);\n          lengths = getParamValue('lengths', node, tensorMap, context);\n          splitTensorArray = context.getTensorArray(splitId.id);\n          splitTensorArray.split(lengths, splitTensor);\n          return _context2.abrupt(\"return\", [splitTensorArray.idTensor]);\n        case 102:\n          sizeId = getParamValue('tensorArrayId', node, tensorMap, context);\n          sizeTensorArray = context.getTensorArray(sizeId.id);\n          return _context2.abrupt(\"return\", [scalar(sizeTensorArray.size(), 'int32')]);\n        case 105:\n          closeId = getParamValue('tensorArrayId', node, tensorMap, context);\n          closeTensorArray = context.getTensorArray(closeId.id);\n          closeTensorArray.clearAndClose();\n          return _context2.abrupt(\"return\", [closeTensorArray.idTensor]);\n        case 109:\n          idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          _index = getParamValue('index', node, tensorMap, context);\n          _writeTensor = getParamValue('tensor', node, tensorMap, context);\n          tensorList = context.getTensorList(idTensor.id);\n          tensorList.setItem(_index, _writeTensor);\n          return _context2.abrupt(\"return\", [tensorList.idTensor]);\n        case 115:\n          _idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          _readIndex = getParamValue('index', node, tensorMap, context);\n          _elementShape = getParamValue('elementShape', node, tensorMap, context);\n          elementDType = getParamValue('elementDType', node, tensorMap, context);\n          _tensorList = context.getTensorList(_idTensor.id);\n          return _context2.abrupt(\"return\", [_tensorList.getItem(_readIndex, _elementShape, elementDType)]);\n        case 121:\n          _scatterIndices = getParamValue('indices', node, tensorMap, context);\n          _scatterTensor = getParamValue('tensor', node, tensorMap, context);\n          _elementShape2 = getParamValue('elementShape', node, tensorMap, context);\n          numElements = getParamValue('numElements', node, tensorMap, context);\n          _tensorList2 = scatter(_scatterTensor, _scatterIndices, _elementShape2, numElements);\n          context.addTensorList(_tensorList2);\n          return _context2.abrupt(\"return\", [_tensorList2.idTensor]);\n        case 128:\n          _elementShape3 = getParamValue('elementShape', node, tensorMap, context);\n          elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          if (node.op === 'TensorListReserve') {\n            numElementsParam = 'numElements';\n          } else {\n            numElementsParam = 'maxNumElements';\n          }\n          _numElements = getParamValue(numElementsParam, node, tensorMap, context);\n          maxNumElements = node.op === 'TensorListReserve' ? -1 : _numElements;\n          _tensorList3 = reserve(_elementShape3, elementDtype, _numElements, maxNumElements);\n          context.addTensorList(_tensorList3);\n          return _context2.abrupt(\"return\", [_tensorList3.idTensor]);\n        case 136:\n          _gatherId = getParamValue('tensorListId', node, tensorMap, context);\n          _gatherIndices = getParamValue('indices', node, tensorMap, context);\n          _elementShape4 = getParamValue('elementShape', node, tensorMap, context);\n          _elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          _tensorList4 = context.getTensorList(_gatherId.id);\n          return _context2.abrupt(\"return\", [_tensorList4.gather(_gatherIndices, _elementDtype, _elementShape4)]);\n        case 142:\n          _idTensor2 = getParamValue('tensorListId', node, tensorMap, context);\n          _elementShape5 = getParamValue('elementShape', node, tensorMap, context);\n          _elementDtype2 = getParamValue('elementDType', node, tensorMap, context);\n          _numElements2 = getParamValue('numElements', node, tensorMap, context);\n          _tensorList5 = context.getTensorList(_idTensor2.id);\n          return _context2.abrupt(\"return\", [_tensorList5.stack(_elementShape5, _elementDtype2, _numElements2)]);\n        case 148:\n          tensor = getParamValue('tensor', node, tensorMap, context);\n          _elementShape6 = getParamValue('elementShape', node, tensorMap, context);\n          _elementDtype3 = getParamValue('elementDType', node, tensorMap, context);\n          _tensorList6 = fromTensor(tensor, _elementShape6, _elementDtype3);\n          context.addTensorList(_tensorList6);\n          return _context2.abrupt(\"return\", [_tensorList6.idTensor]);\n        case 154:\n          _concatId = getParamValue('tensorListId', node, tensorMap, context);\n          _tensorList7 = context.getTensorList(_concatId.id);\n          _concatDtype = getParamValue('dtype', node, tensorMap, context);\n          _elementShape7 = getParamValue('elementShape', node, tensorMap, context);\n          return _context2.abrupt(\"return\", [_tensorList7.concat(_concatDtype, _elementShape7)]);\n        case 159:\n          _idTensor3 = getParamValue('tensorListId', node, tensorMap, context);\n          _writeTensor2 = getParamValue('tensor', node, tensorMap, context);\n          _tensorList8 = context.getTensorList(_idTensor3.id);\n          _tensorList8.pushBack(_writeTensor2);\n          return _context2.abrupt(\"return\", [_tensorList8.idTensor]);\n        case 164:\n          _idTensor4 = getParamValue('tensorListId', node, tensorMap, context);\n          _elementShape8 = getParamValue('elementShape', node, tensorMap, context);\n          _elementDType = getParamValue('elementDType', node, tensorMap, context);\n          _tensorList9 = context.getTensorList(_idTensor4.id);\n          return _context2.abrupt(\"return\", [_tensorList9.popBack(_elementShape8, _elementDType)]);\n        case 169:\n          _splitTensor = getParamValue('tensor', node, tensorMap, context);\n          _elementShape9 = getParamValue('elementShape', node, tensorMap, context);\n          _lengths = getParamValue('lengths', node, tensorMap, context);\n          _tensorList10 = split(_splitTensor, _lengths, _elementShape9);\n          context.addTensorList(_tensorList10);\n          return _context2.abrupt(\"return\", [_tensorList10.idTensor]);\n        case 175:\n          _idTensor5 = getParamValue('tensorListId', node, tensorMap, context);\n          _tensorList11 = context.getTensorList(_idTensor5.id);\n          return _context2.abrupt(\"return\", [scalar(_tensorList11.size(), 'int32')]);\n        case 178:\n          _idTensor6 = getParamValue('tensorListId', node, tensorMap, context);\n          _size = getParamValue('size', node, tensorMap, context);\n          srcTensorList = context.getTensorList(_idTensor6.id);\n          destTensorList = srcTensorList.resize(_size);\n          context.addTensorList(destTensorList);\n          return _context2.abrupt(\"return\", [destTensorList.idTensor]);\n        case 184:\n          throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n        case 185:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee);\n  }));\n  return function executeOp(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var CATEGORY = 'control';","map":{"version":3,"mappings":"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","names":["scalar","TensorArray","fromTensor","reserve","scatter","split","cloneTensor","getParamValue","getTensor","executeOp","node","tensorMap","context","op","thenFunc","elseFunc","cond","args","data","condValue","functionMap","executeFunctionAsync","tensorArrayMap","tensorListMap","bodyFunc","condFunc","condResult","argIds","map","tensor","id","forEach","kept","indexOf","dispose","result","origResult","resultIds","pred","undefined","inputName","inputNames","find","name","frameId","enterFrame","exitFrame","nextIteration","size","dtype","elementShape","dynamicSize","clearAfterRead","identicalElementShapes","tensorArray","addTensorArray","idTensor","index","writeTensor","writeTensorArray","getTensorArray","write","readId","readIndex","readTensorArray","read","gatherId","gatherIndices","gatherDtype","gatherTensorArray","gather","scatterId","scatterIndices","scatterTensor","scatterTensorArray","concatId","concatTensorArray","concatDtype","concat","splitId","splitTensor","lengths","splitTensorArray","sizeId","sizeTensorArray","closeId","closeTensorArray","clearAndClose","tensorList","getTensorList","setItem","elementDType","getItem","numElements","addTensorList","elementDtype","numElementsParam","maxNumElements","stack","pushBack","popBack","srcTensorList","destTensorList","resize","TypeError","CATEGORY"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-converter\\src\\operations\\executors\\control_executor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, scalar, Tensor} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {TensorArray} from '../../executor/tensor_array';\nimport {fromTensor, reserve, scatter, split} from '../../executor/tensor_list';\nimport {InternalOpAsyncExecutor, Node} from '../types';\n\nimport {cloneTensor, getParamValue, getTensor} from './utils';\n\nexport const executeOp: InternalOpAsyncExecutor = async(\n    node: Node, tensorMap: NamedTensorsMap,\n    context: ExecutionContext): Promise<Tensor[]> => {\n  switch (node.op) {\n    case 'If':\n    case 'StatelessIf': {\n      const thenFunc =\n          getParamValue('thenBranch', node, tensorMap, context) as string;\n      const elseFunc =\n          getParamValue('elseBranch', node, tensorMap, context) as string;\n      const cond = getParamValue('cond', node, tensorMap, context) as Tensor;\n      const args = getParamValue('args', node, tensorMap, context) as Tensor[];\n      const condValue = await cond.data();\n      if (condValue[0]) {\n        return context.functionMap[thenFunc].executeFunctionAsync(\n            args, context.tensorArrayMap, context.tensorListMap);\n      } else {\n        return context.functionMap[elseFunc].executeFunctionAsync(\n            args, context.tensorArrayMap, context.tensorListMap);\n      }\n    }\n    case 'While':\n    case 'StatelessWhile': {\n      const bodyFunc =\n          getParamValue('body', node, tensorMap, context) as string;\n      const condFunc =\n          getParamValue('cond', node, tensorMap, context) as string;\n      const args = getParamValue('args', node, tensorMap, context) as Tensor[];\n\n      // Calculate the condition of the loop\n      const condResult =\n          (await context.functionMap[condFunc].executeFunctionAsync(\n              args, context.tensorArrayMap, context.tensorListMap));\n      const argIds = args.map(tensor => tensor.id);\n      let condValue = await condResult[0].data();\n      // Dispose the intermediate tensors for condition function\n      condResult.forEach(tensor => {\n        if (!tensor.kept && argIds.indexOf(tensor.id) === -1) {\n          tensor.dispose();\n        }\n      });\n\n      let result: Tensor[] = args;\n\n      while (condValue[0]) {\n        // Record the previous result for intermediate tensor tracking\n        const origResult = result;\n        // Execution the body of the loop\n        result = await context.functionMap[bodyFunc].executeFunctionAsync(\n            result, context.tensorArrayMap, context.tensorListMap);\n        const resultIds = result.map(tensor => tensor.id);\n\n        // Dispose the intermediate tensor for body function that is not global\n        // kept, not input/output of the body function\n        origResult.forEach(tensor => {\n          if (!tensor.kept && argIds.indexOf(tensor.id) === -1 &&\n              resultIds.indexOf(tensor.id) === -1) {\n            tensor.dispose();\n          }\n        });\n\n        // Recalcuate the condition of the loop using the latest results.\n        const condResult =\n            (await context.functionMap[condFunc].executeFunctionAsync(\n                result, context.tensorArrayMap, context.tensorListMap));\n        condValue = await condResult[0].data();\n        // Dispose the intermediate tensors for condition function\n        condResult.forEach(tensor => {\n          if (!tensor.kept && argIds.indexOf(tensor.id) === -1 &&\n              resultIds.indexOf(tensor.id) === -1) {\n            tensor.dispose();\n          }\n        });\n      }\n      return result;\n    }\n    case 'LoopCond': {\n      const pred = getParamValue('pred', node, tensorMap, context) as Tensor;\n      return [cloneTensor(pred)];\n    }\n    case 'Switch': {\n      const pred = getParamValue('pred', node, tensorMap, context) as Tensor;\n      let data = getParamValue('data', node, tensorMap, context) as Tensor;\n      if (!data.kept) {\n        data = cloneTensor(data);\n      }\n      // Outputs nodes :0 => false, :1 => true\n      return (await pred.data())[0] ? [undefined, data] : [data, undefined];\n    }\n    case 'Merge': {\n      const inputName = node.inputNames.find(\n          name => getTensor(name, tensorMap, context) !== undefined);\n      if (inputName) {\n        const data = getTensor(inputName, tensorMap, context);\n        return [cloneTensor(data)];\n      }\n      return undefined;\n    }\n    case 'Enter': {\n      const frameId =\n          getParamValue('frameName', node, tensorMap, context) as string;\n      const data = getParamValue('tensor', node, tensorMap, context) as Tensor;\n      context.enterFrame(frameId);\n      return [cloneTensor(data)];\n    }\n    case 'Exit': {\n      const data = getParamValue('tensor', node, tensorMap, context) as Tensor;\n      context.exitFrame();\n      return [cloneTensor(data)];\n    }\n    case 'NextIteration': {\n      const data = getParamValue('tensor', node, tensorMap, context) as Tensor;\n      context.nextIteration();\n      return [cloneTensor(data)];\n    }\n    case 'TensorArrayV3': {\n      const size = getParamValue('size', node, tensorMap, context) as number;\n      const dtype =\n          getParamValue('dtype', node, tensorMap, context) as DataType;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const dynamicSize =\n          getParamValue('dynamicSize', node, tensorMap, context) as boolean;\n      const clearAfterRead =\n          getParamValue('clearAfterRead', node, tensorMap, context) as boolean;\n      const identicalElementShapes =\n          getParamValue('identicalElementShapes', node, tensorMap, context) as\n          boolean;\n      const name = getParamValue('name', node, tensorMap, context) as string;\n      const tensorArray = new TensorArray(\n          name, dtype, size, elementShape, identicalElementShapes, dynamicSize,\n          clearAfterRead);\n      context.addTensorArray(tensorArray);\n      return [tensorArray.idTensor, scalar(1.0)];\n    }\n    case 'TensorArrayWriteV3': {\n      const id =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const index = getParamValue('index', node, tensorMap, context) as number;\n      const writeTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const writeTensorArray = context.getTensorArray(id.id);\n      writeTensorArray.write(index, writeTensor);\n      return [writeTensorArray.idTensor];\n    }\n    case 'TensorArrayReadV3': {\n      const readId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const readIndex =\n          getParamValue('index', node, tensorMap, context) as number;\n      const readTensorArray = context.getTensorArray(readId.id);\n      return [readTensorArray.read(readIndex)];\n    }\n    case 'TensorArrayGatherV3': {\n      const gatherId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const gatherIndices =\n          getParamValue('indices', node, tensorMap, context) as number[];\n      const gatherDtype =\n          getParamValue('dtype', node, tensorMap, context) as DataType;\n      const gatherTensorArray = context.getTensorArray(gatherId.id);\n      return [gatherTensorArray.gather(gatherIndices, gatherDtype)];\n    }\n    case 'TensorArrayScatterV3': {\n      const scatterId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const scatterIndices =\n          getParamValue('indices', node, tensorMap, context) as number[];\n      const scatterTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const scatterTensorArray = context.getTensorArray(scatterId.id);\n      scatterTensorArray.scatter(scatterIndices, scatterTensor);\n      return [scatterTensorArray.idTensor];\n    }\n    case 'TensorArrayConcatV3': {\n      const concatId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const concatTensorArray = context.getTensorArray(concatId.id);\n      const concatDtype =\n          getParamValue('dtype', node, tensorMap, context) as DataType;\n      return [concatTensorArray.concat(concatDtype)];\n    }\n    case 'TensorArraySplitV3': {\n      const splitId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const splitTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const lengths =\n          getParamValue('lengths', node, tensorMap, context) as number[];\n      const splitTensorArray = context.getTensorArray(splitId.id);\n      splitTensorArray.split(lengths, splitTensor);\n      return [splitTensorArray.idTensor];\n    }\n    case 'TensorArraySizeV3': {\n      const sizeId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const sizeTensorArray = context.getTensorArray(sizeId.id);\n      return [scalar(sizeTensorArray.size(), 'int32')];\n    }\n    case 'TensorArrayCloseV3': {\n      const closeId =\n          getParamValue('tensorArrayId', node, tensorMap, context) as Tensor;\n      const closeTensorArray = context.getTensorArray(closeId.id);\n      closeTensorArray.clearAndClose();\n      return [closeTensorArray.idTensor];\n    }\n    case 'TensorListSetItem': {\n      const idTensor =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const index = getParamValue('index', node, tensorMap, context) as number;\n      const writeTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const tensorList = context.getTensorList(idTensor.id);\n      tensorList.setItem(index, writeTensor);\n      return [tensorList.idTensor];\n    }\n    case 'TensorListGetItem': {\n      const idTensor =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const readIndex =\n          getParamValue('index', node, tensorMap, context) as number;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n\n      const elementDType =\n          getParamValue('elementDType', node, tensorMap, context) as DataType;\n      const tensorList = context.getTensorList(idTensor.id);\n      return [tensorList.getItem(readIndex, elementShape, elementDType)];\n    }\n    case 'TensorListScatterV2':\n    case 'TensorListScatter': {\n      const scatterIndices =\n          getParamValue('indices', node, tensorMap, context) as number[];\n      const scatterTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const numElements =\n          getParamValue('numElements', node, tensorMap, context) as number;\n      const tensorList =\n          scatter(scatterTensor, scatterIndices, elementShape, numElements);\n      context.addTensorList(tensorList);\n      return [tensorList.idTensor];\n    }\n    case 'TensorListReserve':\n    case 'EmptyTensorList': {\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const elementDtype =\n          getParamValue('elementDType', node, tensorMap, context) as DataType;\n      let numElementsParam;\n\n      if (node.op === 'TensorListReserve') {\n        numElementsParam = 'numElements';\n      } else {\n        numElementsParam = 'maxNumElements';\n      }\n\n      const numElements =\n          getParamValue(numElementsParam, node, tensorMap, context) as number;\n      const maxNumElements = node.op === 'TensorListReserve' ? -1 : numElements;\n      const tensorList =\n          reserve(elementShape, elementDtype, numElements, maxNumElements);\n      context.addTensorList(tensorList);\n      return [tensorList.idTensor];\n    }\n    case 'TensorListGather': {\n      const gatherId =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const gatherIndices =\n          getParamValue('indices', node, tensorMap, context) as number[];\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const elementDtype =\n          getParamValue('elementDType', node, tensorMap, context) as DataType;\n      const tensorList = context.getTensorList(gatherId.id);\n      return [tensorList.gather(gatherIndices, elementDtype, elementShape)];\n    }\n    case 'TensorListStack': {\n      const idTensor =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const elementDtype =\n          getParamValue('elementDType', node, tensorMap, context) as DataType;\n      const numElements =\n          getParamValue('numElements', node, tensorMap, context) as number;\n      const tensorList = context.getTensorList(idTensor.id);\n      return [tensorList.stack(elementShape, elementDtype, numElements)];\n    }\n    case 'TensorListFromTensor': {\n      const tensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const elementDtype =\n          getParamValue('elementDType', node, tensorMap, context) as DataType;\n      const tensorList = fromTensor(tensor, elementShape, elementDtype);\n      context.addTensorList(tensorList);\n      return [tensorList.idTensor];\n    }\n    case 'TensorListConcat':\n    case 'TensorListConcatV2': {\n      const concatId =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const tensorList = context.getTensorList(concatId.id);\n      const concatDtype =\n          getParamValue('dtype', node, tensorMap, context) as DataType;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      return [tensorList.concat(concatDtype, elementShape)];\n    }\n    case 'TensorListPushBack': {\n      const idTensor =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const writeTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const tensorList = context.getTensorList(idTensor.id);\n      tensorList.pushBack(writeTensor);\n      return [tensorList.idTensor];\n    }\n    case 'TensorListPopBack': {\n      const idTensor =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const elementDType =\n          getParamValue('elementDType', node, tensorMap, context) as DataType;\n      const tensorList = context.getTensorList(idTensor.id);\n      return [tensorList.popBack(elementShape, elementDType)];\n    }\n    case 'TensorListSplit': {\n      const splitTensor =\n          getParamValue('tensor', node, tensorMap, context) as Tensor;\n      const elementShape =\n          getParamValue('elementShape', node, tensorMap, context) as number[];\n      const lengths =\n          getParamValue('lengths', node, tensorMap, context) as number[];\n\n      const tensorList = split(splitTensor, lengths, elementShape);\n      context.addTensorList(tensorList);\n      return [tensorList.idTensor];\n    }\n    case 'TensorListLength': {\n      const idTensor =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const tensorList = context.getTensorList(idTensor.id);\n      return [scalar(tensorList.size(), 'int32')];\n    }\n    case 'TensorListResize': {\n      const idTensor =\n          getParamValue('tensorListId', node, tensorMap, context) as Tensor;\n      const size = getParamValue('size', node, tensorMap, context) as number;\n\n      const srcTensorList = context.getTensorList(idTensor.id);\n      const destTensorList = srcTensorList.resize(size);\n      context.addTensorList(destTensorList);\n      return [destTensorList.idTensor];\n    }\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\n\nexport const CATEGORY = 'control';\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}