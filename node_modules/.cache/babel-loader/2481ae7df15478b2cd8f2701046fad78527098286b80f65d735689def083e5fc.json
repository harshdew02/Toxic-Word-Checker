{"ast":null,"code":"import _regeneratorRuntime from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _asyncToGenerator from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source keras/models.py */\nimport { dispose, io, serialization, util } from '@tensorflow/tfjs-core';\nimport { getUid } from './backend/state';\nimport { Input } from './engine/input_layer';\nimport { getSourceInputs, Node } from './engine/topology';\nimport { LayersModel } from './engine/training';\nimport { NotImplementedError, RuntimeError, ValueError } from './errors';\nimport { deserialize } from './layers/serialization';\nimport * as generic_utils from './utils/generic_utils';\nimport { convertPythonicToTs } from './utils/serialization_utils';\nimport { getExactlyOneShape } from './utils/types_utils';\n/**\n * Parses a JSON model configuration file and returns a model instance.\n *\n * ```js\n * // This example shows how to serialize a model using `toJSON()` and\n * // deserialize it as another model using `tf.models.modelFromJSON()`.\n * // Note: this example serializes and deserializes only the topology\n * // of the model; the weights of the loaded model will be different\n * // from those of the the original model, due to random weight\n * // initialization.\n * // To load the topology and weights of a model, use `tf.loadLayersModel()`.\n * const model1 = tf.sequential();\n * model1.add(tf.layers.repeatVector({inputShape: [2], n: 4}));\n * // Serialize `model1` as a JSON object.\n * const model1JSON = model1.toJSON(null, false);\n * model1.summary();\n *\n * const model2 = await tf.models.modelFromJSON(model1JSON);\n * model2.summary();\n * ```\n *\n *  @param modelAndWeightsConfig JSON object or string encoding a model and\n *       weights configuration. It can also be only the topology JSON of the\n *       model, in which case the weights will not be loaded.\n *  @param custom_objects Optional dictionary mapping names\n *       (strings) to custom classes or functions to be\n *       considered during deserialization.\n * @returns A TensorFlow.js Layers `tf.LayersModel` instance (uncompiled).\n */\nexport function modelFromJSON(_x, _x2) {\n  return _modelFromJSON.apply(this, arguments);\n}\n/**\n * Load a model composed of Layer objects, including its topology and optionally\n * weights. See the Tutorial named \"How to import a Keras Model\" for usage\n * examples.\n *\n * This method is applicable to:\n *\n * 1. Models created with the `tf.layers.*`, `tf.sequential`, and\n * `tf.model` APIs of TensorFlow.js and later saved with the\n * `tf.LayersModel.save` method.\n * 2. Models converted from Keras or TensorFlow tf.keras using the\n * [tensorflowjs_converter](https://github.com/tensorflow/tfjs/tree/master/tfjs-converter).\n *\n * This mode is *not* applicable to TensorFlow `SavedModel`s or their converted\n * forms. For those models, use `tf.loadGraphModel`.\n *\n * Example 1. Load a model from an HTTP server.\n *\n * ```js\n * const model = await tf.loadLayersModel(\n *     'https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');\n * model.summary();\n * ```\n *\n * Example 2: Save `model`'s topology and weights to browser [local\n * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('localstorage://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 3. Saving `model`'s topology and weights to browser\n * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('indexeddb://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 4. Load a model from user-selected files from HTML\n * [file input\n * elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).\n *\n * ```js\n * // Note: this code snippet will not work without the HTML elements in the\n * //   page\n * const jsonUpload = document.getElementById('json-upload');\n * const weightsUpload = document.getElementById('weights-upload');\n *\n * const model = await tf.loadLayersModel(\n *     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));\n * ```\n *\n * @param pathOrIOHandler Can be either of the two formats\n *   1. A string path to the `ModelAndWeightsConfig` JSON describing\n *      the model in the canonical TensorFlow.js format. For file://\n *      (tfjs-node-only), http:// and https:// schemas, the path can be\n *      either absolute or relative. The content of the JSON file is assumed to\n *      be a JSON object with the following fields and values:\n *      - 'modelTopology': A JSON object that can be either of:\n *        1. a model architecture JSON consistent with the format of the return\n *            value of `keras.Model.to_json()`\n *        2. a full model JSON in the format of `keras.models.save_model()`.\n *      - 'weightsManifest': A TensorFlow.js weights manifest.\n *      See the Python converter function `save_model()` for more details.\n *      It is also assumed that model weights can be accessed from relative\n *      paths described by the `paths` fields in weights manifest.\n *   2. A `tf.io.IOHandler` object that loads model artifacts with its `load`\n *      method.\n * @param options Optional configuration arguments for the model loading,\n *   including:\n *   - `strict`: Require that the provided weights exactly match those required\n *     by the layers.  Default true.  Passing false means that both extra\n *     weights and missing weights will be silently ignored.\n *   - `onProgress`: A progress callback of the form:\n *     `(fraction: number) => void`. This callback can be used to monitor the\n *     model-loading process.\n * @returns A `Promise` of `tf.LayersModel`, with the topology and weights\n *     loaded.\n *\n * @doc {heading: 'Models', subheading: 'Loading'}\n */\nfunction _modelFromJSON() {\n  _modelFromJSON = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(modelAndWeightsConfig, customObjects) {\n    var modelTopology, tsConfig, model, weightValues, uniqueWeightValues, _iterator4, _step4, weight;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          if (!('modelTopology' in modelAndWeightsConfig)) {\n            modelAndWeightsConfig = {\n              modelTopology: modelAndWeightsConfig\n            };\n          }\n          modelAndWeightsConfig = modelAndWeightsConfig;\n          modelTopology = modelAndWeightsConfig.modelTopology;\n          if (modelTopology['model_config'] != null) {\n            // If the model-topology JSON contains a 'model_config' field, then it is\n            // a full model JSON (e.g., from `keras.Model.save()`), which contains\n            // not only the model's architecture in its 'model_config' field, but\n            // additional information such as the model's optimizer. We use only the\n            // 'model_config' field currently.\n            modelTopology = modelTopology['model_config'];\n          }\n          tsConfig = convertPythonicToTs(modelTopology);\n          model = deserialize(tsConfig, customObjects);\n          if (!(modelAndWeightsConfig.weightsManifest != null)) {\n            _context5.next = 15;\n            break;\n          }\n          _context5.next = 9;\n          return io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(function (weight) {\n            return weight.originalName;\n          }));\n        case 9:\n          weightValues = _context5.sent;\n          // Map the weights to the unique tensor names generated during model loading\n          uniqueWeightValues = {};\n          _iterator4 = _createForOfIteratorHelper(model.weights);\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              weight = _step4.value;\n              uniqueWeightValues[weight.originalName] = weightValues[weight.originalName];\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          model.loadWeights(uniqueWeightValues);\n          // Dispose temporary weight values.\n          dispose(weightValues);\n        case 15:\n          return _context5.abrupt(\"return\", model);\n        case 16:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n  return _modelFromJSON.apply(this, arguments);\n}\nexport function loadLayersModel(_x3, _x4) {\n  return _loadLayersModel.apply(this, arguments);\n}\n/**\n * Load a model and optionally its weights, using an IOHandler object.\n *\n * @param handler The instance of `IOHandler` to be used during the model\n *   loading.\n * @param customObjects Any optional custom objects to be used during model\n *   loading.\n * @param strict Whether the weight loading will be done in strict mode.\n *   Default: `true`.\n */\nfunction _loadLayersModel() {\n  _loadLayersModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(pathOrIOHandler, options) {\n    var handlers;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          if (options == null) {\n            options = {};\n          }\n          if (!(typeof pathOrIOHandler === 'string')) {\n            _context6.next = 10;\n            break;\n          }\n          handlers = io.getLoadHandlers(pathOrIOHandler, options);\n          if (!(handlers.length === 0)) {\n            _context6.next = 7;\n            break;\n          }\n          // For backward compatibility: if no load handler can be found,\n          // assume it is a relative http path.\n          // TODO(cais): Reformat the args into a single `LoadOptions` once the core\n          // is refactored.\n          handlers.push(io.browserHTTPRequest(pathOrIOHandler, options));\n          _context6.next = 9;\n          break;\n        case 7:\n          if (!(handlers.length > 1)) {\n            _context6.next = 9;\n            break;\n          }\n          throw new ValueError(\"Found more than one (\".concat(handlers.length, \") load handlers for \") + \"URL '\".concat(pathOrIOHandler, \"'\"));\n        case 9:\n          pathOrIOHandler = handlers[0];\n        case 10:\n          return _context6.abrupt(\"return\", loadLayersModelFromIOHandler(pathOrIOHandler, undefined, options));\n        case 11:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6);\n  }));\n  return _loadLayersModel.apply(this, arguments);\n}\nexport function loadLayersModelFromIOHandler(_x5, _x6, _x7) {\n  return _loadLayersModelFromIOHandler.apply(this, arguments);\n}\nfunction _loadLayersModelFromIOHandler() {\n  _loadLayersModelFromIOHandler = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(handler, customObjects, options) {\n    var artifacts, modelTopology, strict, fastWeightInit, model, trainingConfig, _decodeModelAndOptimi, modelWeights, optimizerWeights;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) switch (_context7.prev = _context7.next) {\n        case 0:\n          if (options == null) {\n            options = {};\n          }\n          if (!(handler.load == null)) {\n            _context7.next = 3;\n            break;\n          }\n          throw new ValueError('Cannot proceed with model loading because the IOHandler provided ' + 'does not have the `load` method implemented.');\n        case 3:\n          _context7.next = 5;\n          return handler.load();\n        case 5:\n          artifacts = _context7.sent;\n          modelTopology = artifacts.modelTopology;\n          if (modelTopology['model_config'] != null) {\n            modelTopology = modelTopology['model_config'];\n          }\n          strict = options.strict == null ? true : options.strict; // If weights are provided and the weight-loading mode is strict, use\n          // fast weight initialization. This skips costly initializers such as\n          // 'orthogonal' and saves unnecessary computation in cases where\n          // the initialized weight values will immediately be overwritten by\n          // loaded weight values.\n          fastWeightInit = artifacts.weightData != null && artifacts.weightSpecs != null && strict;\n          model = deserialize(convertPythonicToTs(modelTopology), customObjects, fastWeightInit);\n          trainingConfig = artifacts.trainingConfig;\n          if (trainingConfig != null) {\n            model.loadTrainingConfig(trainingConfig);\n          }\n          if (artifacts.userDefinedMetadata != null) {\n            model.setUserDefinedMetadata(artifacts.userDefinedMetadata);\n          }\n          // If weightData is present, load the weights into the model.\n          if (!(artifacts.weightData != null)) {\n            _context7.next = 24;\n            break;\n          }\n          if (!(artifacts.weightSpecs == null)) {\n            _context7.next = 17;\n            break;\n          }\n          throw new ValueError('LayersModel artifacts contains weight data, but not weight specs. ' + 'Therefore loading of weights cannot proceed.');\n        case 17:\n          _decodeModelAndOptimi = decodeModelAndOptimizerWeights(artifacts.weightData, artifacts.weightSpecs), modelWeights = _decodeModelAndOptimi.modelWeights, optimizerWeights = _decodeModelAndOptimi.optimizerWeights;\n          model.loadWeights(modelWeights, strict);\n          if (!(model.optimizer != null && optimizerWeights.length > 0)) {\n            _context7.next = 22;\n            break;\n          }\n          _context7.next = 22;\n          return model.optimizer.setWeights(optimizerWeights);\n        case 22:\n          // Dispose temporary weight values.\n          dispose(modelWeights);\n          dispose(optimizerWeights.map(function (w) {\n            return w.tensor;\n          }));\n        case 24:\n          return _context7.abrupt(\"return\", model);\n        case 25:\n        case \"end\":\n          return _context7.stop();\n      }\n    }, _callee7);\n  }));\n  return _loadLayersModelFromIOHandler.apply(this, arguments);\n}\nfunction decodeModelAndOptimizerWeights(buffer, specs) {\n  var name2Tensor = io.decodeWeights(buffer, specs);\n  var modelWeights = {};\n  var optimizerWeights = [];\n  specs.forEach(function (spec) {\n    if (spec.group === 'optimizer') {\n      optimizerWeights.push({\n        name: spec.name,\n        tensor: name2Tensor[spec.name]\n      });\n    } else {\n      modelWeights[spec.name] = name2Tensor[spec.name];\n    }\n  });\n  return {\n    modelWeights: modelWeights,\n    optimizerWeights: optimizerWeights\n  };\n}\n/**\n * A model with a stack of layers, feeding linearly from one to the next.\n *\n * `tf.sequential` is a factory function that creates an instance of\n * `tf.Sequential`.\n *\n * ```js\n *  // Define a model for linear regression.\n *  const model = tf.sequential();\n *  model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n *\n *  // Prepare the model for training: Specify the loss and the optimizer.\n *  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *  // Generate some synthetic data for training.\n *  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);\n *  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);\n *\n *  // Train the model using the data then do inference on a data point the\n *  // model hasn't seen:\n *  await model.fit(xs, ys);\n *  model.predict(tf.tensor2d([5], [1, 1])).print();\n * ```\n *\n * @doc {heading: 'Models', subheading: 'Classes'}\n */\nexport var Sequential = /*#__PURE__*/function (_LayersModel) {\n  _inherits(Sequential, _LayersModel);\n  var _super = _createSuper(Sequential);\n  function Sequential(args) {\n    var _this;\n    _classCallCheck(this, Sequential);\n    _this = _super.call(this, {\n      inputs: [],\n      outputs: []\n    });\n    args = args || {};\n    _this.trainable = true;\n    _this.built = false;\n    // Set model name.\n    _this.name = args.name != null ? args.name : getUid('sequential_');\n    // Add to the model any layers passed to the constructor.\n    if (args.layers != null) {\n      var _iterator = _createForOfIteratorHelper(args.layers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var layer = _step.value;\n          _this.add(layer);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    return _this;\n  }\n  // Helper function to Sequential.add  Throws if the new output shape will be\n  // invalid.\n  _createClass(Sequential, [{\n    key: \"checkShape\",\n    value: function checkShape(layer) {\n      var shape = layer.inboundNodes[0].outputTensors[0].shape;\n      if (shape.some(function (x) {\n        return x < 0;\n      })) {\n        throw new ValueError('Negative dimension size caused by adding layer ' + \"\".concat(layer.name, \" with input shape [\") + \"\".concat(layer.inboundNodes[0].inputTensors[0].shape, \"]\"));\n      }\n    }\n    /**\n     * Adds a layer instance on top of the layer stack.\n     *\n     * ```js\n     *  const model = tf.sequential();\n     *  model.add(tf.layers.dense({units: 8, inputShape: [1]}));\n     *  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));\n     *  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));\n     *  // Note that the untrained model is random at this point.\n     *  model.predict(tf.randomNormal([10, 1])).print();\n     * ```\n     * @param layer Layer instance.\n     *\n     * @exception ValueError In case the `layer` argument does not know its\n     * input shape.\n     * @exception ValueError In case the `layer` argument has multiple output\n     *   tensors, or is already connected somewhere else (forbidden in\n     *   `Sequential` models).\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n  }, {\n    key: \"add\",\n    value: function add(layer) {\n      var isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;\n      var modelLayer;\n      if (isLayerModelInstance) {\n        modelLayer = layer;\n        if (modelLayer.outputs.length !== 1) {\n          throw new ValueError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n        }\n        if (modelLayer.inputs.length !== 1) {\n          throw new ValueError('All layers in a Sequential model ' + 'should have a single input tensor. ' + 'For multi-input layers, ' + 'use the functional API.');\n        }\n      }\n      if (this.outputs.length === 0) {\n        // first layer in model: check that it is an input layer\n        if (layer.inboundNodes.length === 0) {\n          // create an input layer\n          if (layer.batchInputShape == null) {\n            throw new ValueError('The first layer in a Sequential model must ' + 'get an `inputShape` or `batchInputShape` argument.');\n          }\n          // Instantiate the input layer.\n          var x = Input({\n            batchShape: layer.batchInputShape,\n            dtype: layer.dtype,\n            name: layer.name + '_input'\n          });\n          // This will build the current layer and create the node connecting\n          // the current layer to the input layer we just created.\n          layer.apply(x);\n        }\n        if (isLayerModelInstance) {\n          this.outputs = modelLayer.outputs;\n          this.inputs = modelLayer.inputs;\n        } else {\n          if (layer.inboundNodes.length !== 1) {\n            throw new ValueError('A layer added to a Sequential model must not already be ' + \"connected somewhere else. LayersModel received layer \".concat(layer.name, \" \") + \"which has \".concat(layer.inboundNodes.length, \" pre-existing inbound \") + 'connections.');\n          }\n          if (layer.inboundNodes[0].outputTensors.length !== 1) {\n            throw new ValueError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n          }\n          this.checkShape(layer);\n          this.outputs = [layer.inboundNodes[0].outputTensors[0]];\n          this.inputs = getSourceInputs(this.outputs[0]);\n        }\n        this.inboundNodes = [];\n        // We create an input node, which we will keep updated\n        // as we add more layers.\n        // (This call has side effects.)\n        // tslint:disable-next-line:no-unused-expression\n        new Node({\n          outboundLayer: this,\n          inboundLayers: [],\n          nodeIndices: [],\n          tensorIndices: [],\n          inputTensors: this.inputs,\n          outputTensors: this.outputs,\n          // no model-level masking for now\n          inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),\n          outputMasks: [null],\n          inputShapes: this.inputs.map(function (x) {\n            return x.shape;\n          }),\n          outputShapes: this.outputs[0].shape\n        });\n      } else {\n        var outputTensor = layer.apply(this.outputs[0]);\n        if (Array.isArray(outputTensor)) {\n          throw new TypeError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n        }\n        this.checkShape(layer);\n        this.outputs = [outputTensor];\n        // update self.inbound_nodes\n        this.inboundNodes[0].outputTensors = this.outputs;\n        this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n      }\n      this.layers.push(layer);\n      this.built = false;\n    }\n    /**\n     * Removes the last layer in the model.\n     *\n     * @exception TypeError if there are no layers in the model.\n     */\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      if (this.layers.length === 0) {\n        throw new TypeError('There are no layers in the model.');\n      }\n      this.layers.pop();\n      if (this.layers.length === 0) {\n        this.outputs = [];\n        this.inboundNodes = [];\n        this.outboundNodes = [];\n      } else {\n        var lastLayerIndex = this.layers.length - 1;\n        this.layers[lastLayerIndex].outboundNodes = [];\n        this.outputs = [this.layers[lastLayerIndex].output];\n        // update self.inbound_nodes\n        this.inboundNodes[0].outputTensors = this.outputs;\n        this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n      }\n    }\n  }, {\n    key: \"call\",\n    value: function call(inputs, kwargs) {\n      if (this.model == null) {\n        this.build();\n      }\n      return this.model.call(inputs, kwargs);\n    }\n  }, {\n    key: \"build\",\n    value: function build(inputShape) {\n      // Call `getExactlyOneShape` without using its return value,\n      // to verify that exactly one input shape is provided.\n      getExactlyOneShape(inputShape);\n      if (this.inputs.length === 0 || this.outputs.length === 0) {\n        throw new TypeError('Sequential model cannot be built: model is empty.' + ' Add some layers first.');\n      }\n      // actually create the model\n      this.model = new LayersModel({\n        inputs: this.inputs,\n        outputs: this.outputs[0],\n        name: this.name + '_model'\n      });\n      this.model.trainable = this.trainable;\n      // mirror model attributes\n      this.supportsMasking = this.model.supportsMasking;\n      // TODO(michaelterry): Add caches\n      this.inputLayers = this.model.inputLayers;\n      this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;\n      this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;\n      this.outputLayers = this.model.outputLayers;\n      this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;\n      this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;\n      this.nodesByDepth = this.model.nodesByDepth;\n      this.containerNodes = this.model.containerNodes;\n      this.outputNames = this.model.outputNames;\n      this.inputNames = this.model.inputNames;\n      // TODO(michaelterry): Add feedInputNames, feedInputs, if needed.\n      // TODO(michaelterry): Add callbackModel if needed.\n      this.built = true;\n    }\n  }, {\n    key: \"countParams\",\n    value: function countParams() {\n      if (!this.built) {\n        this.build();\n      }\n      return _get(_getPrototypeOf(Sequential.prototype), \"countParams\", this).call(this);\n    }\n    /**\n     * Print a text summary of the Sequential model's layers.\n     *\n     * The summary includes\n     * - Name and type of all layers that comprise the model.\n     * - Output shape(s) of the layers\n     * - Number of weight parameters of each layer\n     * - The total number of trainable and non-trainable parameters of the\n     * model.\n     *\n     * ```js\n     * const model = tf.sequential();\n     * model.add(\n     *     tf.layers.dense({units: 100, inputShape: [10], activation: 'relu'}));\n     * model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));\n     *\n     * model.summary();\n     * ```\n     *\n     * @param lineLength Custom line length, in number of characters.\n     * @param positions Custom widths of each of the columns, as either\n     *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\n     *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to\n     *   right-most (i.e., ending) position of a column.\n     * @param printFn Custom print function. Can be used to replace the default\n     *   `console.log`. For example, you can use `x => {}` to mute the printed\n     *   messages in the console.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n  }, {\n    key: \"summary\",\n    value: function summary(lineLength, positions) {\n      var printFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;\n      if (!this.built) {\n        this.build();\n      }\n      _get(_getPrototypeOf(Sequential.prototype), \"summary\", this).call(this, lineLength, positions, printFn);\n    }\n    /**\n     * Sets the weights of the model.\n     *\n     * @param weights Should be a list of Tensors with shapes and types matching\n     *   the output of `model.getWeights()`.\n     */\n  }, {\n    key: \"setWeights\",\n    value: function setWeights(weights) {\n      if (this.model == null) {\n        this.build();\n      }\n      this.model.setWeights(weights);\n    }\n    /**\n     * Returns the loss value & metrics values for the model in test mode.\n     *\n     * Loss and metrics are specified during `compile()`, which needs to happen\n     * before calls to `evaluate()`.\n     *\n     * Computation is done in batches.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *   batchSize: 4,\n     * });\n     * result.print();\n     * ```\n     *\n     * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple inputs.\n     * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple outputs.\n     * @param args A `ModelEvaluateConfig`, containing optional fields.\n     *\n     * @return `Scalar` test loss (if the model has a single output and no\n     *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs\n     *   and/or metrics). The attribute `model.metricsNames`\n     *   will give you the display labels for the scalar outputs.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(x, y) {\n      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (!this.built) {\n        throw new RuntimeError('The model needs to be compiled before being used.');\n      }\n      return this.model.evaluate(x, y, args);\n    }\n    // TODO(cais): Add code snippet below once real dataset objects are\n    //   available.\n    /**\n     * Evaluate model using a dataset object.\n     *\n     * Note: Unlike `evaluate()`, this method is asynchronous (`async`).\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected\n     *   to generate a dataset iterator object, the `next()` method of which\n     *   is expected to produce data batches for evaluation. The return value\n     *   of the `next()` call ought to contain a boolean `done` field and a\n     *   `value` field. The `value` field is expected to be an array of two\n     *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\n     *   case is for models with exactly one input and one output (e.g.\n     *   a sequential model). The latter case is for models with multiple\n     *   inputs and/or multiple outputs. Of the two items in the array, the\n     *   first is the input feature(s) and the second is the output target(s).\n     * @param args A configuration object for the dataset-based evaluation.\n     * @returns Loss and metric values as an Array of `Scalar` objects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n  }, {\n    key: \"evaluateDataset\",\n    value: function () {\n      var _evaluateDataset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dataset, args) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (this.built) {\n                _context.next = 2;\n                break;\n              }\n              throw new RuntimeError('The model needs to be compiled before being used.');\n            case 2:\n              return _context.abrupt(\"return\", this.model.evaluateDataset(dataset, args));\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function evaluateDataset(_x8, _x9) {\n        return _evaluateDataset.apply(this, arguments);\n      }\n      return evaluateDataset;\n    }()\n    /**\n     * Generates output predictions for the input samples.\n     *\n     * Computation is done in batches.\n     *\n     * Note: the \"step\" mode of predict() is currently not supported.\n     *   This is because the TensorFlow.js core backend is imperative only.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.predict(tf.ones([2, 10])).print();\n     * ```\n     *\n     * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if\n     *   the model has multiple inputs.\n     * @param conifg A `ModelPredictConfig` object containing optional fields.\n     *\n     * @return `tf.Tensor`(s) of predictions.\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and the model's expectations, or in case a stateful model receives a\n     *   number of samples that is not a multiple of the batch size.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n  }, {\n    key: \"predict\",\n    value: function predict(x) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.model == null) {\n        this.build();\n      }\n      return this.model.predict(x, args);\n    }\n    /**\n     * Returns predictions for a single batch of samples.\n     *\n     * @param x: Input samples, as a Tensor, or list of Tensors (if the model\n     *   has multiple inputs).\n     * @return Tensor(s) of predictions\n     */\n  }, {\n    key: \"predictOnBatch\",\n    value: function predictOnBatch(x) {\n      if (this.model == null) {\n        this.build();\n      }\n      return this.model.predictOnBatch(x);\n    }\n    /**\n     * See `LayersModel.compile`.\n     *\n     * @param args\n     */\n  }, {\n    key: \"compile\",\n    value: function compile(args) {\n      this.build();\n      this.model.compile(args);\n      this.optimizer_ = this.model.optimizer;\n      // tslint:disable-next-line:no-any\n      this.isOptimizerOwned = this.model.isOptimizerOwned;\n      this.loss = this.model.loss;\n      this.metrics = this.model.metrics;\n      // TODO(cais): Add this.lossWeights, this.sampleWeightMode,\n      //   this.weightedMetrics, this.targets.\n      this.metricsTensors = this.model.metricsTensors;\n      this.metricsNames = this.model.metricsNames;\n      // TODO(cais): Add sampleWeights.\n    }\n  }, {\n    key: \"optimizer\",\n    get: function get() {\n      return this.model == null ? undefined : this.model.optimizer;\n    },\n    set: function set(optimizer) {\n      this.model.optimizer = optimizer;\n    }\n    /**\n     * Trains the model for a fixed number of epochs (iterations on a dataset).\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *   batchSize: 4,\n     *   epochs: 3\n     * });\n     * console.log(history.history.loss[0]);\n     * ```\n     *\n     * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the\n     * model has multiple inputs. If all inputs in the model are named, you can\n     * also pass a dictionary mapping input names to `tf.Tensor`s.\n     * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if\n     * the model has multiple outputs. If all outputs in the model are named, you\n     *  can also pass a dictionary mapping output names to `tf.Tensor`s.\n     * @param args  A `ModelFitConfig`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and what the model expects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n  }, {\n    key: \"fit\",\n    value: function () {\n      var _fit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(x, y) {\n        var args,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              args = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n              if (this.built) {\n                _context2.next = 3;\n                break;\n              }\n              throw new RuntimeError('The model needs to be compiled before ' + 'being used.');\n            case 3:\n              return _context2.abrupt(\"return\", this.model.fit(x, y, args));\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function fit(_x10, _x11) {\n        return _fit.apply(this, arguments);\n      }\n      return fit;\n    }()\n    /**\n     * Trains the model using a dataset object.\n     *\n     * ```js\n     * const xArray = [\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     * ];\n     * const yArray = [1, 1, 1, 1];\n     * // Create a dataset from the JavaScript array.\n     * const xDataset = tf.data.array(xArray);\n     * const yDataset = tf.data.array(yArray);\n     * // Zip combines the `x` and `y` Datasets into a single Dataset, the\n     * // iterator of which will return an object containing of two tensors,\n     * // corresponding to `x` and `y`.  The call to `batch(4)` will bundle\n     * // four such samples into a single object, with the same keys now pointing\n     * // to tensors that hold 4 examples, organized along the batch dimension.\n     * // The call to `shuffle(4)` causes each iteration through the dataset to\n     * // happen in a different order.  The size of the shuffle window is 4.\n     * const xyDataset = tf.data.zip({xs: xDataset, ys: yDataset})\n     *     .batch(4)\n     *     .shuffle(4);\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [9]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const history = await model.fitDataset(xyDataset, {\n     *   epochs: 4,\n     *   callbacks: {onEpochEnd: (epoch, logs) => console.log(logs.loss)}\n     * });\n     * ```\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected to\n     *   generate a dataset iterator object, the `next()` method of which is\n     *   expected to produce data batches for evaluation. The return value of the\n     *   `next()` call ought to contain a boolean `done` field and a `value`\n     *   field.\n     *\n     *   The `value` field is expected to be an object of with fields\n     *   `xs` and `ys`, which point to the feature tensor and the target tensor,\n     *   respectively. This case is for models with exactly one input and one\n     *   output (e.g. a sequential model). For example:\n     *   ```js\n     *   {value: {xs: xsTensor, ys: ysTensor}, done: false}\n     *   ```\n     *\n     *   If the model has multiple inputs, the `xs` field of `value` should\n     *   be an object mapping input names to their respective feature tensors.\n     *   For example:\n     *   ```js\n     *   {\n     *     value: {\n     *       xs: {\n     *         input_1: xsTensor1,\n     *         input_2: xsTensor2\n     *       },\n     *       ys: ysTensor\n     *     },\n     *     done: false\n     *   }\n     *   ```\n     *   If the model has multiple outputs, the `ys` field of `value` should\n     *   be an object mapping output names to their respective target tensors.\n     *   For example:\n     *   ```js\n     *   {\n     *     value: {\n     *       xs: xsTensor,\n     *       ys: {\n     *         output_1: ysTensor1,\n     *         output_2: ysTensor2\n     *       },\n     *     },\n     *     done: false\n     *   }\n     *   ```\n     * @param args A `ModelFitDatasetArgs`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n     */\n  }, {\n    key: \"fitDataset\",\n    value: function () {\n      var _fitDataset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataset, args) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (this.built) {\n                _context3.next = 2;\n                break;\n              }\n              throw new RuntimeError('The model needs to be compiled before ' + 'being used.');\n            case 2:\n              return _context3.abrupt(\"return\", this.model.fitDataset(dataset, args));\n            case 3:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function fitDataset(_x12, _x13) {\n        return _fitDataset.apply(this, arguments);\n      }\n      return fitDataset;\n    }()\n    /**\n     * Runs a single gradient update on a single batch of data.\n     *\n     * This method differs from `fit()` and `fitDataset()` in the following\n     * regards:\n     *   - It operates on exactly one batch of data.\n     *   - It returns only the loss and metric values, instead of\n     *     returning the batch-by-batch loss and metric values.\n     *   - It doesn't support fine-grained options such as verbosity and\n     *     callbacks.\n     *\n     * @param x Input data. It could be one of the following:\n     *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has\n     *     multiple inputs).\n     *   - An Object mapping input names to corresponding `tf.Tensor` (if the\n     *     model has named inputs).\n     * @param y Target data. It could be either a `tf.Tensor` or multiple\n     *   `tf.Tensor`s. It should be consistent with `x`.\n     * @returns Training loss or losses (in case the model has\n     *   multiple outputs), along with metrics (if any), as numbers.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n  }, {\n    key: \"trainOnBatch\",\n    value: function () {\n      var _trainOnBatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(x, y) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              return _context4.abrupt(\"return\", this.model.trainOnBatch(x, y));\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function trainOnBatch(_x14, _x15) {\n        return _trainOnBatch.apply(this, arguments);\n      }\n      return trainOnBatch;\n    }()\n    /* See parent class for JsDoc */\n    /** @nocollapse */\n  }, {\n    key: \"stopTraining\",\n    get: function get() {\n      if (this.model == null) {\n        throw new ValueError('Cannot get the stopTraining property of a sequential model before ' + 'it is compiled.');\n      }\n      return this.model.stopTraining;\n    }\n    // TODO(cais): Override get trainableWeights() here\n    // tslint:disable-next-line:no-any\n    ,\n    set:\n    /**\n     * Setter used for force stopping of LayersModel.fit() (i.e., training).\n     *\n     * Example:\n     *\n     * ```js\n     * const model = tf.sequential();\n     * model.add(tf.layers.dense({units: 1, inputShape: [10]}));\n     * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n     * const xs = tf.ones([8, 10]);\n     * const ys = tf.zeros([8, 1]);\n     *\n     * const history = await model.fit(xs, ys, {\n     *   epochs: 10,\n     *   callbacks: {\n     *     onEpochEnd: async (epoch, logs) => {\n     *       if (epoch === 2) {\n     *         model.stopTraining = true;\n     *       }\n     *     }\n     *   }\n     * });\n     *\n     * // There should be only 3 values in the loss array, instead of 10 values,\n     * // due to the stopping after 3 epochs.\n     * console.log(history.history.loss);\n     * ```\n     */\n    function set(stop) {\n      // TODO(cais): When refactoring to remove the composition pattern happens,\n      // remove this method overriding.\n      if (this.model == null) {\n        throw new ValueError('Cannot set the stopTraining property of a sequential model before ' + 'it is compiled.');\n      }\n      this.model.stopTraining = stop;\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      // NOTE(cais): We override the return type of getConfig() to `any` here,\n      //   because the `Sequential` class is a special case among `Container`\n      //   subtypes in that its getConfig() method returns an Array (not a\n      //   dict).\n      var layers = [];\n      var _iterator2 = _createForOfIteratorHelper(this.layers),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var layer = _step2.value;\n          var dict = {};\n          dict['className'] = layer.getClassName();\n          dict['config'] = layer.getConfig();\n          layers.push(dict);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return {\n        name: this.name,\n        layers: layers\n      };\n    }\n  }], [{\n    key: \"fromConfig\",\n    value: function fromConfig(cls, config) {\n      var customObjects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var fastWeightInit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var configArray;\n      var extraModelConfig = {};\n      if (config instanceof Array) {\n        if (!(config[0].className != null) || config[0]['className'] === 'Merge') {\n          throw new ValueError('Legacy serialization format not supported yet.');\n        }\n        configArray = config;\n      } else {\n        util.assert(config['layers'] != null, function () {\n          return \"When the config data for a Sequential model is not an Array, \" + \"it must be an Object that contains the 'layers' field.\";\n        });\n        configArray = config['layers'];\n        delete config['layers'];\n        extraModelConfig = config;\n      }\n      var model = new cls(extraModelConfig);\n      if (!(model instanceof Sequential)) {\n        throw new NotImplementedError(\"Sequential.fromConfig called on non-Sequential input: \".concat(model));\n      }\n      var _iterator3 = _createForOfIteratorHelper(configArray),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var conf = _step3.value;\n          var _customObjects = undefined;\n          var layer = deserialize(conf, _customObjects, fastWeightInit);\n          if (fastWeightInit) {\n            layer.setFastWeightInitDuringBuild(true);\n          }\n          model.add(layer);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return model;\n    }\n  }]);\n  return Sequential;\n}(LayersModel);\n/** @nocollapse */\nSequential.className = 'Sequential';\nserialization.registerClass(Sequential);","map":{"version":3,"mappings":";;;;;;;;;AAAA;;;;;;;;;AAUA;AAEA,SAAQA,OAAO,EAAEC,EAAE,EAAqCC,aAAa,EAAUC,IAAI,QAAO,uBAAuB;AAEjH,SAAQC,MAAM,QAAO,iBAAiB;AAGtC,SAAQC,KAAK,QAAO,sBAAsB;AAC1C,SAAQC,eAAe,EAASC,IAAI,QAAuB,mBAAmB;AAC9E,SAAQC,WAAW,QAA4C,mBAAmB;AAGlF,SAAQC,mBAAmB,EAAEC,YAAY,EAAEC,UAAU,QAAO,UAAU;AAItE,SAAQC,WAAW,QAAO,wBAAwB;AAElD,OAAO,KAAKC,aAAa,MAAM,uBAAuB;AACtD,SAAQC,mBAAmB,QAAO,6BAA6B;AAC/D,SAAQC,kBAAkB,QAAO,qBAAqB;AAEtD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,gBAAsBC,aAAa;EAAA;AAAA;AAqFnC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;EAAA,4EArFO,kBACHC,qBAAuD,EACvDC,aAAwC;IAAA;IAAA;MAAA;QAAA;UAC1C,IAAI,EAAE,eAAe,IAAID,qBAAqB,CAAC,EAAE;YAC/CA,qBAAqB,GAAG;cAACE,aAAa,EAAEF;YAAqB,CAAC;;UAEhEA,qBAAqB,GAAGA,qBAA8C;UAElEE,aAAa,GAAGF,qBAAqB,CAACE,aAAa;UACvD,IAAIA,aAAa,CAAC,cAAc,CAAC,IAAI,IAAI,EAAE;YACzC;YACA;YACA;YACA;YACA;YACAA,aAAa,GAAGA,aAAa,CAAC,cAAc,CAAe;;UAEvDC,QAAQ,GACVN,mBAAmB,CAACK,aAAa,CAA6B;UAC5DE,KAAK,GAAGT,WAAW,CAACQ,QAAQ,EAAEF,aAAa,CAAgB;UAAA,MAE7DD,qBAAqB,CAACK,eAAe,IAAI,IAAI;YAAA;YAAA;UAAA;UAAA;UAAA,OAIpBrB,EAAE,CAACsB,WAAW,CACrCN,qBAAqB,CAACK,eAAe,EAAEL,qBAAqB,CAACO,UAAU,EACvEH,KAAK,CAACI,OAAO,CAACC,GAAG,CAAC,gBAAM;YAAA,OAAIC,MAAM,CAACC,YAAY;UAAA,EAAC,CAAC;QAAA;UAF/CC,YAAY;UAIlB;UACMC,kBAAkB,GAAmB,EAAE;UAAA,wCACxBT,KAAK,CAACI,OAAO;UAAA;YAAlC,uDAAoC;cAAzBE,MAAM;cACfG,kBAAkB,CAACH,MAAM,CAACC,YAAY,CAAC,GACnCC,YAAY,CAACF,MAAM,CAACC,YAAY,CAAC;;UACtC;YAAA;UAAA;YAAA;UAAA;UAEDP,KAAK,CAACE,WAAW,CAACO,kBAAkB,CAAC;UACrC;UACA9B,OAAO,CAAC6B,YAAY,CAAC;QAAC;UAAA,kCAEjBR,KAAK;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,CACb;EAAA;AAAA;AAiJD,gBAAsBU,eAAe;EAAA;AAAA;AAwBrC;;;;;;;;;;AAAA;EAAA,8EAxBO,kBACHC,eAAoC,EACpCC,OAAwB;IAAA;IAAA;MAAA;QAAA;UAC1B,IAAIA,OAAO,IAAI,IAAI,EAAE;YACnBA,OAAO,GAAG,EAAE;;UACb,MACG,OAAOD,eAAe,KAAK,QAAQ;YAAA;YAAA;UAAA;UAC/BE,QAAQ,GAAGjC,EAAE,CAACkC,eAAe,CAACH,eAAe,EAAEC,OAAO,CAAC;UAAA,MACzDC,QAAQ,CAACE,MAAM,KAAK,CAAC;YAAA;YAAA;UAAA;UACvB;UACA;UACA;UACA;UACAF,QAAQ,CAACG,IAAI,CAACpC,EAAE,CAACqC,kBAAkB,CAACN,eAAe,EAAEC,OAAO,CAAC,CAAC;UAAC;UAAA;QAAA;UAAA,MACtDC,QAAQ,CAACE,MAAM,GAAG,CAAC;YAAA;YAAA;UAAA;UAAA,MACtB,IAAIzB,UAAU,CAChB,+BAAwBuB,QAAQ,CAACE,MAAM,2CAC/BJ,eAAe,MAAG,CAAC;QAAA;UAEjCA,eAAe,GAAGE,QAAQ,CAAC,CAAC,CAAC;QAAC;UAAA,kCAEzBK,4BAA4B,CAACP,eAAe,EAAEQ,SAAS,EAAEP,OAAO,CAAC;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,CACzE;EAAA;AAAA;AAYD,gBAAsBM,4BAA4B;EAAA;AAAA;AA4DjD;EAAA,2FA5DM,kBACHE,OAAqB,EAAEvB,aAAwC,EAC/De,OAAwB;IAAA;IAAA;MAAA;QAAA;UAC1B,IAAIA,OAAO,IAAI,IAAI,EAAE;YACnBA,OAAO,GAAG,EAAE;;UACb,MACGQ,OAAO,CAACC,IAAI,IAAI,IAAI;YAAA;YAAA;UAAA;UAAA,MAChB,IAAI/B,UAAU,CAChB,mEAAmE,GACnE,8CAA8C,CAAC;QAAA;UAAA;UAAA,OAE7B8B,OAAO,CAACC,IAAI,EAAE;QAAA;UAAhCC,SAAS;UACXxB,aAAa,GAAGwB,SAAS,CAACxB,aAA2B;UACzD,IAAIA,aAAa,CAAC,cAAc,CAAC,IAAI,IAAI,EAAE;YACzCA,aAAa,GAAGA,aAAa,CAAC,cAAc,CAAe;;UAGvDyB,MAAM,GAAGX,OAAO,CAACW,MAAM,IAAI,IAAI,GAAG,IAAI,GAAGX,OAAO,CAACW,MAAM,EAC7D;UACA;UACA;UACA;UACA;UACMC,cAAc,GAChBF,SAAS,CAACG,UAAU,IAAI,IAAI,IAAIH,SAAS,CAACI,WAAW,IAAI,IAAI,IAAIH,MAAM;UACrEvB,KAAK,GACPT,WAAW,CACPE,mBAAmB,CAACK,aAAa,CAA6B,EAC9DD,aAAa,EAAE2B,cAAc,CAAgB;UAE/CG,cAAc,GAAGL,SAAS,CAACK,cAAgC;UACjE,IAAIA,cAAc,IAAI,IAAI,EAAE;YAC1B3B,KAAK,CAAC4B,kBAAkB,CAACD,cAAc,CAAC;;UAE1C,IAAIL,SAAS,CAACO,mBAAmB,IAAI,IAAI,EAAE;YACzC7B,KAAK,CAAC8B,sBAAsB,CAACR,SAAS,CAACO,mBAAmB,CAAC;;UAG7D;UAAA,MACIP,SAAS,CAACG,UAAU,IAAI,IAAI;YAAA;YAAA;UAAA;UAAA,MAE1BH,SAAS,CAACI,WAAW,IAAI,IAAI;YAAA;YAAA;UAAA;UAAA,MACzB,IAAIpC,UAAU,CAChB,oEAAoE,GACpE,8CAA8C,CAAC;QAAA;UAAA,wBAGZyC,8BAA8B,CACnET,SAAS,CAACG,UAAU,EAAEH,SAAS,CAACI,WAAW,CAAC,EADzCM,YAAY,yBAAZA,YAAY,EAAEC,gBAAgB,yBAAhBA,gBAAgB;UAErCjC,KAAK,CAACE,WAAW,CAAC8B,YAAY,EAAET,MAAM,CAAC;UAAC,MAEpCvB,KAAK,CAACkC,SAAS,IAAI,IAAI,IAAID,gBAAgB,CAAClB,MAAM,GAAG,CAAC;YAAA;YAAA;UAAA;UAAA;UAAA,OAClDf,KAAK,CAACkC,SAAS,CAACC,UAAU,CAACF,gBAAgB,CAAC;QAAA;UAGpD;UACAtD,OAAO,CAACqD,YAAY,CAAC;UACrBrD,OAAO,CAACsD,gBAAgB,CAAC5B,GAAG,CAAC,WAAC;YAAA,OAAI+B,CAAC,CAACC,MAAM;UAAA,EAAC,CAAC;QAAC;UAAA,kCAExCrC,KAAK;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,CACb;EAAA;AAAA;AAED,SAAS+B,8BAA8B,CACnCO,MAAmB,EAAEC,KAAgC;EAEvD,IAAMC,WAAW,GAAG5D,EAAE,CAAC6D,aAAa,CAACH,MAAM,EAAEC,KAAK,CAAC;EACnD,IAAMP,YAAY,GAAmB,EAAE;EACvC,IAAMC,gBAAgB,GAAkB,EAAE;EAC1CM,KAAK,CAACG,OAAO,CAAC,cAAI,EAAG;IACnB,IAAIC,IAAI,CAACC,KAAK,KAAK,WAAW,EAAE;MAC9BX,gBAAgB,CAACjB,IAAI,CAAC;QAAC6B,IAAI,EAAEF,IAAI,CAACE,IAAI;QAAER,MAAM,EAAEG,WAAW,CAACG,IAAI,CAACE,IAAI;MAAC,CAAC,CAAC;KACzE,MAAM;MACLb,YAAY,CAACW,IAAI,CAACE,IAAI,CAAC,GAAGL,WAAW,CAACG,IAAI,CAACE,IAAI,CAAC;;EAEpD,CAAC,CAAC;EACF,OAAO;IAACb,YAAY,EAAZA,YAAY;IAAEC,gBAAgB,EAAhBA;EAAgB,CAAC;AACzC;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,WAAaa,UAAW;EAAA;EAAA;EAItB,oBAAYC,IAAqB;IAAA;IAAA;IAC/B,0BAAM;MAACC,MAAM,EAAE,EAAE;MAAEC,OAAO,EAAE;IAAE,CAAC;IAC/BF,IAAI,GAAGA,IAAI,IAAI,EAAE;IAEjB,MAAKG,SAAS,GAAG,IAAI;IACrB,MAAKC,KAAK,GAAG,KAAK;IAElB;IACA,MAAKN,IAAI,GAAIE,IAAI,CAACF,IAAI,IAAI,IAAI,GAAIE,IAAI,CAACF,IAAI,GAAG9D,MAAM,CAAC,aAAa,CAAC;IAEnE;IACA,IAAIgE,IAAI,CAACK,MAAM,IAAI,IAAI,EAAE;MAAA,2CACHL,IAAI,CAACK,MAAM;QAAA;MAAA;QAA/B,oDAAiC;UAAA,IAAtBC,KAAK;UACd,MAAKC,GAAG,CAACD,KAAK,CAAC;;MAChB;QAAA;MAAA;QAAA;MAAA;;IACF;EACH;EAEA;EACA;EAAA;IAAA;IAAA,OACQ,oBAAWA,KAAY;MAC7B,IAAME,KAAK,GAAGF,KAAK,CAACG,YAAY,CAAC,CAAC,CAAC,CAACC,aAAa,CAAC,CAAC,CAAC,CAACF,KAAK;MAC1D,IAAIA,KAAK,CAACG,IAAI,CAAC,WAAC;QAAA,OAAIC,CAAC,GAAG,CAAC;MAAA,EAAC,EAAE;QAC1B,MAAM,IAAIrE,UAAU,CAChB,iDAAiD,aAC9C+D,KAAK,CAACR,IAAI,wBAAqB,aAC/BQ,KAAK,CAACG,YAAY,CAAC,CAAC,CAAC,CAACI,YAAY,CAAC,CAAC,CAAC,CAACL,KAAK,MAAG,CAAC;;IAE1D;IAEA;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA,OAqBA,aAAIF,KAAY;MACd,IAAMQ,oBAAoB,GACtBR,KAAK,YAAYP,UAAU,IAAIO,KAAK,YAAYlE,WAAW;MAC/D,IAAI2E,UAAuB;MAC3B,IAAID,oBAAoB,EAAE;QACxBC,UAAU,GAAGT,KAAoB;QACjC,IAAIS,UAAU,CAACb,OAAO,CAAClC,MAAM,KAAK,CAAC,EAAE;UACnC,MAAM,IAAIzB,UAAU,CAChB,mCAAmC,GACnC,sCAAsC,GACtC,2BAA2B,GAC3B,yBAAyB,CAAC;;QAEhC,IAAIwE,UAAU,CAACd,MAAM,CAACjC,MAAM,KAAK,CAAC,EAAE;UAClC,MAAM,IAAIzB,UAAU,CAChB,mCAAmC,GACnC,qCAAqC,GACrC,0BAA0B,GAC1B,yBAAyB,CAAC;;;MAIlC,IAAI,IAAI,CAAC2D,OAAO,CAAClC,MAAM,KAAK,CAAC,EAAE;QAC7B;QACA,IAAIsC,KAAK,CAACG,YAAY,CAACzC,MAAM,KAAK,CAAC,EAAE;UACnC;UACA,IAAIsC,KAAK,CAACU,eAAe,IAAI,IAAI,EAAE;YACjC,MAAM,IAAIzE,UAAU,CAChB,6CAA6C,GAC7C,oDAAoD,CAAC;;UAE3D;UACA,IAAMqE,CAAC,GAAG3E,KAAK,CAAC;YACdgF,UAAU,EAAEX,KAAK,CAACU,eAAe;YACjCE,KAAK,EAAEZ,KAAK,CAACY,KAAK;YAClBpB,IAAI,EAAEQ,KAAK,CAACR,IAAI,GAAG;WACpB,CAAC;UACF;UACA;UACAQ,KAAK,CAACa,KAAK,CAACP,CAAC,CAAC;;QAGhB,IAAIE,oBAAoB,EAAE;UACxB,IAAI,CAACZ,OAAO,GAAGa,UAAU,CAACb,OAAO;UACjC,IAAI,CAACD,MAAM,GAAGc,UAAU,CAACd,MAAM;SAChC,MAAM;UACL,IAAIK,KAAK,CAACG,YAAY,CAACzC,MAAM,KAAK,CAAC,EAAE;YACnC,MAAM,IAAIzB,UAAU,CAChB,0DAA0D,kEAEtD+D,KAAK,CAACR,IAAI,MAAG,uBACJQ,KAAK,CAACG,YAAY,CAACzC,MAAM,2BAAwB,GAC9D,cAAc,CAAC;;UAGrB,IAAIsC,KAAK,CAACG,YAAY,CAAC,CAAC,CAAC,CAACC,aAAa,CAAC1C,MAAM,KAAK,CAAC,EAAE;YACpD,MAAM,IAAIzB,UAAU,CAChB,mCAAmC,GACnC,sCAAsC,GACtC,2BAA2B,GAC3B,yBAAyB,CAAC;;UAEhC,IAAI,CAAC6E,UAAU,CAACd,KAAK,CAAC;UACtB,IAAI,CAACJ,OAAO,GAAG,CAACI,KAAK,CAACG,YAAY,CAAC,CAAC,CAAC,CAACC,aAAa,CAAC,CAAC,CAAC,CAAC;UACvD,IAAI,CAACT,MAAM,GAAG/D,eAAe,CAAC,IAAI,CAACgE,OAAO,CAAC,CAAC,CAAC,CAAC;;QAGhD,IAAI,CAACO,YAAY,GAAG,EAAE;QACtB;QACA;QACA;QACA;QACA,IAAItE,IAAI,CAAC;UACPkF,aAAa,EAAE,IAAI;UACnBC,aAAa,EAAE,EAAE;UACjBC,WAAW,EAAE,EAAE;UACfC,aAAa,EAAE,EAAE;UACjBX,YAAY,EAAE,IAAI,CAACZ,MAAM;UACzBS,aAAa,EAAE,IAAI,CAACR,OAAO;UAC3B;UACAuB,UAAU,EAAEhF,aAAa,CAACiF,YAAY,CAAC,IAAI,EAAE,IAAI,CAACzB,MAAM,CAACjC,MAAM,CAAC;UAChE2D,WAAW,EAAE,CAAC,IAAI,CAAC;UACnBC,WAAW,EAAE,IAAI,CAAC3B,MAAM,CAAC3C,GAAG,CAAC,WAAC;YAAA,OAAIsD,CAAC,CAACJ,KAAK;UAAA,EAAC;UAC1CqB,YAAY,EAAE,IAAI,CAAC3B,OAAO,CAAC,CAAC,CAAC,CAACM;SAC/B,CAAC;OACH,MAAM;QACL,IAAMsB,YAAY,GAAGxB,KAAK,CAACa,KAAK,CAAC,IAAI,CAACjB,OAAO,CAAC,CAAC,CAAC,CAAC;QACjD,IAAI6B,KAAK,CAACC,OAAO,CAACF,YAAY,CAAC,EAAE;UAC/B,MAAM,IAAIG,SAAS,CACf,mCAAmC,GACnC,sCAAsC,GACtC,2BAA2B,GAC3B,yBAAyB,CAAC;;QAEhC,IAAI,CAACb,UAAU,CAACd,KAAK,CAAC;QACtB,IAAI,CAACJ,OAAO,GAAG,CAAC4B,YAA8B,CAAC;QAC/C;QACA,IAAI,CAACrB,YAAY,CAAC,CAAC,CAAC,CAACC,aAAa,GAAG,IAAI,CAACR,OAAO;QACjD,IAAI,CAACO,YAAY,CAAC,CAAC,CAAC,CAACoB,YAAY,GAAG,CAAC,IAAI,CAAC3B,OAAO,CAAC,CAAC,CAAC,CAACM,KAAK,CAAC;;MAG7D,IAAI,CAACH,MAAM,CAACpC,IAAI,CAACqC,KAAK,CAAC;MACvB,IAAI,CAACF,KAAK,GAAG,KAAK;IACpB;IAEA;;;;;EAAA;IAAA;IAAA,OAKA,eAAG;MACD,IAAI,IAAI,CAACC,MAAM,CAACrC,MAAM,KAAK,CAAC,EAAE;QAC5B,MAAM,IAAIiE,SAAS,CAAC,mCAAmC,CAAC;;MAG1D,IAAI,CAAC5B,MAAM,CAAC6B,GAAG,EAAE;MACjB,IAAI,IAAI,CAAC7B,MAAM,CAACrC,MAAM,KAAK,CAAC,EAAE;QAC5B,IAAI,CAACkC,OAAO,GAAG,EAAE;QACjB,IAAI,CAACO,YAAY,GAAG,EAAE;QACtB,IAAI,CAAC0B,aAAa,GAAG,EAAE;OACxB,MAAM;QACL,IAAMC,cAAc,GAAG,IAAI,CAAC/B,MAAM,CAACrC,MAAM,GAAG,CAAC;QAC7C,IAAI,CAACqC,MAAM,CAAC+B,cAAc,CAAC,CAACD,aAAa,GAAG,EAAE;QAC9C,IAAI,CAACjC,OAAO,GAAG,CAAC,IAAI,CAACG,MAAM,CAAC+B,cAAc,CAAC,CAACC,MAAwB,CAAC;QACrE;QACA,IAAI,CAAC5B,YAAY,CAAC,CAAC,CAAC,CAACC,aAAa,GAAG,IAAI,CAACR,OAAO;QACjD,IAAI,CAACO,YAAY,CAAC,CAAC,CAAC,CAACoB,YAAY,GAAG,CAAC,IAAI,CAAC3B,OAAO,CAAC,CAAC,CAAC,CAACM,KAAK,CAAC;;IAE/D;EAAC;IAAA;IAAA,OAEQ,cAAKP,MAAuB,EAAEqC,MAAc;MACnD,IAAI,IAAI,CAACrF,KAAK,IAAI,IAAI,EAAE;QACtB,IAAI,CAACsF,KAAK,EAAE;;MAEd,OAAO,IAAI,CAACtF,KAAK,CAACuF,IAAI,CAACvC,MAAM,EAAEqC,MAAM,CAAC;IACxC;EAAC;IAAA;IAAA,OAEQ,eAAMG,UAA0B;MACvC;MACA;MACA9F,kBAAkB,CAAC8F,UAAU,CAAC;MAE9B,IAAI,IAAI,CAACxC,MAAM,CAACjC,MAAM,KAAK,CAAC,IAAI,IAAI,CAACkC,OAAO,CAAClC,MAAM,KAAK,CAAC,EAAE;QACzD,MAAM,IAAIiE,SAAS,CACf,mDAAmD,GACnD,yBAAyB,CAAC;;MAEhC;MACA,IAAI,CAAChF,KAAK,GAAG,IAAIb,WAAW,CAAC;QAC3B6D,MAAM,EAAE,IAAI,CAACA,MAAM;QACnBC,OAAO,EAAE,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC;QACxBJ,IAAI,EAAE,IAAI,CAACA,IAAI,GAAG;OACnB,CAAC;MACF,IAAI,CAAC7C,KAAK,CAACkD,SAAS,GAAG,IAAI,CAACA,SAAS;MAErC;MACA,IAAI,CAACuC,eAAe,GAAG,IAAI,CAACzF,KAAK,CAACyF,eAAe;MACjD;MACA,IAAI,CAACC,WAAW,GAAG,IAAI,CAAC1F,KAAK,CAAC0F,WAAW;MACzC,IAAI,CAACC,sBAAsB,GAAG,IAAI,CAAC3F,KAAK,CAAC2F,sBAAsB;MAC/D,IAAI,CAACC,wBAAwB,GAAG,IAAI,CAAC5F,KAAK,CAAC4F,wBAAwB;MACnE,IAAI,CAACC,YAAY,GAAG,IAAI,CAAC7F,KAAK,CAAC6F,YAAY;MAC3C,IAAI,CAACC,uBAAuB,GAAG,IAAI,CAAC9F,KAAK,CAAC8F,uBAAuB;MACjE,IAAI,CAACC,yBAAyB,GAAG,IAAI,CAAC/F,KAAK,CAAC+F,yBAAyB;MACrE,IAAI,CAACC,YAAY,GAAG,IAAI,CAAChG,KAAK,CAACgG,YAAY;MAC3C,IAAI,CAACC,cAAc,GAAG,IAAI,CAACjG,KAAK,CAACiG,cAAc;MAC/C,IAAI,CAACC,WAAW,GAAG,IAAI,CAAClG,KAAK,CAACkG,WAAW;MACzC,IAAI,CAACC,UAAU,GAAG,IAAI,CAACnG,KAAK,CAACmG,UAAU;MACvC;MACA;MACA,IAAI,CAAChD,KAAK,GAAG,IAAI;IACnB;EAAC;IAAA;IAAA,OAEQ,uBAAW;MAClB,IAAI,CAAC,IAAI,CAACA,KAAK,EAAE;QACf,IAAI,CAACmC,KAAK,EAAE;;MAEd;IACF;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA,OA8BS,iBACLc,UAAmB,EAAEC,SAAoB,EAGsB;MAAA,IAF/DC,8EAEoDC,OAAO,CAACC,GAAG;MACjE,IAAI,CAAC,IAAI,CAACrD,KAAK,EAAE;QACf,IAAI,CAACmC,KAAK,EAAE;;MAEd,wEAAcc,UAAU,EAAEC,SAAS,EAAEC,OAAO;IAC9C;IAEA;;;;;;EAAA;IAAA;IAAA,OAMS,oBAAWlG,OAAiB;MACnC,IAAI,IAAI,CAACJ,KAAK,IAAI,IAAI,EAAE;QACtB,IAAI,CAACsF,KAAK,EAAE;;MAEd,IAAI,CAACtF,KAAK,CAACmC,UAAU,CAAC/B,OAAO,CAAC;IAChC;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA,OAgCS,kBACLuD,CAAkB,EAAE8C,CAAkB,EACV;MAAA,IAA5B1D,2EAA0B,EAAE;MAC9B,IAAI,CAAC,IAAI,CAACI,KAAK,EAAE;QACf,MAAM,IAAI9D,YAAY,CAClB,mDAAmD,CAAC;;MAE1D,OAAO,IAAI,CAACW,KAAK,CAAC0G,QAAQ,CAAC/C,CAAC,EAAE8C,CAAC,EAAE1D,IAAI,CAAC;IACxC;IAEA;IACA;IACA;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,kFAoBS,iBAAsB4D,OAAoB,EAC/C5D,IAA8B;QAAA;UAAA;YAAA;cAAA,IAC3B,IAAI,CAACI,KAAK;gBAAA;gBAAA;cAAA;cAAA,MACP,IAAI9D,YAAY,CAClB,mDAAmD,CAAC;YAAA;cAAA,iCAEnD,IAAI,CAACW,KAAK,CAAC4G,eAAe,CAACD,OAAO,EAAE5D,IAAI,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CACjD;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA,OA2BS,iBAAQY,CAAkB,EAA6B;MAAA,IAA3BZ,2EAAyB,EAAE;MAE9D,IAAI,IAAI,CAAC/C,KAAK,IAAI,IAAI,EAAE;QACtB,IAAI,CAACsF,KAAK,EAAE;;MAEd,OAAO,IAAI,CAACtF,KAAK,CAAC6G,OAAO,CAAClD,CAAC,EAAEZ,IAAI,CAAC;IACpC;IAEA;;;;;;;EAAA;IAAA;IAAA,OAOS,wBAAeY,CAAS;MAC/B,IAAI,IAAI,CAAC3D,KAAK,IAAI,IAAI,EAAE;QACtB,IAAI,CAACsF,KAAK,EAAE;;MAEd,OAAO,IAAI,CAACtF,KAAK,CAAC8G,cAAc,CAACnD,CAAC,CAAC;IACrC;IAEA;;;;;EAAA;IAAA;IAAA,OAKS,iBAAQZ,IAAsB;MACrC,IAAI,CAACuC,KAAK,EAAE;MACZ,IAAI,CAACtF,KAAK,CAAC+G,OAAO,CAAChE,IAAI,CAAC;MACxB,IAAI,CAACiE,UAAU,GAAG,IAAI,CAAChH,KAAK,CAACkC,SAAS;MACtC;MACA,IAAI,CAAC+E,gBAAgB,GAAI,IAAI,CAACjH,KAAa,CAACiH,gBAAgB;MAC5D,IAAI,CAACC,IAAI,GAAG,IAAI,CAAClH,KAAK,CAACkH,IAAI;MAC3B,IAAI,CAACC,OAAO,GAAG,IAAI,CAACnH,KAAK,CAACmH,OAAO;MACjC;MACA;MACA,IAAI,CAACC,cAAc,GAAG,IAAI,CAACpH,KAAK,CAACoH,cAAc;MAC/C,IAAI,CAACC,YAAY,GAAG,IAAI,CAACrH,KAAK,CAACqH,YAAY;MAC3C;IACF;EAAC;IAAA;IAAA,KAED,eAAsB;MACpB,OAAO,IAAI,CAACrH,KAAK,IAAI,IAAI,GAAGmB,SAAS,GAAG,IAAI,CAACnB,KAAK,CAACkC,SAAS;IAC9D,CAAC;IAAA,KAED,aAAuBA,SAAoB;MACzC,IAAI,CAAClC,KAAK,CAACkC,SAAS,GAAGA,SAAS;IAClC;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,sEA+BS,kBACLyB,CAAgD,EAChD8C,CAAgD;QAAA;UAAA;QAAA;UAAA;YAAA;cAChD1D,kEAAqB,EAAE;cAAA,IACpB,IAAI,CAACI,KAAK;gBAAA;gBAAA;cAAA;cAAA,MACP,IAAI9D,YAAY,CAClB,wCAAwC,GACxC,aAAa,CAAC;YAAA;cAAA,kCAEb,IAAI,CAACW,KAAK,CAACsH,GAAG,CAAC3D,CAAC,EAAE8C,CAAC,EAAE1D,IAAI,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CAClC;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,6EAqFS,kBAAoB4D,OAAmB,EAC5C5D,IAA4B;QAAA;UAAA;YAAA;cAAA,IACzB,IAAI,CAACI,KAAK;gBAAA;gBAAA;cAAA;cAAA,MACP,IAAI9D,YAAY,CAClB,wCAAwC,GACxC,aAAa,CAAC;YAAA;cAAA,kCAEb,IAAI,CAACW,KAAK,CAACuH,UAAU,CAACZ,OAAO,EAAE5D,IAAI,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CAC5C;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,+EAuBS,kBACLY,CAAgD,EAChD8C,CAC6B;QAAA;UAAA;YAAA;cAAA,kCACxB,IAAI,CAACzG,KAAK,CAACwH,YAAY,CAAC7D,CAAC,EAAE8C,CAAC,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CACrC;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;IACA;EAAA;IAAA;IAAA,KAkFA,eAAyB;MACvB,IAAI,IAAI,CAACzG,KAAK,IAAI,IAAI,EAAE;QACtB,MAAM,IAAIV,UAAU,CAChB,oEAAoE,GACpE,iBAAiB,CAAC;;MAExB,OAAO,IAAI,CAACU,KAAK,CAACyH,YAAY;IAChC;IAEA;IAEA;IAAA;IAAA;IAlDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA4BA,aAA0BC,IAAa;MACrC;MACA;MACA,IAAI,IAAI,CAAC1H,KAAK,IAAI,IAAI,EAAE;QACtB,MAAM,IAAIV,UAAU,CAChB,oEAAoE,GACpE,iBAAiB,CAAC;;MAExB,IAAI,CAACU,KAAK,CAACyH,YAAY,GAAGC,IAAI;IAChC;EAAC;IAAA;IAAA,OAcQ,qBAAS;MAChB;MACA;MACA;MACA;MACA,IAAMtE,MAAM,GAA+B,EAAE;MAAC,4CAC1B,IAAI,CAACA,MAAM;QAAA;MAAA;QAA/B,uDAAiC;UAAA,IAAtBC,KAAK;UACd,IAAMsE,IAAI,GAA6B,EAAE;UACzCA,IAAI,CAAC,WAAW,CAAC,GAAGtE,KAAK,CAACuE,YAAY,EAAE;UACxCD,IAAI,CAAC,QAAQ,CAAC,GAAGtE,KAAK,CAACwE,SAAS,EAAE;UAClCzE,MAAM,CAACpC,IAAI,CAAC2G,IAAI,CAAC;;MAClB;QAAA;MAAA;QAAA;MAAA;MACD,OAAO;QAAC9E,IAAI,EAAE,IAAI,CAACA,IAAI;QAAEO,MAAM,EAANA;MAAM,CAAC;IAClC;EAAC;IAAA;IAAA,OA1GD,oBACI0E,GAA6C,EAC7CC,MAAgC,EAEV;MAAA,IADtBlI,oFAAgB,EAA8B;MAAA,IAC9C2B,cAAc,uEAAG,KAAK;MACxB,IAAIwG,WAA0C;MAC9C,IAAIC,gBAAgB,GAA6B,EAAE;MACnD,IAAIF,MAAM,YAAYjD,KAAK,EAAE;QAC3B,IAAI,EAAEiD,MAAM,CAAC,CAAC,CAAC,CAACG,SAAS,IAAI,IAAI,CAAC,IAC9BH,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,OAAO,EAAE;UACtC,MAAM,IAAIzI,UAAU,CAAC,gDAAgD,CAAC;;QAExE0I,WAAW,GAAGD,MAAM;OACrB,MAAM;QACLjJ,IAAI,CAACqJ,MAAM,CACPJ,MAAM,CAAC,QAAQ,CAAC,IAAI,IAAI,EACxB;UAAA,OACI,0HACwD;QAAA,EAAC;QACjEC,WAAW,GAAGD,MAAM,CAAC,QAAQ,CAAkC;QAC/D,OAAOA,MAAM,CAAC,QAAQ,CAAC;QACvBE,gBAAgB,GAAGF,MAAM;;MAG3B,IAAM/H,KAAK,GAAG,IAAI8H,GAAG,CAACG,gBAAgB,CAAC;MACvC,IAAI,EAAEjI,KAAK,YAAY8C,UAAU,CAAC,EAAE;QAClC,MAAM,IAAI1D,mBAAmB,iEACgCY,KAAK,EAAG;;MACtE,4CACkBgI,WAAW;QAAA;MAAA;QAA9B,uDAAgC;UAAA,IAArBI,IAAI;UACb,IAAMvI,cAAa,GAA6BsB,SAAS;UACzD,IAAMkC,KAAK,GAAG9D,WAAW,CACP6I,IAAgC,EAAEvI,cAAa,EAC/C2B,cAAc,CAAU;UAC1C,IAAIA,cAAc,EAAE;YAClB6B,KAAK,CAACgF,4BAA4B,CAAC,IAAI,CAAC;;UAE1CrI,KAAK,CAACsD,GAAG,CAACD,KAAK,CAAC;;MACjB;QAAA;MAAA;QAAA;MAAA;MACD,OAAOrD,KAAK;IACd;EAAC;EAAA;AAAA,EAzoB6Bb,WAAW;AACzC;AACgB2D,oBAAS,GAAG,YAAY;AA2sB1CjE,aAAa,CAACyJ,aAAa,CAACxF,UAAU,CAAC","names":["dispose","io","serialization","util","getUid","Input","getSourceInputs","Node","LayersModel","NotImplementedError","RuntimeError","ValueError","deserialize","generic_utils","convertPythonicToTs","getExactlyOneShape","modelFromJSON","modelAndWeightsConfig","customObjects","modelTopology","tsConfig","model","weightsManifest","loadWeights","pathPrefix","weights","map","weight","originalName","weightValues","uniqueWeightValues","loadLayersModel","pathOrIOHandler","options","handlers","getLoadHandlers","length","push","browserHTTPRequest","loadLayersModelFromIOHandler","undefined","handler","load","artifacts","strict","fastWeightInit","weightData","weightSpecs","trainingConfig","loadTrainingConfig","userDefinedMetadata","setUserDefinedMetadata","decodeModelAndOptimizerWeights","modelWeights","optimizerWeights","optimizer","setWeights","w","tensor","buffer","specs","name2Tensor","decodeWeights","forEach","spec","group","name","Sequential","args","inputs","outputs","trainable","built","layers","layer","add","shape","inboundNodes","outputTensors","some","x","inputTensors","isLayerModelInstance","modelLayer","batchInputShape","batchShape","dtype","apply","checkShape","outboundLayer","inboundLayers","nodeIndices","tensorIndices","inputMasks","pyListRepeat","outputMasks","inputShapes","outputShapes","outputTensor","Array","isArray","TypeError","pop","outboundNodes","lastLayerIndex","output","kwargs","build","call","inputShape","supportsMasking","inputLayers","inputLayersNodeIndices","inputLayersTensorIndices","outputLayers","outputLayersNodeIndices","outputLayersTensorIndices","nodesByDepth","containerNodes","outputNames","inputNames","lineLength","positions","printFn","console","log","y","evaluate","dataset","evaluateDataset","predict","predictOnBatch","compile","optimizer_","isOptimizerOwned","loss","metrics","metricsTensors","metricsNames","fit","fitDataset","trainOnBatch","stopTraining","stop","dict","getClassName","getConfig","cls","config","configArray","extraModelConfig","className","assert","conf","setFastWeightInitDuringBuild","registerClass"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-layers\\src\\models.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source keras/models.py */\n\nimport {dispose, io, NamedTensorMap, Optimizer, Scalar, serialization, Tensor, util} from '@tensorflow/tfjs-core';\n\nimport {getUid} from './backend/state';\nimport {History} from './base_callbacks';\nimport {Dataset} from './engine/dataset_stub';\nimport {Input} from './engine/input_layer';\nimport {getSourceInputs, Layer, Node, SymbolicTensor} from './engine/topology';\nimport {LayersModel, ModelCompileArgs, ModelEvaluateArgs} from './engine/training';\nimport {ModelEvaluateDatasetArgs, ModelFitDatasetArgs} from './engine/training_dataset';\nimport {ModelFitArgs} from './engine/training_tensors';\nimport {NotImplementedError, RuntimeError, ValueError} from './errors';\nimport {Shape} from './keras_format/common';\nimport {TrainingConfig} from './keras_format/training_config';\nimport {PyJsonDict} from './keras_format/types';\nimport {deserialize} from './layers/serialization';\nimport {Kwargs, NamedTensor} from './types';\nimport * as generic_utils from './utils/generic_utils';\nimport {convertPythonicToTs} from './utils/serialization_utils';\nimport {getExactlyOneShape} from './utils/types_utils';\n\n/**\n * Parses a JSON model configuration file and returns a model instance.\n *\n * ```js\n * // This example shows how to serialize a model using `toJSON()` and\n * // deserialize it as another model using `tf.models.modelFromJSON()`.\n * // Note: this example serializes and deserializes only the topology\n * // of the model; the weights of the loaded model will be different\n * // from those of the the original model, due to random weight\n * // initialization.\n * // To load the topology and weights of a model, use `tf.loadLayersModel()`.\n * const model1 = tf.sequential();\n * model1.add(tf.layers.repeatVector({inputShape: [2], n: 4}));\n * // Serialize `model1` as a JSON object.\n * const model1JSON = model1.toJSON(null, false);\n * model1.summary();\n *\n * const model2 = await tf.models.modelFromJSON(model1JSON);\n * model2.summary();\n * ```\n *\n *  @param modelAndWeightsConfig JSON object or string encoding a model and\n *       weights configuration. It can also be only the topology JSON of the\n *       model, in which case the weights will not be loaded.\n *  @param custom_objects Optional dictionary mapping names\n *       (strings) to custom classes or functions to be\n *       considered during deserialization.\n * @returns A TensorFlow.js Layers `tf.LayersModel` instance (uncompiled).\n */\nexport async function modelFromJSON(\n    modelAndWeightsConfig: ModelAndWeightsConfig|PyJsonDict,\n    customObjects?: serialization.ConfigDict): Promise<LayersModel> {\n  if (!('modelTopology' in modelAndWeightsConfig)) {\n    modelAndWeightsConfig = {modelTopology: modelAndWeightsConfig};\n  }\n  modelAndWeightsConfig = modelAndWeightsConfig as ModelAndWeightsConfig;\n\n  let modelTopology = modelAndWeightsConfig.modelTopology;\n  if (modelTopology['model_config'] != null) {\n    // If the model-topology JSON contains a 'model_config' field, then it is\n    // a full model JSON (e.g., from `keras.Model.save()`), which contains\n    // not only the model's architecture in its 'model_config' field, but\n    // additional information such as the model's optimizer. We use only the\n    // 'model_config' field currently.\n    modelTopology = modelTopology['model_config'] as PyJsonDict;\n  }\n  const tsConfig =\n      convertPythonicToTs(modelTopology) as serialization.ConfigDict;\n  const model = deserialize(tsConfig, customObjects) as LayersModel;\n\n  if (modelAndWeightsConfig.weightsManifest != null) {\n    // Load the weight values keyed by the original tensor names in the model\n    // file that was loaded.  These should match the keys of the weight\n    // manifest.\n    const weightValues = await io.loadWeights(\n        modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix,\n        model.weights.map(weight => weight.originalName));\n\n    // Map the weights to the unique tensor names generated during model loading\n    const uniqueWeightValues: NamedTensorMap = {};\n    for (const weight of model.weights) {\n      uniqueWeightValues[weight.originalName] =\n          weightValues[weight.originalName];\n    }\n\n    model.loadWeights(uniqueWeightValues);\n    // Dispose temporary weight values.\n    dispose(weightValues);\n  }\n  return model;\n}\n\n/**\n * Options for loading a saved mode in TensorFlow.js format.\n */\nexport interface ModelAndWeightsConfig {\n  /**\n   * A JSON object or JSON string containing the model config.\n   *\n   * This can be either of the following two formats:\n   *   - A model archiecture-only config,  i.e., a format consistent with the\n   *     return value of`keras.Model.to_json()`.\n   *   - A full model config, containing not only model architecture, but also\n   *     training options and state, i.e., a format consistent with the return\n   *     value of `keras.models.save_model()`.\n   */\n  modelTopology: PyJsonDict;\n\n  /**\n   * A weights manifest in TensorFlow.js format.\n   */\n  weightsManifest?: io.WeightsManifestConfig;\n\n  /**\n   * Path to prepend to the paths in `weightManifest` before fetching.\n   *\n   * The path may optionally end in a slash ('/').\n   */\n  pathPrefix?: string;\n}\n\n// TODO(nielsene): Remove after: https://github.com/tensorflow/tfjs/issues/400\nexport interface ModelPredictArgs {\n  /**\n   * Optional. Batch size (Integer). If unspecified, it will default to 32.\n   */\n  batchSize?: number;\n\n  /**\n   * Optional. Verbosity mode. Defaults to false.\n   */\n  verbose?: boolean;\n}\n\n/**\n * Load a model composed of Layer objects, including its topology and optionally\n * weights. See the Tutorial named \"How to import a Keras Model\" for usage\n * examples.\n *\n * This method is applicable to:\n *\n * 1. Models created with the `tf.layers.*`, `tf.sequential`, and\n * `tf.model` APIs of TensorFlow.js and later saved with the\n * `tf.LayersModel.save` method.\n * 2. Models converted from Keras or TensorFlow tf.keras using the\n * [tensorflowjs_converter](https://github.com/tensorflow/tfjs/tree/master/tfjs-converter).\n *\n * This mode is *not* applicable to TensorFlow `SavedModel`s or their converted\n * forms. For those models, use `tf.loadGraphModel`.\n *\n * Example 1. Load a model from an HTTP server.\n *\n * ```js\n * const model = await tf.loadLayersModel(\n *     'https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');\n * model.summary();\n * ```\n *\n * Example 2: Save `model`'s topology and weights to browser [local\n * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('localstorage://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 3. Saving `model`'s topology and weights to browser\n * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('indexeddb://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 4. Load a model from user-selected files from HTML\n * [file input\n * elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).\n *\n * ```js\n * // Note: this code snippet will not work without the HTML elements in the\n * //   page\n * const jsonUpload = document.getElementById('json-upload');\n * const weightsUpload = document.getElementById('weights-upload');\n *\n * const model = await tf.loadLayersModel(\n *     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));\n * ```\n *\n * @param pathOrIOHandler Can be either of the two formats\n *   1. A string path to the `ModelAndWeightsConfig` JSON describing\n *      the model in the canonical TensorFlow.js format. For file://\n *      (tfjs-node-only), http:// and https:// schemas, the path can be\n *      either absolute or relative. The content of the JSON file is assumed to\n *      be a JSON object with the following fields and values:\n *      - 'modelTopology': A JSON object that can be either of:\n *        1. a model architecture JSON consistent with the format of the return\n *            value of `keras.Model.to_json()`\n *        2. a full model JSON in the format of `keras.models.save_model()`.\n *      - 'weightsManifest': A TensorFlow.js weights manifest.\n *      See the Python converter function `save_model()` for more details.\n *      It is also assumed that model weights can be accessed from relative\n *      paths described by the `paths` fields in weights manifest.\n *   2. A `tf.io.IOHandler` object that loads model artifacts with its `load`\n *      method.\n * @param options Optional configuration arguments for the model loading,\n *   including:\n *   - `strict`: Require that the provided weights exactly match those required\n *     by the layers.  Default true.  Passing false means that both extra\n *     weights and missing weights will be silently ignored.\n *   - `onProgress`: A progress callback of the form:\n *     `(fraction: number) => void`. This callback can be used to monitor the\n *     model-loading process.\n * @returns A `Promise` of `tf.LayersModel`, with the topology and weights\n *     loaded.\n *\n * @doc {heading: 'Models', subheading: 'Loading'}\n */\nexport async function loadLayersModel(\n    pathOrIOHandler: string|io.IOHandler,\n    options?: io.LoadOptions): Promise<LayersModel> {\n  if (options == null) {\n    options = {};\n  }\n  if (typeof pathOrIOHandler === 'string') {\n    const handlers = io.getLoadHandlers(pathOrIOHandler, options);\n    if (handlers.length === 0) {\n      // For backward compatibility: if no load handler can be found,\n      // assume it is a relative http path.\n      // TODO(cais): Reformat the args into a single `LoadOptions` once the core\n      // is refactored.\n      handlers.push(io.browserHTTPRequest(pathOrIOHandler, options));\n    } else if (handlers.length > 1) {\n      throw new ValueError(\n          `Found more than one (${handlers.length}) load handlers for ` +\n          `URL '${pathOrIOHandler}'`);\n    }\n    pathOrIOHandler = handlers[0];\n  }\n  return loadLayersModelFromIOHandler(pathOrIOHandler, undefined, options);\n}\n\n/**\n * Load a model and optionally its weights, using an IOHandler object.\n *\n * @param handler The instance of `IOHandler` to be used during the model\n *   loading.\n * @param customObjects Any optional custom objects to be used during model\n *   loading.\n * @param strict Whether the weight loading will be done in strict mode.\n *   Default: `true`.\n */\nexport async function loadLayersModelFromIOHandler(\n    handler: io.IOHandler, customObjects?: serialization.ConfigDict,\n    options?: io.LoadOptions): Promise<LayersModel> {\n  if (options == null) {\n    options = {};\n  }\n  if (handler.load == null) {\n    throw new ValueError(\n        'Cannot proceed with model loading because the IOHandler provided ' +\n        'does not have the `load` method implemented.');\n  }\n  const artifacts = await handler.load();\n  let modelTopology = artifacts.modelTopology as PyJsonDict;\n  if (modelTopology['model_config'] != null) {\n    modelTopology = modelTopology['model_config'] as PyJsonDict;\n  }\n\n  const strict = options.strict == null ? true : options.strict;\n  // If weights are provided and the weight-loading mode is strict, use\n  // fast weight initialization. This skips costly initializers such as\n  // 'orthogonal' and saves unnecessary computation in cases where\n  // the initialized weight values will immediately be overwritten by\n  // loaded weight values.\n  const fastWeightInit =\n      artifacts.weightData != null && artifacts.weightSpecs != null && strict;\n  const model =\n      deserialize(\n          convertPythonicToTs(modelTopology) as serialization.ConfigDict,\n          customObjects, fastWeightInit) as LayersModel;\n\n  const trainingConfig = artifacts.trainingConfig as TrainingConfig;\n  if (trainingConfig != null) {\n    model.loadTrainingConfig(trainingConfig);\n  }\n  if (artifacts.userDefinedMetadata != null) {\n    model.setUserDefinedMetadata(artifacts.userDefinedMetadata);\n  }\n\n  // If weightData is present, load the weights into the model.\n  if (artifacts.weightData != null) {\n    // Loading weights requires weightSpecs.\n    if (artifacts.weightSpecs == null) {\n      throw new ValueError(\n          'LayersModel artifacts contains weight data, but not weight specs. ' +\n          'Therefore loading of weights cannot proceed.');\n    }\n\n    const {modelWeights, optimizerWeights} = decodeModelAndOptimizerWeights(\n        artifacts.weightData, artifacts.weightSpecs);\n    model.loadWeights(modelWeights, strict);\n\n    if (model.optimizer != null && optimizerWeights.length > 0) {\n      await model.optimizer.setWeights(optimizerWeights);\n    }\n\n    // Dispose temporary weight values.\n    dispose(modelWeights);\n    dispose(optimizerWeights.map(w => w.tensor));\n  }\n  return model;\n}\n\nfunction decodeModelAndOptimizerWeights(\n    buffer: ArrayBuffer, specs: io.WeightsManifestEntry[]):\n    {modelWeights: NamedTensorMap, optimizerWeights: NamedTensor[]} {\n  const name2Tensor = io.decodeWeights(buffer, specs);\n  const modelWeights: NamedTensorMap = {};\n  const optimizerWeights: NamedTensor[] = [];\n  specs.forEach(spec => {\n    if (spec.group === 'optimizer') {\n      optimizerWeights.push({name: spec.name, tensor: name2Tensor[spec.name]});\n    } else {\n      modelWeights[spec.name] = name2Tensor[spec.name];\n    }\n  });\n  return {modelWeights, optimizerWeights};\n}\n\n/**\n * Configuration for a Sequential model.\n */\nexport interface SequentialArgs {\n  /** Stack of layers for the model. */\n  layers?: Layer[];\n\n  /** The name of this model. */\n  name?: string;\n}\n\n/**\n * A model with a stack of layers, feeding linearly from one to the next.\n *\n * `tf.sequential` is a factory function that creates an instance of\n * `tf.Sequential`.\n *\n * ```js\n *  // Define a model for linear regression.\n *  const model = tf.sequential();\n *  model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n *\n *  // Prepare the model for training: Specify the loss and the optimizer.\n *  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *  // Generate some synthetic data for training.\n *  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);\n *  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);\n *\n *  // Train the model using the data then do inference on a data point the\n *  // model hasn't seen:\n *  await model.fit(xs, ys);\n *  model.predict(tf.tensor2d([5], [1, 1])).print();\n * ```\n *\n * @doc {heading: 'Models', subheading: 'Classes'}\n */\nexport class Sequential extends LayersModel {\n  /** @nocollapse */\n  static override className = 'Sequential';\n  private model: LayersModel;\n  constructor(args?: SequentialArgs) {\n    super({inputs: [], outputs: []});\n    args = args || {};\n\n    this.trainable = true;\n    this.built = false;\n\n    // Set model name.\n    this.name = (args.name != null) ? args.name : getUid('sequential_');\n\n    // Add to the model any layers passed to the constructor.\n    if (args.layers != null) {\n      for (const layer of args.layers) {\n        this.add(layer);\n      }\n    }\n  }\n\n  // Helper function to Sequential.add  Throws if the new output shape will be\n  // invalid.\n  private checkShape(layer: Layer) {\n    const shape = layer.inboundNodes[0].outputTensors[0].shape;\n    if (shape.some(x => x < 0)) {\n      throw new ValueError(\n          'Negative dimension size caused by adding layer ' +\n          `${layer.name} with input shape [` +\n          `${layer.inboundNodes[0].inputTensors[0].shape}]`);\n    }\n  }\n\n  /**\n   * Adds a layer instance on top of the layer stack.\n   *\n   * ```js\n   *  const model = tf.sequential();\n   *  model.add(tf.layers.dense({units: 8, inputShape: [1]}));\n   *  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));\n   *  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));\n   *  // Note that the untrained model is random at this point.\n   *  model.predict(tf.randomNormal([10, 1])).print();\n   * ```\n   * @param layer Layer instance.\n   *\n   * @exception ValueError In case the `layer` argument does not know its\n   * input shape.\n   * @exception ValueError In case the `layer` argument has multiple output\n   *   tensors, or is already connected somewhere else (forbidden in\n   *   `Sequential` models).\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  add(layer: Layer): void {\n    const isLayerModelInstance =\n        layer instanceof Sequential || layer instanceof LayersModel;\n    let modelLayer: LayersModel;\n    if (isLayerModelInstance) {\n      modelLayer = layer as LayersModel;\n      if (modelLayer.outputs.length !== 1) {\n        throw new ValueError(\n            'All layers in a Sequential model ' +\n            'should have a single output tensor. ' +\n            'For multi-output layers, ' +\n            'use the functional API.');\n      }\n      if (modelLayer.inputs.length !== 1) {\n        throw new ValueError(\n            'All layers in a Sequential model ' +\n            'should have a single input tensor. ' +\n            'For multi-input layers, ' +\n            'use the functional API.');\n      }\n    }\n\n    if (this.outputs.length === 0) {\n      // first layer in model: check that it is an input layer\n      if (layer.inboundNodes.length === 0) {\n        // create an input layer\n        if (layer.batchInputShape == null) {\n          throw new ValueError(\n              'The first layer in a Sequential model must ' +\n              'get an `inputShape` or `batchInputShape` argument.');\n        }\n        // Instantiate the input layer.\n        const x = Input({\n          batchShape: layer.batchInputShape,\n          dtype: layer.dtype,\n          name: layer.name + '_input'\n        });\n        // This will build the current layer and create the node connecting\n        // the current layer to the input layer we just created.\n        layer.apply(x);\n      }\n\n      if (isLayerModelInstance) {\n        this.outputs = modelLayer.outputs;\n        this.inputs = modelLayer.inputs;\n      } else {\n        if (layer.inboundNodes.length !== 1) {\n          throw new ValueError(\n              'A layer added to a Sequential model must not already be ' +\n              `connected somewhere else. LayersModel received layer ${\n                  layer.name} ` +\n              `which has ${layer.inboundNodes.length} pre-existing inbound ` +\n              'connections.');\n        }\n\n        if (layer.inboundNodes[0].outputTensors.length !== 1) {\n          throw new ValueError(\n              'All layers in a Sequential model ' +\n              'should have a single output tensor. ' +\n              'For multi-output layers, ' +\n              'use the functional API.');\n        }\n        this.checkShape(layer);\n        this.outputs = [layer.inboundNodes[0].outputTensors[0]];\n        this.inputs = getSourceInputs(this.outputs[0]);\n      }\n\n      this.inboundNodes = [];\n      // We create an input node, which we will keep updated\n      // as we add more layers.\n      // (This call has side effects.)\n      // tslint:disable-next-line:no-unused-expression\n      new Node({\n        outboundLayer: this,\n        inboundLayers: [],\n        nodeIndices: [],\n        tensorIndices: [],\n        inputTensors: this.inputs,\n        outputTensors: this.outputs,\n        // no model-level masking for now\n        inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),\n        outputMasks: [null],\n        inputShapes: this.inputs.map(x => x.shape),\n        outputShapes: this.outputs[0].shape\n      });\n    } else {\n      const outputTensor = layer.apply(this.outputs[0]);\n      if (Array.isArray(outputTensor)) {\n        throw new TypeError(\n            'All layers in a Sequential model ' +\n            'should have a single output tensor. ' +\n            'For multi-output layers, ' +\n            'use the functional API.');\n      }\n      this.checkShape(layer);\n      this.outputs = [outputTensor as SymbolicTensor];\n      // update self.inbound_nodes\n      this.inboundNodes[0].outputTensors = this.outputs;\n      this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n    }\n\n    this.layers.push(layer);\n    this.built = false;\n  }\n\n  /**\n   * Removes the last layer in the model.\n   *\n   * @exception TypeError if there are no layers in the model.\n   */\n  pop(): void {\n    if (this.layers.length === 0) {\n      throw new TypeError('There are no layers in the model.');\n    }\n\n    this.layers.pop();\n    if (this.layers.length === 0) {\n      this.outputs = [];\n      this.inboundNodes = [];\n      this.outboundNodes = [];\n    } else {\n      const lastLayerIndex = this.layers.length - 1;\n      this.layers[lastLayerIndex].outboundNodes = [];\n      this.outputs = [this.layers[lastLayerIndex].output as SymbolicTensor];\n      // update self.inbound_nodes\n      this.inboundNodes[0].outputTensors = this.outputs;\n      this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n    }\n  }\n\n  override call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    if (this.model == null) {\n      this.build();\n    }\n    return this.model.call(inputs, kwargs);\n  }\n\n  override build(inputShape?: Shape|Shape[]) {\n    // Call `getExactlyOneShape` without using its return value,\n    // to verify that exactly one input shape is provided.\n    getExactlyOneShape(inputShape);\n\n    if (this.inputs.length === 0 || this.outputs.length === 0) {\n      throw new TypeError(\n          'Sequential model cannot be built: model is empty.' +\n          ' Add some layers first.');\n    }\n    // actually create the model\n    this.model = new LayersModel({\n      inputs: this.inputs,\n      outputs: this.outputs[0],\n      name: this.name + '_model'\n    });\n    this.model.trainable = this.trainable;\n\n    // mirror model attributes\n    this.supportsMasking = this.model.supportsMasking;\n    // TODO(michaelterry): Add caches\n    this.inputLayers = this.model.inputLayers;\n    this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;\n    this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;\n    this.outputLayers = this.model.outputLayers;\n    this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;\n    this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;\n    this.nodesByDepth = this.model.nodesByDepth;\n    this.containerNodes = this.model.containerNodes;\n    this.outputNames = this.model.outputNames;\n    this.inputNames = this.model.inputNames;\n    // TODO(michaelterry): Add feedInputNames, feedInputs, if needed.\n    // TODO(michaelterry): Add callbackModel if needed.\n    this.built = true;\n  }\n\n  override countParams(): number {\n    if (!this.built) {\n      this.build();\n    }\n    return super.countParams();\n  }\n\n  /**\n   * Print a text summary of the Sequential model's layers.\n   *\n   * The summary includes\n   * - Name and type of all layers that comprise the model.\n   * - Output shape(s) of the layers\n   * - Number of weight parameters of each layer\n   * - The total number of trainable and non-trainable parameters of the\n   * model.\n   *\n   * ```js\n   * const model = tf.sequential();\n   * model.add(\n   *     tf.layers.dense({units: 100, inputShape: [10], activation: 'relu'}));\n   * model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));\n   *\n   * model.summary();\n   * ```\n   *\n   * @param lineLength Custom line length, in number of characters.\n   * @param positions Custom widths of each of the columns, as either\n   *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\n   *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to\n   *   right-most (i.e., ending) position of a column.\n   * @param printFn Custom print function. Can be used to replace the default\n   *   `console.log`. For example, you can use `x => {}` to mute the printed\n   *   messages in the console.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  override summary(\n      lineLength?: number, positions?: number[],\n      printFn:\n          // tslint:disable-next-line:no-any\n      (message?: any, ...optionalParams: any[]) => void = console.log) {\n    if (!this.built) {\n      this.build();\n    }\n    super.summary(lineLength, positions, printFn);\n  }\n\n  /**\n   * Sets the weights of the model.\n   *\n   * @param weights Should be a list of Tensors with shapes and types matching\n   *   the output of `model.getWeights()`.\n   */\n  override setWeights(weights: Tensor[]): void {\n    if (this.model == null) {\n      this.build();\n    }\n    this.model.setWeights(weights);\n  }\n\n  /**\n   * Returns the loss value & metrics values for the model in test mode.\n   *\n   * Loss and metrics are specified during `compile()`, which needs to happen\n   * before calls to `evaluate()`.\n   *\n   * Computation is done in batches.\n   *\n   * ```js\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n   * });\n   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n   * const result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {\n   *   batchSize: 4,\n   * });\n   * result.print();\n   * ```\n   *\n   * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the\n   * model has multiple inputs.\n   * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the\n   * model has multiple outputs.\n   * @param args A `ModelEvaluateConfig`, containing optional fields.\n   *\n   * @return `Scalar` test loss (if the model has a single output and no\n   *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs\n   *   and/or metrics). The attribute `model.metricsNames`\n   *   will give you the display labels for the scalar outputs.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  override evaluate(\n      x: Tensor|Tensor[], y: Tensor|Tensor[],\n      args: ModelEvaluateArgs = {}): Scalar|Scalar[] {\n    if (!this.built) {\n      throw new RuntimeError(\n          'The model needs to be compiled before being used.');\n    }\n    return this.model.evaluate(x, y, args);\n  }\n\n  // TODO(cais): Add code snippet below once real dataset objects are\n  //   available.\n  /**\n   * Evaluate model using a dataset object.\n   *\n   * Note: Unlike `evaluate()`, this method is asynchronous (`async`).\n   *\n   * @param dataset A dataset object. Its `iterator()` method is expected\n   *   to generate a dataset iterator object, the `next()` method of which\n   *   is expected to produce data batches for evaluation. The return value\n   *   of the `next()` call ought to contain a boolean `done` field and a\n   *   `value` field. The `value` field is expected to be an array of two\n   *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\n   *   case is for models with exactly one input and one output (e.g.\n   *   a sequential model). The latter case is for models with multiple\n   *   inputs and/or multiple outputs. Of the two items in the array, the\n   *   first is the input feature(s) and the second is the output target(s).\n   * @param args A configuration object for the dataset-based evaluation.\n   * @returns Loss and metric values as an Array of `Scalar` objects.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  override async evaluateDataset(dataset: Dataset<{}>,\n      args: ModelEvaluateDatasetArgs): Promise<Scalar|Scalar[]> {\n    if (!this.built) {\n      throw new RuntimeError(\n          'The model needs to be compiled before being used.');\n    }\n    return this.model.evaluateDataset(dataset, args);\n  }\n\n  /**\n   * Generates output predictions for the input samples.\n   *\n   * Computation is done in batches.\n   *\n   * Note: the \"step\" mode of predict() is currently not supported.\n   *   This is because the TensorFlow.js core backend is imperative only.\n   *\n   * ```js\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n   * });\n   * model.predict(tf.ones([2, 10])).print();\n   * ```\n   *\n   * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if\n   *   the model has multiple inputs.\n   * @param conifg A `ModelPredictConfig` object containing optional fields.\n   *\n   * @return `tf.Tensor`(s) of predictions.\n   *\n   * @exception ValueError In case of mismatch between the provided input data\n   *   and the model's expectations, or in case a stateful model receives a\n   *   number of samples that is not a multiple of the batch size.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  override predict(x: Tensor|Tensor[], args: ModelPredictArgs = {}):\n      Tensor|Tensor[] {\n    if (this.model == null) {\n      this.build();\n    }\n    return this.model.predict(x, args);\n  }\n\n  /**\n   * Returns predictions for a single batch of samples.\n   *\n   * @param x: Input samples, as a Tensor, or list of Tensors (if the model\n   *   has multiple inputs).\n   * @return Tensor(s) of predictions\n   */\n  override predictOnBatch(x: Tensor): Tensor|Tensor[] {\n    if (this.model == null) {\n      this.build();\n    }\n    return this.model.predictOnBatch(x);\n  }\n\n  /**\n   * See `LayersModel.compile`.\n   *\n   * @param args\n   */\n  override compile(args: ModelCompileArgs): void {\n    this.build();\n    this.model.compile(args);\n    this.optimizer_ = this.model.optimizer;\n    // tslint:disable-next-line:no-any\n    this.isOptimizerOwned = (this.model as any).isOptimizerOwned;\n    this.loss = this.model.loss;\n    this.metrics = this.model.metrics;\n    // TODO(cais): Add this.lossWeights, this.sampleWeightMode,\n    //   this.weightedMetrics, this.targets.\n    this.metricsTensors = this.model.metricsTensors;\n    this.metricsNames = this.model.metricsNames;\n    // TODO(cais): Add sampleWeights.\n  }\n\n  override get optimizer(): Optimizer {\n    return this.model == null ? undefined : this.model.optimizer;\n  }\n\n  override set optimizer(optimizer: Optimizer) {\n    this.model.optimizer = optimizer;\n  }\n\n  /**\n   * Trains the model for a fixed number of epochs (iterations on a dataset).\n   *\n   * ```js\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n   * });\n   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n   * const history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n   *   batchSize: 4,\n   *   epochs: 3\n   * });\n   * console.log(history.history.loss[0]);\n   * ```\n   *\n   * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the\n   * model has multiple inputs. If all inputs in the model are named, you can\n   * also pass a dictionary mapping input names to `tf.Tensor`s.\n   * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if\n   * the model has multiple outputs. If all outputs in the model are named, you\n   *  can also pass a dictionary mapping output names to `tf.Tensor`s.\n   * @param args  A `ModelFitConfig`, containing optional fields.\n   *\n   * @return A `History` instance. Its `history` attribute contains all\n   *   information collected during training.\n   *\n   * @exception ValueError In case of mismatch between the provided input data\n   *   and what the model expects.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  override async fit(\n      x: Tensor|Tensor[]|{[inputName: string]: Tensor},\n      y: Tensor|Tensor[]|{[inputName: string]: Tensor},\n      args: ModelFitArgs = {}): Promise<History> {\n    if (!this.built) {\n      throw new RuntimeError(\n          'The model needs to be compiled before ' +\n          'being used.');\n    }\n    return this.model.fit(x, y, args);\n  }\n\n  /**\n   * Trains the model using a dataset object.\n   *\n   * ```js\n   * const xArray = [\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n   * ];\n   * const yArray = [1, 1, 1, 1];\n   * // Create a dataset from the JavaScript array.\n   * const xDataset = tf.data.array(xArray);\n   * const yDataset = tf.data.array(yArray);\n   * // Zip combines the `x` and `y` Datasets into a single Dataset, the\n   * // iterator of which will return an object containing of two tensors,\n   * // corresponding to `x` and `y`.  The call to `batch(4)` will bundle\n   * // four such samples into a single object, with the same keys now pointing\n   * // to tensors that hold 4 examples, organized along the batch dimension.\n   * // The call to `shuffle(4)` causes each iteration through the dataset to\n   * // happen in a different order.  The size of the shuffle window is 4.\n   * const xyDataset = tf.data.zip({xs: xDataset, ys: yDataset})\n   *     .batch(4)\n   *     .shuffle(4);\n   * const model = tf.sequential({\n   *   layers: [tf.layers.dense({units: 1, inputShape: [9]})]\n   * });\n   * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n   * const history = await model.fitDataset(xyDataset, {\n   *   epochs: 4,\n   *   callbacks: {onEpochEnd: (epoch, logs) => console.log(logs.loss)}\n   * });\n   * ```\n   *\n   * @param dataset A dataset object. Its `iterator()` method is expected to\n   *   generate a dataset iterator object, the `next()` method of which is\n   *   expected to produce data batches for evaluation. The return value of the\n   *   `next()` call ought to contain a boolean `done` field and a `value`\n   *   field.\n   *\n   *   The `value` field is expected to be an object of with fields\n   *   `xs` and `ys`, which point to the feature tensor and the target tensor,\n   *   respectively. This case is for models with exactly one input and one\n   *   output (e.g. a sequential model). For example:\n   *   ```js\n   *   {value: {xs: xsTensor, ys: ysTensor}, done: false}\n   *   ```\n   *\n   *   If the model has multiple inputs, the `xs` field of `value` should\n   *   be an object mapping input names to their respective feature tensors.\n   *   For example:\n   *   ```js\n   *   {\n   *     value: {\n   *       xs: {\n   *         input_1: xsTensor1,\n   *         input_2: xsTensor2\n   *       },\n   *       ys: ysTensor\n   *     },\n   *     done: false\n   *   }\n   *   ```\n   *   If the model has multiple outputs, the `ys` field of `value` should\n   *   be an object mapping output names to their respective target tensors.\n   *   For example:\n   *   ```js\n   *   {\n   *     value: {\n   *       xs: xsTensor,\n   *       ys: {\n   *         output_1: ysTensor1,\n   *         output_2: ysTensor2\n   *       },\n   *     },\n   *     done: false\n   *   }\n   *   ```\n   * @param args A `ModelFitDatasetArgs`, containing optional fields.\n   *\n   * @return A `History` instance. Its `history` attribute contains all\n   *   information collected during training.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n   */\n  override async fitDataset<T>(dataset: Dataset<T>,\n      args: ModelFitDatasetArgs<T>): Promise<History> {\n    if (!this.built) {\n      throw new RuntimeError(\n          'The model needs to be compiled before ' +\n          'being used.');\n    }\n    return this.model.fitDataset(dataset, args);\n  }\n\n  /**\n   * Runs a single gradient update on a single batch of data.\n   *\n   * This method differs from `fit()` and `fitDataset()` in the following\n   * regards:\n   *   - It operates on exactly one batch of data.\n   *   - It returns only the loss and metric values, instead of\n   *     returning the batch-by-batch loss and metric values.\n   *   - It doesn't support fine-grained options such as verbosity and\n   *     callbacks.\n   *\n   * @param x Input data. It could be one of the following:\n   *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has\n   *     multiple inputs).\n   *   - An Object mapping input names to corresponding `tf.Tensor` (if the\n   *     model has named inputs).\n   * @param y Target data. It could be either a `tf.Tensor` or multiple\n   *   `tf.Tensor`s. It should be consistent with `x`.\n   * @returns Training loss or losses (in case the model has\n   *   multiple outputs), along with metrics (if any), as numbers.\n   *\n   * @doc {heading: 'Models', subheading: 'Classes'}\n   */\n  override async trainOnBatch(\n      x: Tensor|Tensor[]|{[inputName: string]: Tensor},\n      y: Tensor|Tensor[]|\n      {[inputName: string]: Tensor}): Promise<number|number[]> {\n    return this.model.trainOnBatch(x, y);\n  }\n\n  /* See parent class for JsDoc */\n  /** @nocollapse */\n  static override fromConfig<T extends serialization.Serializable>(\n      cls: serialization.SerializableConstructor<T>,\n      config: serialization.ConfigDict,\n      customObjects = {} as serialization.ConfigDict,\n      fastWeightInit = false): T {\n    let configArray: serialization.ConfigDictArray;\n    let extraModelConfig: serialization.ConfigDict = {};\n    if (config instanceof Array) {\n      if (!(config[0].className != null) ||\n          config[0]['className'] === 'Merge') {\n        throw new ValueError('Legacy serialization format not supported yet.');\n      }\n      configArray = config;\n    } else {\n      util.assert(\n          config['layers'] != null,\n          () =>\n              `When the config data for a Sequential model is not an Array, ` +\n              `it must be an Object that contains the 'layers' field.`);\n      configArray = config['layers'] as serialization.ConfigDictArray;\n      delete config['layers'];\n      extraModelConfig = config;\n    }\n\n    const model = new cls(extraModelConfig);\n    if (!(model instanceof Sequential)) {\n      throw new NotImplementedError(\n          `Sequential.fromConfig called on non-Sequential input: ${model}`);\n    }\n    for (const conf of configArray) {\n      const customObjects: serialization.ConfigDict = undefined;\n      const layer = deserialize(\n                        conf as serialization.ConfigDict, customObjects,\n                        fastWeightInit) as Layer;\n      if (fastWeightInit) {\n        layer.setFastWeightInitDuringBuild(true);\n      }\n      model.add(layer);\n    }\n    return model;\n  }\n\n  /**\n   * Setter used for force stopping of LayersModel.fit() (i.e., training).\n   *\n   * Example:\n   *\n   * ```js\n   * const model = tf.sequential();\n   * model.add(tf.layers.dense({units: 1, inputShape: [10]}));\n   * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n   * const xs = tf.ones([8, 10]);\n   * const ys = tf.zeros([8, 1]);\n   *\n   * const history = await model.fit(xs, ys, {\n   *   epochs: 10,\n   *   callbacks: {\n   *     onEpochEnd: async (epoch, logs) => {\n   *       if (epoch === 2) {\n   *         model.stopTraining = true;\n   *       }\n   *     }\n   *   }\n   * });\n   *\n   * // There should be only 3 values in the loss array, instead of 10 values,\n   * // due to the stopping after 3 epochs.\n   * console.log(history.history.loss);\n   * ```\n   */\n  override set stopTraining(stop: boolean) {\n    // TODO(cais): When refactoring to remove the composition pattern happens,\n    // remove this method overriding.\n    if (this.model == null) {\n      throw new ValueError(\n          'Cannot set the stopTraining property of a sequential model before ' +\n          'it is compiled.');\n    }\n    this.model.stopTraining = stop;\n  }\n\n  override get stopTraining(): boolean {\n    if (this.model == null) {\n      throw new ValueError(\n          'Cannot get the stopTraining property of a sequential model before ' +\n          'it is compiled.');\n    }\n    return this.model.stopTraining;\n  }\n\n  // TODO(cais): Override get trainableWeights() here\n\n  // tslint:disable-next-line:no-any\n  override getConfig(): any {\n    // NOTE(cais): We override the return type of getConfig() to `any` here,\n    //   because the `Sequential` class is a special case among `Container`\n    //   subtypes in that its getConfig() method returns an Array (not a\n    //   dict).\n    const layers: serialization.ConfigDict[] = [];\n    for (const layer of this.layers) {\n      const dict: serialization.ConfigDict = {};\n      dict['className'] = layer.getClassName();\n      dict['config'] = layer.getConfig();\n      layers.push(dict);\n    }\n    return {name: this.name, layers};\n  }\n}\nserialization.registerClass(Sequential);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}