{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tidy, util } from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport var executeOp = function executeOp(node, tensorMap, context) {\n  var ops = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : tfOps;\n  switch (node.op) {\n    case 'ConcatV2':\n    case 'Concat':\n      {\n        var n = getParamValue('n', node, tensorMap, context);\n        var axis = getParamValue('axis', node, tensorMap, context);\n        var inputs = getParamValue('tensors', node, tensorMap, context);\n        inputs = inputs.slice(0, n);\n        return [ops.concat(inputs, axis)];\n      }\n    case 'Gather':\n      {\n        var input = getParamValue('x', node, tensorMap, context);\n        var indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n      }\n    case 'GatherV2':\n      {\n        var _axis = getParamValue('axis', node, tensorMap, context);\n        var batchDims = getParamValue('batchDims', node, tensorMap, context);\n        var _input = getParamValue('x', node, tensorMap, context);\n        var _indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(_input, ops.cast(_indices, 'int32'), _axis, batchDims)];\n      }\n    case 'Reverse':\n      {\n        var dims = getParamValue('dims', node, tensorMap, context);\n        var _axis2 = [];\n        for (var i = 0; i < dims.length; i++) {\n          if (dims[i]) {\n            _axis2.push(i);\n          }\n        }\n        var _input2 = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(_input2, _axis2)];\n      }\n    case 'ReverseV2':\n      {\n        var _axis3 = getParamValue('axis', node, tensorMap, context);\n        var _input3 = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(_input3, _axis3)];\n      }\n    case 'Slice':\n      {\n        // tslint:disable-next-line:no-any\n        var begin = getParamValue('begin', node, tensorMap, context);\n        // tslint:disable-next-line:no-any\n        var size = getParamValue('size', node, tensorMap, context);\n        return [ops.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n      }\n    case 'StridedSlice':\n      {\n        var _begin = getParamValue('begin', node, tensorMap, context);\n        var end = getParamValue('end', node, tensorMap, context);\n        var strides = getParamValue('strides', node, tensorMap, context);\n        var beginMask = getParamValue('beginMask', node, tensorMap, context);\n        var endMask = getParamValue('endMask', node, tensorMap, context);\n        var ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n        var newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n        var shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n        var tensor = getParamValue('x', node, tensorMap, context);\n        return [ops.stridedSlice(tensor, _begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n      }\n    case 'Pack':\n      {\n        return tidy(function () {\n          var axis = getParamValue('axis', node, tensorMap, context);\n          var tensors = getParamValue('tensors', node, tensorMap, context);\n          // Reshape the tensors to the first tensor's shape if they don't\n          // match.\n          var shape = tensors[0].shape;\n          var squeezedShape = ops.squeeze(tensors[0]).shape;\n          var mapped = tensors.map(function (tensor) {\n            var sameShape = util.arraysEqual(tensor.shape, shape);\n            if (!sameShape && !util.arraysEqual(ops.squeeze(tensor).shape, squeezedShape)) {\n              throw new Error('the input tensors shape does not match');\n            }\n            return sameShape ? tensor : ops.reshape(tensor, shape);\n          });\n          return [ops.stack(mapped, axis)];\n        });\n      }\n    case 'Unpack':\n      {\n        var _axis4 = getParamValue('axis', node, tensorMap, context);\n        var _tensor = getParamValue('tensor', node, tensorMap, context);\n        return ops.unstack(_tensor, _axis4);\n      }\n    case 'Tile':\n      {\n        var reps = getParamValue('reps', node, tensorMap, context);\n        return [ops.tile(getParamValue('x', node, tensorMap, context), reps)];\n      }\n    case 'Split':\n    case 'SplitV':\n      {\n        var _axis5 = getParamValue('axis', node, tensorMap, context);\n        var numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n        var _tensor2 = getParamValue('x', node, tensorMap, context);\n        return ops.split(_tensor2, numOrSizeSplits, _axis5);\n      }\n    case 'ScatterNd':\n      {\n        var _indices2 = getParamValue('indices', node, tensorMap, context);\n        var values = getParamValue('values', node, tensorMap, context);\n        var shape = getParamValue('shape', node, tensorMap, context);\n        return [ops.scatterND(_indices2, values, shape)];\n      }\n    case 'GatherNd':\n      {\n        var x = getParamValue('x', node, tensorMap, context);\n        var _indices3 = getParamValue('indices', node, tensorMap, context);\n        return [ops.gatherND(x, _indices3)];\n      }\n    case 'SparseToDense':\n      {\n        var _indices4 = getParamValue('sparseIndices', node, tensorMap, context);\n        var _shape = getParamValue('outputShape', node, tensorMap, context);\n        var sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n        var defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n        return [ops.sparseToDense(_indices4, sparseValues, _shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : ops.cast(defaultValue, sparseValues.dtype))];\n      }\n    default:\n      throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n  }\n};\nexport var CATEGORY = 'slice_join';","map":{"version":3,"mappings":"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","names":["tidy","util","tfOps","getParamValue","executeOp","node","tensorMap","context","ops","op","n","axis","inputs","slice","concat","input","indices","gather","cast","batchDims","dims","i","length","push","reverse","begin","size","end","strides","beginMask","endMask","ellipsisMask","newAxisMask","shrinkAxisMask","tensor","stridedSlice","tensors","shape","squeezedShape","squeeze","mapped","map","sameShape","arraysEqual","Error","reshape","stack","unstack","reps","tile","numOrSizeSplits","split","values","scatterND","x","gatherND","sparseValues","defaultValue","sparseToDense","dtype","TypeError","CATEGORY"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-converter\\src\\operations\\executors\\slice_join_executor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar, Tensor, Tensor1D, tidy, util} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {getParamValue} from './utils';\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap,\n     context: ExecutionContext, ops = tfOps): Tensor[] => {\n      switch (node.op) {\n        case 'ConcatV2':\n        case 'Concat': {\n          const n = getParamValue('n', node, tensorMap, context) as number;\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          let inputs =\n              getParamValue('tensors', node, tensorMap, context) as Tensor[];\n          inputs = inputs.slice(0, n);\n          return [ops.concat(inputs, axis)];\n        }\n        case 'Gather': {\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor1D;\n          return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n        }\n        case 'GatherV2': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const batchDims =\n              getParamValue('batchDims', node, tensorMap, context) as number;\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor1D;\n          return [ops.gather(\n              input, ops.cast(indices, 'int32'), axis, batchDims)];\n        }\n        case 'Reverse': {\n          const dims =\n              getParamValue('dims', node, tensorMap, context) as boolean[];\n          const axis = [];\n          for (let i = 0; i < dims.length; i++) {\n            if (dims[i]) {\n              axis.push(i);\n            }\n          }\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [ops.reverse(input, axis)];\n        }\n        case 'ReverseV2': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number[];\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [ops.reverse(input, axis)];\n        }\n        case 'Slice': {\n          // tslint:disable-next-line:no-any\n          const begin = getParamValue('begin', node, tensorMap, context) as any;\n          // tslint:disable-next-line:no-any\n          const size = getParamValue('size', node, tensorMap, context) as any;\n          return [ops.slice(\n              getParamValue('x', node, tensorMap, context) as Tensor, begin,\n              size)];\n        }\n        case 'StridedSlice': {\n          const begin =\n              getParamValue('begin', node, tensorMap, context) as number[];\n          const end =\n              getParamValue('end', node, tensorMap, context) as number[];\n          const strides =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const beginMask =\n              getParamValue('beginMask', node, tensorMap, context) as number;\n          const endMask =\n              getParamValue('endMask', node, tensorMap, context) as number;\n          const ellipsisMask =\n              getParamValue('ellipsisMask', node, tensorMap, context) as number;\n          const newAxisMask =\n              getParamValue('newAxisMask', node, tensorMap, context) as number;\n          const shrinkAxisMask =\n              getParamValue('shrinkAxisMask', node, tensorMap, context) as\n              number;\n          const tensor = getParamValue('x', node, tensorMap, context) as Tensor;\n\n          return [ops.stridedSlice(\n              tensor, begin, end, strides, beginMask, endMask, ellipsisMask,\n              newAxisMask, shrinkAxisMask)];\n        }\n        case 'Pack': {\n          return tidy(() => {\n            const axis =\n                getParamValue('axis', node, tensorMap, context) as number;\n            const tensors =\n                getParamValue('tensors', node, tensorMap, context) as Tensor[];\n            // Reshape the tensors to the first tensor's shape if they don't\n            // match.\n            const shape = tensors[0].shape;\n            const squeezedShape = ops.squeeze(tensors[0]).shape;\n            const mapped = tensors.map(tensor => {\n              const sameShape = util.arraysEqual(tensor.shape, shape);\n              if (!sameShape &&\n                  !util.arraysEqual(\n                      ops.squeeze(tensor).shape, squeezedShape)) {\n                throw new Error('the input tensors shape does not match');\n              }\n              return sameShape ? tensor : ops.reshape(tensor, shape);\n            });\n            return [ops.stack(mapped, axis)];\n          });\n        }\n        case 'Unpack': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const tensor =\n              getParamValue('tensor', node, tensorMap, context) as Tensor;\n          return ops.unstack(tensor, axis);\n        }\n        case 'Tile': {\n          const reps =\n              getParamValue('reps', node, tensorMap, context) as number[];\n          return [ops.tile(\n              getParamValue('x', node, tensorMap, context) as Tensor, reps)];\n        }\n        case 'Split':\n        case 'SplitV': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const numOrSizeSplits =\n              getParamValue('numOrSizeSplits', node, tensorMap, context) as\n                  number |\n              number[];\n          const tensor = getParamValue('x', node, tensorMap, context) as Tensor;\n\n          return ops.split(tensor, numOrSizeSplits, axis);\n        }\n        case 'ScatterNd': {\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          const values =\n              getParamValue('values', node, tensorMap, context) as Tensor;\n          const shape =\n              getParamValue('shape', node, tensorMap, context) as number[];\n          return [ops.scatterND(indices, values, shape)];\n        }\n        case 'GatherNd': {\n          const x = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          return [ops.gatherND(x, indices)];\n        }\n        case 'SparseToDense': {\n          const indices =\n              getParamValue('sparseIndices', node, tensorMap, context) as\n              Tensor;\n          const shape =\n              getParamValue('outputShape', node, tensorMap, context) as\n              number[];\n          const sparseValues =\n              getParamValue('sparseValues', node, tensorMap, context) as Tensor;\n          const defaultValue =\n              getParamValue('defaultValue', node, tensorMap, context) as Scalar;\n          return [ops.sparseToDense(\n              indices, sparseValues, shape,\n              sparseValues.dtype === defaultValue.dtype ?\n                  defaultValue :\n                  ops.cast(defaultValue, sparseValues.dtype))];\n        }\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'slice_join';\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}