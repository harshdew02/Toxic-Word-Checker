{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Dilation2D, util } from '@tensorflow/tfjs-core';\nexport var dilation2DConfig = {\n  kernelName: Dilation2D,\n  backendName: 'cpu',\n  kernelFunc: function kernelFunc(_ref) {\n    var inputs = _ref.inputs,\n      backend = _ref.backend,\n      attrs = _ref.attrs;\n    var x = inputs.x,\n      filter = inputs.filter;\n    var strides = attrs.strides,\n      pad = attrs.pad,\n      dilations = attrs.dilations;\n    var cpuBackend = backend;\n    var xVals = cpuBackend.data.get(x.dataId).values;\n    var xRank = x.shape.length;\n    var filterVals = cpuBackend.data.get(filter.dataId).values;\n    var filterRank = filter.shape.length;\n    var _backend_util$compute = backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad, 'NHWC' /* dataFormat */, dilations),\n      batchSize = _backend_util$compute.batchSize,\n      inHeight = _backend_util$compute.inHeight,\n      inWidth = _backend_util$compute.inWidth,\n      inChannels = _backend_util$compute.inChannels,\n      outHeight = _backend_util$compute.outHeight,\n      outWidth = _backend_util$compute.outWidth,\n      padInfo = _backend_util$compute.padInfo,\n      strideHeight = _backend_util$compute.strideHeight,\n      strideWidth = _backend_util$compute.strideWidth,\n      filterHeight = _backend_util$compute.filterHeight,\n      filterWidth = _backend_util$compute.filterWidth,\n      dilationHeight = _backend_util$compute.dilationHeight,\n      dilationWidth = _backend_util$compute.dilationWidth,\n      outShape = _backend_util$compute.outShape;\n    var outSize = util.sizeFromShape(outShape);\n    var outRank = outShape.length;\n    var outputVals = util.getArrayFromDType(x.dtype, outSize);\n    // Upsampling the input by fill in `dilation size - 1` values between each\n    // input value.\n    // This implementation follows the TF c++ implementation:\n    // https://github.com/tensorflow/tensorflow/blob/d9a3a849edc198e90172bc58eb293de457f9d986/tensorflow/core/kernels/dilation_ops.cc\n    for (var b = 0; b < batchSize; ++b) {\n      for (var hOut = 0; hOut < outHeight; ++hOut) {\n        var hBeg = hOut * strideHeight - padInfo.top;\n        for (var wOut = 0; wOut < outWidth; ++wOut) {\n          var wBeg = wOut * strideWidth - padInfo.left;\n          for (var d = 0; d < inChannels; ++d) {\n            var curVal = Number.MIN_SAFE_INTEGER;\n            for (var h = 0; h < filterHeight; ++h) {\n              var hIn = hBeg + h * dilationHeight;\n              if (hIn >= 0 && hIn < inHeight) {\n                for (var w = 0; w < filterWidth; ++w) {\n                  var wIn = wBeg + w * dilationWidth;\n                  if (wIn >= 0 && wIn < inWidth) {\n                    var xIndex = util.locToIndex([b, hIn, wIn, d], xRank, util.computeStrides(x.shape));\n                    var filterIndex = util.locToIndex([h, w, d], filterRank, util.computeStrides(filter.shape));\n                    var val = xVals[xIndex] + filterVals[filterIndex];\n                    if (val > curVal) {\n                      curVal = val;\n                    }\n                  }\n                }\n              }\n            }\n            var outputIndex = util.locToIndex([b, hOut, wOut, d], outRank, util.computeStrides(outShape));\n            outputVals[outputIndex] = curVal;\n          }\n        }\n      }\n    }\n    var dataId = cpuBackend.write(util.toTypedArray(outputVals, x.dtype), outShape, x.dtype);\n    return {\n      dataId: dataId,\n      shape: outShape,\n      dtype: x.dtype\n    };\n  }\n};","map":{"version":3,"mappings":"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","names":["backend_util","Dilation2D","util","dilation2DConfig","kernelName","backendName","kernelFunc","inputs","backend","attrs","x","filter","strides","pad","dilations","cpuBackend","xVals","data","get","dataId","values","xRank","shape","length","filterVals","filterRank","computeDilation2DInfo","batchSize","inHeight","inWidth","inChannels","outHeight","outWidth","padInfo","strideHeight","strideWidth","filterHeight","filterWidth","dilationHeight","dilationWidth","outShape","outSize","sizeFromShape","outRank","outputVals","getArrayFromDType","dtype","b","hOut","hBeg","top","wOut","wBeg","left","d","curVal","Number","MIN_SAFE_INTEGER","h","hIn","w","wIn","xIndex","locToIndex","computeStrides","filterIndex","val","outputIndex","write","toTypedArray"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-backend-cpu\\src\\kernels\\Dilation2D.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Dilation2D, Dilation2DAttrs, Dilation2DInputs, KernelConfig, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport const dilation2DConfig: KernelConfig = {\n  kernelName: Dilation2D,\n  backendName: 'cpu',\n  kernelFunc: ({inputs, backend, attrs}) => {\n    const {x, filter} = inputs as Dilation2DInputs;\n    const {strides, pad, dilations} = attrs as unknown as Dilation2DAttrs;\n    const cpuBackend = backend as MathBackendCPU;\n\n    const xVals = cpuBackend.data.get(x.dataId).values as TypedArray;\n    const xRank = x.shape.length;\n\n    const filterVals = cpuBackend.data.get(filter.dataId).values as TypedArray;\n    const filterRank = filter.shape.length;\n\n    const {\n      batchSize,\n      inHeight,\n      inWidth,\n      inChannels,\n      outHeight,\n      outWidth,\n      padInfo,\n      strideHeight,\n      strideWidth,\n      filterHeight,\n      filterWidth,\n      dilationHeight,\n      dilationWidth,\n      outShape\n    } =\n        backend_util.computeDilation2DInfo(\n            x.shape as [number, number, number, number],\n            filter.shape as [number, number, number], strides, pad,\n            'NHWC' /* dataFormat */, dilations);\n\n    const outSize = util.sizeFromShape(outShape);\n    const outRank = outShape.length;\n    const outputVals = util.getArrayFromDType(x.dtype, outSize);\n\n    // Upsampling the input by fill in `dilation size - 1` values between each\n    // input value.\n    // This implementation follows the TF c++ implementation:\n    // https://github.com/tensorflow/tensorflow/blob/d9a3a849edc198e90172bc58eb293de457f9d986/tensorflow/core/kernels/dilation_ops.cc\n    for (let b = 0; b < batchSize; ++b) {\n      for (let hOut = 0; hOut < outHeight; ++hOut) {\n        const hBeg = hOut * strideHeight - padInfo.top;\n        for (let wOut = 0; wOut < outWidth; ++wOut) {\n          const wBeg = wOut * strideWidth - padInfo.left;\n          for (let d = 0; d < inChannels; ++d) {\n            let curVal = Number.MIN_SAFE_INTEGER;\n            for (let h = 0; h < filterHeight; ++h) {\n              const hIn = hBeg + h * dilationHeight;\n              if (hIn >= 0 && hIn < inHeight) {\n                for (let w = 0; w < filterWidth; ++w) {\n                  const wIn = wBeg + w * dilationWidth;\n                  if (wIn >= 0 && wIn < inWidth) {\n                    const xIndex = util.locToIndex(\n                        [b, hIn, wIn, d], xRank, util.computeStrides(x.shape));\n                    const filterIndex = util.locToIndex(\n                        [h, w, d], filterRank,\n                        util.computeStrides(filter.shape));\n                    const val = xVals[xIndex] + filterVals[filterIndex];\n                    if (val > curVal) {\n                      curVal = val;\n                    }\n                  }\n                }\n              }\n            }\n            const outputIndex = util.locToIndex(\n                [b, hOut, wOut, d], outRank, util.computeStrides(outShape));\n            outputVals[outputIndex] = curVal;\n          }\n        }\n      }\n    }\n\n    const dataId = cpuBackend.write(\n        util.toTypedArray(outputVals, x.dtype), outShape, x.dtype);\n\n    return {dataId, shape: outShape, dtype: x.dtype};\n  }\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}