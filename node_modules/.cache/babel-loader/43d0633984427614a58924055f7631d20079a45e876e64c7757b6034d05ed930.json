{"ast":null,"code":"import _createForOfIteratorHelper from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var RowPartitionType;\n(function (RowPartitionType) {\n  RowPartitionType[RowPartitionType[\"FIRST_DIM_SIZE\"] = 0] = \"FIRST_DIM_SIZE\";\n  RowPartitionType[RowPartitionType[\"VALUE_ROWIDS\"] = 1] = \"VALUE_ROWIDS\";\n  RowPartitionType[RowPartitionType[\"ROW_LENGTHS\"] = 2] = \"ROW_LENGTHS\";\n  RowPartitionType[RowPartitionType[\"ROW_SPLITS\"] = 3] = \"ROW_SPLITS\";\n  RowPartitionType[RowPartitionType[\"ROW_LIMITS\"] = 4] = \"ROW_LIMITS\";\n  RowPartitionType[RowPartitionType[\"ROW_STARTS\"] = 5] = \"ROW_STARTS\";\n})(RowPartitionType || (RowPartitionType = {}));\nexport function combineRaggedTensorToTensorShapes(raggedRank, shape, valueShape) {\n  // Test for consistency of valueShape and shape specified.\n  // If shape is unspecified and valueShape is specified, then copy\n  // over the size from the valueShape dimension.\n  var outputShape = new Array();\n  if (valueShape == null && shape == null) {\n    return outputShape;\n  }\n  if (shape == null) {\n    // Here, value_shape must be of known size.\n    while (outputShape.length < raggedRank + valueShape.length) {\n      outputShape.push(-1);\n    }\n  } else {\n    outputShape = shape.slice();\n  }\n  if (valueShape == null) {\n    return outputShape;\n  }\n  // At this point, valueShape and output_shape have known ranks.\n  if (raggedRank + valueShape.length !== outputShape.length) {\n    throw new Error(\"rt input.shape and shape=\".concat(shape, \" are incompatible: rt input.rank = \").concat(raggedRank + valueShape.length, \", but shape.rank = \").concat(outputShape.length));\n  }\n  for (var i = 1; i < valueShape.length; ++i) {\n    var valueDim = valueShape[i];\n    var outputShapeDimIndex = outputShape[outputShape.length - valueShape.length + i];\n    var outputShapeDim = outputShape[outputShapeDimIndex];\n    if (valueDim >= 0) {\n      if (outputShapeDim >= 0) {\n        if (outputShapeDim !== valueDim) {\n          throw new Error(\"rt input.shape and shape=\".concat(shape, \" are incompatible: rt input.shape[\").concat(i + raggedRank, \"] = \").concat(valueDim, \" but shape[\").concat(i + raggedRank, \"] = \").concat(outputShapeDim));\n        }\n      } else {\n        outputShape[outputShapeDimIndex] = valueDim;\n      }\n    }\n  }\n  return outputShape;\n}\nexport function getRowPartitionTypesHelper(rowPartitionTypeStrings) {\n  var stringToType = {\n    'FIRST_DIM_SIZE': RowPartitionType.FIRST_DIM_SIZE,\n    'VALUE_ROWIDS': RowPartitionType.VALUE_ROWIDS,\n    'ROW_LENGTHS': RowPartitionType.ROW_LENGTHS,\n    'ROW_SPLITS': RowPartitionType.ROW_SPLITS,\n    'ROW_LIMITS': RowPartitionType.ROW_LIMITS,\n    'ROW_STARTS': RowPartitionType.ROW_STARTS\n  };\n  var result = [];\n  var _iterator = _createForOfIteratorHelper(rowPartitionTypeStrings),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var typeStr = _step.value;\n      if (typeStr in stringToType) {\n        result.push(stringToType[typeStr]);\n      } else {\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return result;\n}\nexport function getRaggedRank(rowPartitionTypes) {\n  if (rowPartitionTypes.length === 0) {\n    return 0;\n  }\n  if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n    return rowPartitionTypes.length - 1;\n  }\n  return rowPartitionTypes.length;\n}\nexport function validateDefaultValueShape(defaultValueShape, valueShape) {\n  if (defaultValueShape == null || valueShape == null) {\n    return;\n  }\n  var defaultNDims = defaultValueShape.length;\n  var valuesNDims = valueShape.length;\n  if (defaultNDims >= valuesNDims) {\n    throw new Error(\"defaultValue.shape=\".concat(defaultValueShape, \" and ragged tensor flatValues.shape=\").concat(valueShape, \", are incompatible: defaultValue.rank = \").concat(defaultNDims, \" must be less than ragged tensor input flatValues.rank = \").concat(valuesNDims, \")\"));\n  }\n  for (var i = 0; i < Math.min(defaultNDims, valuesNDims - 1); ++i) {\n    var defaultDim = defaultValueShape[i];\n    var valueDim = valueShape[i + 1];\n    if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 && defaultDim !== valueDim) {\n      throw new Error(\"defaultValue.shape=\".concat(defaultValueShape, \", and ragged tensor input flatValues.shape=\").concat(valueShape, \" are incompatible: defaultValue.shape[\").concat(i - defaultValueShape.length, \"] = \").concat(defaultDim, \" but ragged tensor input.flatValues.shape[\").concat(i - defaultValueShape.length, \"] = \").concat(valueDim));\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["RowPartitionType","combineRaggedTensorToTensorShapes","raggedRank","shape","valueShape","outputShape","Array","length","push","slice","Error","i","valueDim","outputShapeDimIndex","outputShapeDim","getRowPartitionTypesHelper","rowPartitionTypeStrings","stringToType","FIRST_DIM_SIZE","VALUE_ROWIDS","ROW_LENGTHS","ROW_SPLITS","ROW_LIMITS","ROW_STARTS","result","typeStr","getRaggedRank","rowPartitionTypes","validateDefaultValueShape","defaultValueShape","defaultNDims","valuesNDims","Math","min","defaultDim"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\node_modules\\@tensorflow\\tfjs-core\\src\\ops\\ragged_to_dense_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport enum RowPartitionType {\n  FIRST_DIM_SIZE,\n  VALUE_ROWIDS,\n  ROW_LENGTHS,\n  ROW_SPLITS,\n  ROW_LIMITS,\n  ROW_STARTS\n}\n\nexport function combineRaggedTensorToTensorShapes(\n    raggedRank: number, shape: number[], valueShape: number[]) {\n  // Test for consistency of valueShape and shape specified.\n  // If shape is unspecified and valueShape is specified, then copy\n  // over the size from the valueShape dimension.\n\n  let outputShape: number[] = new Array();\n  if (valueShape == null && shape == null) {\n    return outputShape;\n  }\n\n  if (shape == null) {\n    // Here, value_shape must be of known size.\n    while (outputShape.length < raggedRank + valueShape.length) {\n      outputShape.push(-1);\n    }\n  } else {\n    outputShape = shape.slice();\n  }\n  if (valueShape == null) {\n    return outputShape;\n  }\n  // At this point, valueShape and output_shape have known ranks.\n  if (raggedRank + valueShape.length !== outputShape.length) {\n    throw new Error(\n        `rt input.shape and shape=${shape} are incompatible: rt input.rank = ${\n            raggedRank +\n            valueShape.length}, but shape.rank = ${outputShape.length}`);\n  }\n\n  for (let i = 1; i < valueShape.length; ++i) {\n    const valueDim = valueShape[i];\n    const outputShapeDimIndex =\n        outputShape[outputShape.length - valueShape.length + i];\n    const outputShapeDim = outputShape[outputShapeDimIndex];\n\n    if (valueDim >= 0) {\n      if (outputShapeDim >= 0) {\n        if (outputShapeDim !== valueDim) {\n          throw new Error(`rt input.shape and shape=${\n              shape} are incompatible: rt input.shape[${i + raggedRank}] = ${\n              valueDim} but shape[${i + raggedRank}] = ${outputShapeDim}`);\n        }\n      } else {\n        outputShape[outputShapeDimIndex] = valueDim;\n      }\n    }\n  }\n  return outputShape;\n}\n\nexport function getRowPartitionTypesHelper(rowPartitionTypeStrings: string[]) {\n  const stringToType = {\n    'FIRST_DIM_SIZE': RowPartitionType.FIRST_DIM_SIZE,\n    'VALUE_ROWIDS': RowPartitionType.VALUE_ROWIDS,\n    'ROW_LENGTHS': RowPartitionType.ROW_LENGTHS,\n    'ROW_SPLITS': RowPartitionType.ROW_SPLITS,\n    'ROW_LIMITS': RowPartitionType.ROW_LIMITS,\n    'ROW_STARTS': RowPartitionType.ROW_STARTS\n  };\n\n  const result: RowPartitionType[] = [];\n  for (const typeStr of rowPartitionTypeStrings) {\n    if (typeStr in stringToType) {\n      result.push(stringToType[typeStr as keyof typeof stringToType]);\n    } else {\n      break;\n    }\n  }\n\n  return result;\n}\n\nexport function getRaggedRank(rowPartitionTypes: RowPartitionType[]) {\n  if (rowPartitionTypes.length === 0) {\n    return 0;\n  }\n  if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n    return rowPartitionTypes.length - 1;\n  }\n  return rowPartitionTypes.length;\n}\n\nexport function validateDefaultValueShape(\n    defaultValueShape: number[], valueShape: number[]) {\n  if (defaultValueShape == null || valueShape == null) {\n    return;\n  }\n\n  const defaultNDims = defaultValueShape.length;\n  const valuesNDims = valueShape.length;\n  if (defaultNDims >= valuesNDims) {\n    throw new Error(`defaultValue.shape=${\n        defaultValueShape} and ragged tensor flatValues.shape=${\n        valueShape}, are incompatible: defaultValue.rank = ${\n        defaultNDims} must be less than ragged tensor input flatValues.rank = ${\n        valuesNDims})`);\n  }\n  for (let i = 0; i < Math.min(defaultNDims, valuesNDims - 1); ++i) {\n    const defaultDim = defaultValueShape[i];\n    const valueDim = valueShape[i + 1];\n    if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 &&\n        defaultDim !== valueDim) {\n      throw new Error(`defaultValue.shape=${\n          defaultValueShape}, and ragged tensor input flatValues.shape=${\n          valueShape} are incompatible: defaultValue.shape[${\n          i - defaultValueShape.length}] = ${\n          defaultDim} but ragged tensor input.flatValues.shape[${\n          i - defaultValueShape.length}] = ${valueDim}`);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}