{"ast":null,"code":"import _slicedToArray from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinearGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeBilinearGrad(args) {\n  var inputs = args.inputs,\n    backend = args.backend,\n    attrs = args.attrs;\n  var images = inputs.images,\n    dy = inputs.dy;\n  var alignCorners = attrs.alignCorners;\n  assertNotComplex([dy, images], 'resizeBilinearGrad');\n  var imagesStrides = util.computeStrides(images.shape);\n  var _images$shape = _slicedToArray(images.shape, 4),\n    batch = _images$shape[0],\n    xHeight = _images$shape[1],\n    xWidth = _images$shape[2],\n    depth = _images$shape[3];\n  var _dy$shape = _slicedToArray(dy.shape, 3),\n    yHeight = _dy$shape[1],\n    yWidth = _dy$shape[2];\n  var output = new Float32Array(batch * xHeight * xWidth * depth);\n  // In the backwards pass, we want to find the pixels that were generated\n  // for each pixel in the input image the forward pass and add the\n  // corresponding coefficient from dy to the gradient (with some\n  // interpolation).\n  var effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n  var effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n  var heightScale = effectiveXSize[0] / effectiveYSize[0];\n  var widthScale = effectiveXSize[1] / effectiveYSize[1];\n  // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n  var dyValues = backend.data.get(dy.dataId).values;\n  var offset = 0;\n  for (var b = 0; b < batch; b++) {\n    var bOffset = b * imagesStrides[0];\n    for (var r = 0; r < yHeight; r++) {\n      var dxR = r * heightScale;\n      var topDxRIndex = Math.floor(dxR);\n      var bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n      var topDxROffset = bOffset + topDxRIndex * imagesStrides[1];\n      var bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];\n      var dxRLerp = dxR - topDxRIndex;\n      var inverseDxRLerp = 1.0 - dxRLerp;\n      for (var c = 0; c < yWidth; c++) {\n        var dxC = c * widthScale;\n        var leftDxCIndex = Math.floor(dxC);\n        var rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n        var dxCLerp = dxC - leftDxCIndex;\n        var inverseDxCLerp = 1.0 - dxCLerp;\n        var topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];\n        var topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];\n        var bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];\n        var bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];\n        var inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n        var inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n        var dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n        var dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n        for (var d = 0; d < depth; d++) {\n          var dyVal = dyValues[offset++];\n          output[topLeftRCOffset + d] += dyVal * inverseDxRLerpTimesInverseDxCLerp;\n          output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n          output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n          output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n        }\n      }\n    }\n  }\n  return backend.makeTensorInfo([batch, xWidth, xHeight, depth], 'float32', output);\n}\nexport var resizeBilinearGradConfig = {\n  kernelName: ResizeBilinearGrad,\n  backendName: 'cpu',\n  kernelFunc: resizeBilinearGrad\n};","map":{"version":3,"mappings":"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","names":["ResizeBilinearGrad","util","assertNotComplex","resizeBilinearGrad","args","inputs","backend","attrs","images","dy","alignCorners","imagesStrides","computeStrides","shape","batch","xHeight","xWidth","depth","yHeight","yWidth","output","Float32Array","effectiveXSize","effectiveYSize","heightScale","widthScale","dyValues","data","get","dataId","values","offset","b","bOffset","r","dxR","topDxRIndex","Math","floor","bottomDxRIndex","min","ceil","topDxROffset","bottomDxROffset","dxRLerp","inverseDxRLerp","c","dxC","leftDxCIndex","rightDxCIndex","dxCLerp","inverseDxCLerp","topLeftRCOffset","topRightRCOffset","bottomLeftRCOffset","bottomRightRCOffset","inverseDxRLerpTimesInverseDxCLerp","inverseDxRLerpTimesDxCLerp","dxRLerpTimesInverseDxCLerp","dxRLerpTimesDxCLerp","d","dyVal","makeTensorInfo","resizeBilinearGradConfig","kernelName","backendName","kernelFunc"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-backend-cpu\\src\\kernels\\ResizeBilinearGrad.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, ResizeBilinearGrad, ResizeBilinearGradAttrs, ResizeBilinearGradInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nexport function resizeBilinearGrad(args: {\n  inputs: ResizeBilinearGradInputs,\n  backend: MathBackendCPU,\n  attrs: ResizeBilinearGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images, dy} = inputs;\n  const {alignCorners} = attrs;\n\n  assertNotComplex([dy, images], 'resizeBilinearGrad');\n\n  const imagesStrides = util.computeStrides(images.shape);\n\n  const [batch, xHeight, xWidth, depth] = images.shape;\n  const [, yHeight, yWidth] = dy.shape;\n\n  const output = new Float32Array(batch * xHeight * xWidth * depth);\n\n  // In the backwards pass, we want to find the pixels that were generated\n  // for each pixel in the input image the forward pass and add the\n  // corresponding coefficient from dy to the gradient (with some\n  // interpolation).\n\n  const effectiveXSize: [number, number] = [\n    (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n    (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n  ];\n\n  const effectiveYSize: [number, number] = [\n    (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n    (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n  ];\n\n  const heightScale = effectiveXSize[0] / effectiveYSize[0];\n  const widthScale = effectiveXSize[1] / effectiveYSize[1];\n\n  // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n  const dyValues = backend.data.get(dy.dataId).values as TypedArray;\n  let offset = 0;\n  for (let b = 0; b < batch; b++) {\n    const bOffset = b * imagesStrides[0];\n    for (let r = 0; r < yHeight; r++) {\n      const dxR = r * heightScale;\n      const topDxRIndex = Math.floor(dxR);\n      const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n\n      const topDxROffset = bOffset + topDxRIndex * imagesStrides[1];\n      const bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];\n\n      const dxRLerp = dxR - topDxRIndex;\n      const inverseDxRLerp = 1.0 - dxRLerp;\n      for (let c = 0; c < yWidth; c++) {\n        const dxC = c * widthScale;\n        const leftDxCIndex = Math.floor(dxC);\n        const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n        const dxCLerp = dxC - leftDxCIndex;\n        const inverseDxCLerp = 1.0 - dxCLerp;\n\n        const topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];\n        const topRightRCOffset =\n            topDxROffset + rightDxCIndex * imagesStrides[2];\n        const bottomLeftRCOffset =\n            bottomDxROffset + leftDxCIndex * imagesStrides[2];\n        const bottomRightRCOffset =\n            bottomDxROffset + rightDxCIndex * imagesStrides[2];\n\n        const inverseDxRLerpTimesInverseDxCLerp =\n            inverseDxRLerp * inverseDxCLerp;\n        const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n        const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n        const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n        for (let d = 0; d < depth; d++) {\n          const dyVal = dyValues[offset++];\n          output[topLeftRCOffset + d] +=\n              dyVal * inverseDxRLerpTimesInverseDxCLerp;\n          output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n          output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n          output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo(\n      [batch, xWidth, xHeight, depth], 'float32', output);\n}\n\nexport const resizeBilinearGradConfig: KernelConfig = {\n  kernelName: ResizeBilinearGrad,\n  backendName: 'cpu',\n  kernelFunc: resizeBilinearGrad as unknown as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}