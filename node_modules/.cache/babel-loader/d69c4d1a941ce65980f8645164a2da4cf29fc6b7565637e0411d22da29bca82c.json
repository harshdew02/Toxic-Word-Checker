{"ast":null,"code":"import _slicedToArray from \"E:/react-detect-toxicity-in-a-chat-app-youtube-2/Toxic-Word-Checker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Prod, upcastType, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { transpose } from './Transpose';\nexport function prodImpl(xShape, xDtype, xVals, reductionAxes) {\n  var _backend_util$compute = backend_util.computeOutAndReduceShapes(xShape, reductionAxes),\n    _backend_util$compute2 = _slicedToArray(_backend_util$compute, 2),\n    outShape = _backend_util$compute2[0],\n    reduceShape = _backend_util$compute2[1];\n  var outDtype = upcastType(xDtype, 'int32');\n  var outVals = util.makeZerosTypedArray(util.sizeFromShape(outShape), outDtype);\n  var reduceSize = util.sizeFromShape(reduceShape);\n  for (var i = 0; i < outVals.length; ++i) {\n    var offset = i * reduceSize;\n    var _prod = 1;\n    for (var j = 0; j < reduceSize; ++j) {\n      _prod *= xVals[offset + j];\n    }\n    outVals[i] = _prod;\n  }\n  return {\n    outVals: outVals,\n    outShape: outShape,\n    outDtype: outDtype\n  };\n}\nexport function prod(args) {\n  var inputs = args.inputs,\n    backend = args.backend,\n    attrs = args.attrs;\n  var x = inputs.x;\n  var axis = attrs.axis,\n    keepDims = attrs.keepDims;\n  assertNotComplex(x, 'prod');\n  var xRank = x.shape.length;\n  var axes = util.parseAxisParam(axis, x.shape);\n  var permutation = backend_util.getAxesPermutation(axes, xRank);\n  var reductionAxes = axes;\n  var permutedX = x;\n  var intermediateTensorInfos = [];\n  if (permutation != null) {\n    permutedX = transpose({\n      inputs: {\n        x: x\n      },\n      backend: backend,\n      attrs: {\n        perm: permutation\n      }\n    });\n    intermediateTensorInfos.push(permutedX);\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n  var xVals = backend.data.get(permutedX.dataId).values;\n  var _prodImpl = prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes),\n    outVals = _prodImpl.outVals,\n    outShape = _prodImpl.outShape,\n    outDtype = _prodImpl.outDtype;\n  var resultShape = outShape;\n  if (keepDims) {\n    resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n  }\n  intermediateTensorInfos.forEach(function (t) {\n    return backend.disposeIntermediateTensorInfo(t);\n  });\n  return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\nexport var prodConfig = {\n  kernelName: Prod,\n  backendName: 'cpu',\n  kernelFunc: prod\n};","map":{"version":3,"mappings":"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","names":["backend_util","Prod","upcastType","util","assertNotComplex","transpose","prodImpl","xShape","xDtype","xVals","reductionAxes","computeOutAndReduceShapes","outShape","reduceShape","outDtype","outVals","makeZerosTypedArray","sizeFromShape","reduceSize","i","length","offset","prod","j","args","inputs","backend","attrs","x","axis","keepDims","xRank","shape","axes","parseAxisParam","permutation","getAxesPermutation","permutedX","intermediateTensorInfos","perm","push","getInnerMostAxes","data","get","dataId","values","dtype","resultShape","expandShapeToKeepDim","forEach","disposeIntermediateTensorInfo","t","makeTensorInfo","prodConfig","kernelName","backendName","kernelFunc"],"sources":["E:\\react-detect-toxicity-in-a-chat-app-youtube-2\\Toxic-Word-Checker\\node_modules\\@tensorflow\\tfjs-backend-cpu\\src\\kernels\\Prod.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, KernelConfig, KernelFunc, Prod, ProdAttrs, ProdInputs, TensorInfo, TypedArray, upcastType, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {transpose} from './Transpose';\n\nexport function prodImpl(\n    xShape: number[], xDtype: DataType, xVals: TypedArray,\n    reductionAxes: number[]):\n    {outVals: TypedArray, outShape: number[], outDtype: DataType} {\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(xShape, reductionAxes);\n  const outDtype = upcastType(xDtype, 'int32');\n  const outVals = util.makeZerosTypedArray(\n                      util.sizeFromShape(outShape), outDtype) as TypedArray;\n  const reduceSize = util.sizeFromShape(reduceShape);\n\n  for (let i = 0; i < outVals.length; ++i) {\n    const offset = i * reduceSize;\n    let prod = 1;\n    for (let j = 0; j < reduceSize; ++j) {\n      prod *= xVals[offset + j];\n    }\n    outVals[i] = prod;\n  }\n\n  return {outVals, outShape, outDtype};\n}\n\nexport function prod(\n    args: {inputs: ProdInputs, backend: MathBackendCPU, attrs: ProdAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  assertNotComplex(x, 'prod');\n\n  const xRank = x.shape.length;\n  const axes = util.parseAxisParam(axis, x.shape);\n\n  const permutation = backend_util.getAxesPermutation(axes, xRank);\n  let reductionAxes = axes;\n  let permutedX = x;\n  const intermediateTensorInfos = [];\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n    intermediateTensorInfos.push(permutedX);\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n\n  const xVals = backend.data.get(permutedX.dataId).values as TypedArray;\n  const {outVals, outShape, outDtype} =\n      prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);\n\n  let resultShape = outShape;\n  if (keepDims) {\n    resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n  }\n\n  intermediateTensorInfos.forEach(\n      t => backend.disposeIntermediateTensorInfo(t));\n\n  return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\n\nexport const prodConfig: KernelConfig = {\n  kernelName: Prod,\n  backendName: 'cpu',\n  kernelFunc: prod as unknown as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}